
package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
      update()
      callback?.onSuccess()
    }
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result.Drawable(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result.Bitmap(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {

    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3

import com.squareup.picasso3.RequestHandler.Result


interface Transformation {
  
  fun transform(source: Result.Bitmap): Result.Bitmap

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.Picasso.LoadedFrom
import java.io.IOException


abstract class RequestHandler {
  
  sealed class Result constructor(
    
    @JvmField val loadedFrom: LoadedFrom,
    
    @JvmField val exifRotation: Int = 0
  ) {
    class Bitmap @JvmOverloads constructor(
      val bitmap: android.graphics.Bitmap,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)

    class Drawable @JvmOverloads constructor(
      val drawable: android.graphics.drawable.Drawable,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)
  }

  interface Callback {
    fun onSuccess(result: Result?)
    fun onError(t: Throwable)
  }

  
  abstract fun canHandleRequest(data: Request): Boolean

  
  @Throws(IOException::class)
  abstract fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  )

  open val retryCount = 0

  open fun shouldRetry(
    airplaneMode: Boolean,
    info: NetworkInfo?
  ) = false

  open fun supportsReplay() = false
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result.Bitmap): Result.Bitmap {
    val bitmap = source.bitmap

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result.Bitmap(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
    update()
    callback?.onSuccess()
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    val bitmap = result.bitmap
    if (bitmap != null) {
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3


interface Transformation {
  
  fun transform(source: RequestHandler.Result): RequestHandler.Result

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result): Result {
    val bitmap = source.bitmap ?: return source

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import okhttp3.Headers
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val headers: Headers? = builder.headers

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0
    var headers: Headers? = null

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    fun addHeader(
      name: String,
      value: String
    ) = apply {
      this.headers = (headers?.newBuilder() ?: Headers.Builder())
        .add(name, value)
        .build()
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    val requestHeaders = request.headers
    if (requestHeaders != null) {
      builder.headers(requestHeaders)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun customHeaders() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(
      picasso,
      key = URI_KEY_1,
      uri = URI_1,
      headers = mapOf(CUSTOM_HEADER_NAME to CUSTOM_HEADER_VALUE)
    )
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          with(requests.first.headers) {
            assertThat(names()).containsExactly(CUSTOM_HEADER_NAME)
            assertThat(values(CUSTOM_HEADER_NAME)).containsExactly(CUSTOM_HEADER_VALUE)
          }
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3.stats

import android.graphics.Bitmap
import android.util.Log
import androidx.core.graphics.BitmapCompat
import com.squareup.picasso3.EventListener
import com.squareup.picasso3.Picasso
import okio.Buffer
import okio.BufferedSink
import java.io.IOException
import kotlin.math.ceil

class StatsEventListener : EventListener {
  private var maxCacheSize = 0
  private var cacheSize = 0

  private var cacheHits = 0L
  private var cacheMisses = 0L
  private var totalDownloadSize = 0L
  private var totalOriginalBitmapSize = 0L
  private var totalTransformedBitmapSize = 0L

  private var averageDownloadSize = 0.0
  private var averageOriginalBitmapSize = 0.0
  private var averageTransformedBitmapSize = 0.0

  private var downloadCount = 0
  private var originalBitmapCount = 0
  private var transformedBitmapCount = 0

  override fun cacheMaxSize(maxSize: Int) {
    maxCacheSize = maxSize
  }

  override fun cacheSize(size: Int) {
    cacheSize = size
  }

  override fun cacheHit() {
    cacheHits++
  }

  override fun cacheMiss() {
    cacheMisses++
  }

  override fun downloadFinished(size: Long) {
    downloadCount++
    totalDownloadSize += size
    averageDownloadSize = average(downloadCount, totalDownloadSize)
  }

  override fun bitmapDecoded(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    originalBitmapCount++
    totalOriginalBitmapSize += bitmapSize
    averageOriginalBitmapSize = average(originalBitmapCount, totalOriginalBitmapSize)
  }

  override fun bitmapTransformed(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    transformedBitmapCount++
    totalTransformedBitmapSize += bitmapSize
    averageTransformedBitmapSize = average(originalBitmapCount, totalTransformedBitmapSize)
  }

  fun getSnapshot() = Snapshot(
      maxCacheSize, cacheSize, cacheHits, cacheMisses,
      totalDownloadSize, totalOriginalBitmapSize, totalTransformedBitmapSize, averageDownloadSize,
      averageOriginalBitmapSize, averageTransformedBitmapSize, downloadCount, originalBitmapCount,
      transformedBitmapCount, System.currentTimeMillis()
  )

  private fun average(
    count: Int,
    totalSize: Long
  ): Double = totalSize * 1.0 / count

  data class Snapshot(
    val maxSize: Int,
    val size: Int,
    val cacheHits: Long,
    val cacheMisses: Long,
    val totalDownloadSize: Long,
    val totalOriginalBitmapSize: Long,
    val totalTransformedBitmapSize: Long,
    val averageDownloadSize: Double,
    val averageOriginalBitmapSize: Double,
    val averageTransformedBitmapSize: Double,
    val downloadCount: Int,
    val originalBitmapCount: Int,
    val transformedBitmapCount: Int,
    val timeStamp: Long
  ) {
    
    fun dump() {
      val buffer = Buffer()
      try {
        dump(buffer)
      } catch (e: IOException) {
        throw AssertionError(e)
      }

      Log.i(Picasso.TAG, buffer.readUtf8())
    }

    
    @Throws(IOException::class)
    fun dump(sink: BufferedSink) {
      sink.writeUtf8("===============BEGIN PICASSO STATS ===============")
      sink.writeUtf8("\n")
      sink.writeUtf8("Memory Cache Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Max Cache Size: ")
      sink.writeUtf8(maxSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Size: ")
      sink.writeUtf8(size.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache % Full: ")
      sink.writeUtf8(ceil((size.toDouble() / maxSize * 100)).toInt().toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Hits: ")
      sink.writeUtf8(cacheHits.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Misses: ")
      sink.writeUtf8(cacheMisses.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Network Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Download Count: ")
      sink.writeUtf8(downloadCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Download Size: ")
      sink.writeUtf8(totalDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Download Size: ")
      sink.writeUtf8(averageDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Bitmap Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmaps Decoded: ")
      sink.writeUtf8(originalBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmap Size: ")
      sink.writeUtf8(totalOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmaps: ")
      sink.writeUtf8(transformedBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmap Size: ")
      sink.writeUtf8(totalTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Bitmap Size: ")
      sink.writeUtf8(averageOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Transformed Bitmap Size: ")
      sink.writeUtf8(averageTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("===============END PICASSO STATS ===============")
      sink.writeUtf8("\n")
    }
  }
}
<code block>
package com.example.picasso.provider

import com.squareup.picasso3.Picasso
import com.squareup.picasso3.stats.StatsEventListener


object PicassoProvider {
  private val instance: Picasso by lazy {
    Picasso
        .Builder(PicassoContentProvider.autoContext!!)
        .addEventListener(StatsEventListener())
        .build()
  }

  @JvmStatic
  fun get() = instance
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.util.Log
import androidx.core.graphics.BitmapCompat
import okio.Buffer
import okio.BufferedSink
import java.io.IOException
import kotlin.math.ceil

class StatsEventListener : EventListener {
  private var maxCacheSize = 0
  private var cacheSize = 0

  private var cacheHits = 0L
  private var cacheMisses = 0L
  private var totalDownloadSize = 0L
  private var totalOriginalBitmapSize = 0L
  private var totalTransformedBitmapSize = 0L

  private var averageDownloadSize = 0.0
  private var averageOriginalBitmapSize = 0.0
  private var averageTransformedBitmapSize = 0.0

  private var downloadCount = 0
  private var originalBitmapCount = 0
  private var transformedBitmapCount = 0

  override fun cacheMaxSize(maxSize: Int) {
    maxCacheSize = maxSize
  }

  override fun cacheSize(size: Int) {
    cacheSize = size
  }

  override fun cacheHit() {
    cacheHits++
  }

  override fun cacheMiss() {
    cacheMisses++
  }

  override fun downloadFinished(size: Long) {
    downloadCount++
    totalDownloadSize += size
    averageDownloadSize = average(downloadCount, totalDownloadSize)
  }

  override fun bitmapDecoded(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    originalBitmapCount++
    totalOriginalBitmapSize += bitmapSize
    averageOriginalBitmapSize = average(originalBitmapCount, totalOriginalBitmapSize)
  }

  override fun bitmapTransformed(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    transformedBitmapCount++
    totalTransformedBitmapSize += bitmapSize
    averageTransformedBitmapSize = average(originalBitmapCount, totalTransformedBitmapSize)
  }

  fun getSnapshot() = Snapshot(
      maxCacheSize, cacheSize, cacheHits, cacheMisses,
      totalDownloadSize, totalOriginalBitmapSize, totalTransformedBitmapSize, averageDownloadSize,
      averageOriginalBitmapSize, averageTransformedBitmapSize, downloadCount, originalBitmapCount,
      transformedBitmapCount, System.currentTimeMillis()
  )

  private fun average(
    count: Int,
    totalSize: Long
  ): Double = totalSize * 1.0 / count

  data class Snapshot(
    val maxSize: Int,
    val size: Int,
    val cacheHits: Long,
    val cacheMisses: Long,
    val totalDownloadSize: Long,
    val totalOriginalBitmapSize: Long,
    val totalTransformedBitmapSize: Long,
    val averageDownloadSize: Double,
    val averageOriginalBitmapSize: Double,
    val averageTransformedBitmapSize: Double,
    val downloadCount: Int,
    val originalBitmapCount: Int,
    val transformedBitmapCount: Int,
    val timeStamp: Long
  ) {
    
    fun dump() {
      val buffer = Buffer()
      try {
        dump(buffer)
      } catch (e: IOException) {
        throw AssertionError(e)
      }

      Log.i(Picasso.TAG, buffer.readUtf8())
    }

    
    @Throws(IOException::class)
    fun dump(sink: BufferedSink) {
      sink.writeUtf8("===============BEGIN PICASSO STATS ===============")
      sink.writeUtf8("\n")
      sink.writeUtf8("Memory Cache Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Max Cache Size: ")
      sink.writeUtf8(maxSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Size: ")
      sink.writeUtf8(size.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache % Full: ")
      sink.writeUtf8(ceil((size.toDouble() / maxSize * 100)).toInt().toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Hits: ")
      sink.writeUtf8(cacheHits.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Misses: ")
      sink.writeUtf8(cacheMisses.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Network Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Download Count: ")
      sink.writeUtf8(downloadCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Download Size: ")
      sink.writeUtf8(totalDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Download Size: ")
      sink.writeUtf8(averageDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Bitmap Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmaps Decoded: ")
      sink.writeUtf8(originalBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmap Size: ")
      sink.writeUtf8(totalOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmaps: ")
      sink.writeUtf8(transformedBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmap Size: ")
      sink.writeUtf8(totalTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Bitmap Size: ")
      sink.writeUtf8(averageOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Transformed Bitmap Size: ")
      sink.writeUtf8(averageTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("===============END PICASSO STATS ===============")
      sink.writeUtf8("\n")
    }
  }
}
<code block>
package com.example.picasso.provider

import com.squareup.picasso3.Picasso
import com.squareup.picasso3.StatsEventListener


object PicassoProvider {
  private val instance: Picasso by lazy {
    Picasso
        .Builder(PicassoContentProvider.autoContext!!)
        .addEventListener(StatsEventListener())
        .build()
  }

  @JvmStatic
  fun get() = instance
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.util.Log
import androidx.annotation.CallSuper
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService

internal abstract class Dispatcher internal constructor(
  private val context: Context,
  @get:JvmName("-service") internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val scansNetworkChanges: Boolean

  init {
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  @CallSuper open fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  abstract fun dispatchSubmit(action: Action)

  abstract fun dispatchCancel(action: Action)

  abstract fun dispatchPauseTag(tag: Any)

  abstract fun dispatchResumeTag(tag: Any)

  abstract fun dispatchComplete(hunter: BitmapHunter)

  abstract fun dispatchRetry(hunter: BitmapHunter)

  abstract fun dispatchFailed(hunter: BitmapHunter)

  abstract fun dispatchNetworkStateChange(info: NetworkInfo)

  abstract fun dispatchAirplaneModeChange(airplaneMode: Boolean)

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    const val RETRY_DELAY = 500L
    const val HUNTER_COMPLETE = 4
    const val NETWORK_STATE_CHANGE = 9
    const val REQUEST_BATCH_RESUME = 13
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = HandlerDispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import java.util.concurrent.ExecutorService

internal class HandlerDispatcher internal constructor(
  context: Context,
  service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache
) : Dispatcher(context, service, mainThreadHandler, cache) {

  private val dispatcherThread: DispatcherThread
  private val handler: Handler

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
  }

  override fun shutdown() {
    super.shutdown()

    dispatcherThread.quit()
  }

  override fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  override fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  override fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  override fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )
  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return HandlerDispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import android.util.Log
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService

internal class Dispatcher internal constructor(
  private val context: Context,
  @get:JvmName("-service") internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val dispatcherThread: DispatcherThread
  private val handler: Handler
  private val scansNetworkChanges: Boolean

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    dispatcherThread.quit()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.util.Log
import androidx.annotation.CallSuper
import androidx.annotation.MainThread
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap

internal abstract class BaseDispatcher internal constructor(
  private val context: Context,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) : Dispatcher {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val scansNetworkChanges: Boolean

  init {
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  @CallSuper override fun shutdown() {
    
    mainThreadHandler.post { receiver.unregister() }
  }

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (isShutdown()) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    dispatchSubmit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      dispatchBatchResumeMain(batch)
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (isShutdown()) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      dispatchSubmit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  @MainThread
  fun performCompleteMain(hunter: BitmapHunter) {
    hunter.picasso.complete(hunter)
  }

  @MainThread
  fun performBatchResumeMain(batch: List<Action>) {
    for (i in batch.indices) {
      val action = batch[i]
      action.picasso.resumeAction(action)
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    dispatchCompleteMain(hunter)
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  internal class NetworkBroadcastReceiver(
    private val dispatcher: BaseDispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_HUNTER
import com.squareup.picasso3.Utils.THREAD_PREFIX
import com.squareup.picasso3.Utils.VERB_DECODED
import com.squareup.picasso3.Utils.VERB_EXECUTING
import com.squareup.picasso3.Utils.VERB_JOINED
import com.squareup.picasso3.Utils.VERB_REMOVED
import com.squareup.picasso3.Utils.VERB_TRANSFORMED
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.io.InterruptedIOException
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Future
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicReference
import kotlinx.coroutines.Job

internal open class BitmapHunter(
  val picasso: Picasso,
  private val dispatcher: Dispatcher,
  private val cache: PlatformLruCache,
  action: Action,
  val requestHandler: RequestHandler
) : Runnable {
  val sequence: Int = SEQUENCE_GENERATOR.incrementAndGet()
  var priority: Picasso.Priority = action.request.priority
  var data: Request = action.request
  val key: String = action.request.key
  var retryCount: Int = requestHandler.retryCount

  var action: Action? = action
    private set
  var actions: MutableList<Action>? = null
    private set

  var future: Future<*>? = null

  var job: Job? = null

  var result: RequestHandler.Result? = null
    private set
  var exception: Exception? = null
    private set

  val isCancelled: Boolean
    get() = future?.isCancelled ?: job?.isCancelled ?: false

  override fun run() {
    val originalName = Thread.currentThread().name
    try {
      Thread.currentThread().name = getName()

      if (picasso.isLoggingEnabled) {
        log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this))
      }

      result = hunt()
      dispatcher.dispatchComplete(this)
    } catch (e: IOException) {
      exception = e
      if (retryCount > 0) {
        dispatcher.dispatchRetry(this)
      } else {
        dispatcher.dispatchFailed(this)
      }
    } catch (e: Exception) {
      exception = e
      dispatcher.dispatchFailed(this)
    } finally {
      Thread.currentThread().name = originalName
    }
  }

  fun getName() = NAME_BUILDER.get()!!.also {
    val name = data.name
    it.ensureCapacity(THREAD_PREFIX.length + name.length)
    it.replace(THREAD_PREFIX.length, it.length, name)
  }.toString()

  fun hunt(): Bitmap? {
    if (shouldReadFromMemoryCache(data.memoryPolicy)) {
      cache[key]?.let { bitmap ->
        picasso.cacheHit()
        if (picasso.isLoggingEnabled) {
          log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache")
        }

        return Bitmap(bitmap, LoadedFrom.MEMORY)
      }
    }

    if (retryCount == 0) {
      data = data.newBuilder().networkPolicy(NetworkPolicy.OFFLINE).build()
    }

    val resultReference = AtomicReference<RequestHandler.Result?>()
    val exceptionReference = AtomicReference<Throwable>()

    val latch = CountDownLatch(1)
    try {
      requestHandler.load(
        picasso = picasso,
        request = data,
        callback = object : RequestHandler.Callback {
          override fun onSuccess(result: RequestHandler.Result?) {
            resultReference.set(result)
            latch.countDown()
          }

          override fun onError(t: Throwable) {
            exceptionReference.set(t)
            latch.countDown()
          }
        }
      )

      latch.await()
    } catch (ie: InterruptedException) {
      val interruptedIoException = InterruptedIOException()
      interruptedIoException.initCause(ie)
      throw interruptedIoException
    }

    exceptionReference.get()?.let { throwable ->
      when (throwable) {
        is IOException, is Error, is RuntimeException -> throw throwable
        else -> throw RuntimeException(throwable)
      }
    }

    val result = resultReference.get() as? Bitmap ?: return null
    val bitmap = result.bitmap
    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_DECODED, data.logId())
    }
    picasso.bitmapDecoded(bitmap)

    val transformations = ArrayList<Transformation>(data.transformations.size + 1)
    if (data.needsMatrixTransform() || result.exifRotation != 0) {
      transformations += MatrixTransformation(data)
    }
    transformations += data.transformations

    val transformedResult =
      applyTransformations(picasso, data, transformations, result) ?: return null
    val transformedBitmap = transformedResult.bitmap
    picasso.bitmapTransformed(transformedBitmap)

    return transformedResult
  }

  fun attach(action: Action) {
    val loggingEnabled = picasso.isLoggingEnabled
    val request = action.request
    if (this.action == null) {
      this.action = action
      if (loggingEnabled) {
        if (actions.isNullOrEmpty()) {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), "to empty hunter")
        } else {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
        }
      }

      return
    }

    if (actions == null) {
      actions = ArrayList(3)
    }
    actions!!.add(action)

    if (loggingEnabled) {
      log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
    }

    val actionPriority = action.request.priority
    if (actionPriority.ordinal > priority.ordinal) {
      priority = actionPriority
    }
  }

  fun detach(action: Action) {
    val detached = when {
      this.action === action -> {
        this.action = null
        true
      }
      else -> actions?.remove(action) ?: false
    }

    
    
    if (detached && action.request.priority == priority) {
      priority = computeNewPriority()
    }

    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_REMOVED, action.request.logId(), getLogIdsForHunter(this, "from "))
    }
  }

  fun cancel(): Boolean =
    action == null && actions.isNullOrEmpty() && future?.cancel(false) ?: job?.let { it.cancel(); true } ?: false

  fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
    val hasRetries = retryCount > 0
    if (!hasRetries) {
      return false
    }
    retryCount--

    return requestHandler.shouldRetry(airplaneMode, info)
  }

  fun supportsReplay(): Boolean = requestHandler.supportsReplay()

  private fun computeNewPriority(): Picasso.Priority {
    val hasMultiple = actions?.isNotEmpty() ?: false
    val hasAny = action != null || hasMultiple

    
    if (!hasAny) {
      return Picasso.Priority.LOW
    }

    var newPriority = action?.request?.priority ?: Picasso.Priority.LOW

    actions?.let { actions ->
      
      for (i in actions.indices) {
        val priority = actions[i].request.priority
        if (priority.ordinal > newPriority.ordinal) {
          newPriority = priority
        }
      }
    }

    return newPriority
  }

  companion object {
    internal val NAME_BUILDER: ThreadLocal<StringBuilder> = object : ThreadLocal<StringBuilder>() {
      override fun initialValue(): StringBuilder = StringBuilder(THREAD_PREFIX)
    }
    val SEQUENCE_GENERATOR = AtomicInteger()
    internal val ERRORING_HANDLER: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean = true

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        callback.onError(IllegalStateException("Unrecognized type of request: $request"))
      }
    }

    fun forRequest(
      picasso: Picasso,
      dispatcher: Dispatcher,
      cache: PlatformLruCache,
      action: Action
    ): BitmapHunter {
      val request = action.request
      val requestHandlers = picasso.requestHandlers

      
      for (i in requestHandlers.indices) {
        val requestHandler = requestHandlers[i]
        if (requestHandler.canHandleRequest(request)) {
          return BitmapHunter(picasso, dispatcher, cache, action, requestHandler)
        }
      }

      return BitmapHunter(picasso, dispatcher, cache, action, ERRORING_HANDLER)
    }

    fun applyTransformations(
      picasso: Picasso,
      data: Request,
      transformations: List<Transformation>,
      result: Bitmap
    ): Bitmap? {
      var res = result

      for (i in transformations.indices) {
        val transformation = transformations[i]
        val newResult = try {
          val transformedResult = transformation.transform(res)
          if (picasso.isLoggingEnabled) {
            log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), "from transformations")
          }

          transformedResult
        } catch (e: RuntimeException) {
          Picasso.HANDLER.post {
            throw RuntimeException(
              "Transformation ${transformation.key()} crashed with exception.",
              e
            )
          }

          return null
        }

        val bitmap = newResult.bitmap
        if (bitmap.isRecycled) {
          Picasso.HANDLER.post {
            throw IllegalStateException(
              "Transformation ${transformation.key()} returned a recycled Bitmap."
            )
          }

          return null
        }

        res = newResult
      }

      return res
    }
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo

internal interface Dispatcher {
  fun shutdown()

  fun dispatchSubmit(action: Action)

  fun dispatchCancel(action: Action)

  fun dispatchPauseTag(tag: Any)

  fun dispatchResumeTag(tag: Any)

  fun dispatchComplete(hunter: BitmapHunter)

  fun dispatchRetry(hunter: BitmapHunter)

  fun dispatchFailed(hunter: BitmapHunter)

  fun dispatchNetworkStateChange(info: NetworkInfo)

  fun dispatchAirplaneModeChange(airplaneMode: Boolean)

  fun dispatchSubmit(hunter: BitmapHunter)

  fun dispatchCompleteMain(hunter: BitmapHunter)

  fun dispatchBatchResumeMain(batch: MutableList<Action>)

  fun isShutdown(): Boolean

  companion object {
    const val RETRY_DELAY = 500L
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import com.squareup.picasso3.Dispatcher.Companion.RETRY_DELAY
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

@OptIn(ExperimentalCoroutinesApi::class)
internal class InternalCoroutineDispatcher internal constructor(
  context: Context,
  mainThreadHandler: Handler,
  cache: PlatformLruCache,
  val mainDispatcher: CoroutineDispatcher,
  val backgroundDispatcher: CoroutineDispatcher
) : BaseDispatcher(context, mainThreadHandler, cache) {

  private val scope = CoroutineScope(SupervisorJob() + backgroundDispatcher)
  private val channel = Channel<() -> Unit>(capacity = Channel.UNLIMITED)

  init {
    
    scope.launch {
      while (!channel.isClosedForReceive) {
        channel.receive().invoke()
      }
    }
  }

  override fun shutdown() {
    super.shutdown()
    channel.close()
    scope.cancel()
  }

  override fun dispatchSubmit(action: Action) {
    channel.trySend {
      performSubmit(action)
    }
  }

  override fun dispatchCancel(action: Action) {
    channel.trySend {
      performCancel(action)
    }
  }

  override fun dispatchPauseTag(tag: Any) {
    channel.trySend {
      performPauseTag(tag)
    }
  }

  override fun dispatchResumeTag(tag: Any) {
    channel.trySend {
      performResumeTag(tag)
    }
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    channel.trySend {
      performComplete(hunter)
    }
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    scope.launch {
      delay(RETRY_DELAY)
      channel.send {
        performRetry(hunter)
      }
    }
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    channel.trySend {
      performError(hunter)
    }
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    channel.trySend {
      performNetworkStateChange(info)
    }
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    channel.trySend {
      performAirplaneModeChange(airplaneMode)
    }
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    scope.launch(mainDispatcher) {
      performCompleteMain(hunter)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    scope.launch(mainDispatcher) {
      performBatchResumeMain(batch)
    }
  }

  override fun dispatchSubmit(hunter: BitmapHunter) {
    hunter.job = scope.launch(CoroutineName(hunter.getName())) {
      hunter.run()
    }
  }

  override fun isShutdown() = !scope.isActive
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var mainDispatcher: CoroutineDispatcher? = null
    private var backgroundDispatcher: CoroutineDispatcher? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = (picasso.dispatcher as? HandlerDispatcher)?.service
      mainDispatcher = (picasso.dispatcher as? InternalCoroutineDispatcher)?.mainDispatcher
      backgroundDispatcher = (picasso.dispatcher as? InternalCoroutineDispatcher)?.backgroundDispatcher
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun dispatchers(
      mainDispatcher: CoroutineDispatcher = Dispatchers.Main,
      backgroundDispatcher: CoroutineDispatcher = Dispatchers.IO
    ) = apply {
      this.mainDispatcher = mainDispatcher
      this.backgroundDispatcher = backgroundDispatcher
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }

      val dispatcher = if (backgroundDispatcher != null) {
        InternalCoroutineDispatcher(context, HANDLER, cache!!, mainDispatcher!!, backgroundDispatcher!!)
      } else {
        if (service == null) {
          service = PicassoExecutorService()
        }

        HandlerDispatcher(context, service!!, HANDLER, cache!!)
      }

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER = Handler(Looper.getMainLooper())
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import java.util.concurrent.ExecutorService

internal class HandlerDispatcher internal constructor(
  context: Context,
  @get:JvmName("-service") val service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache
) : BaseDispatcher(context, mainThreadHandler, cache) {

  private val dispatcherThread: DispatcherThread
  private val handler: Handler
  private val mainHandler: Handler

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    mainHandler = MainDispatcherHandler(mainThreadHandler.looper, this)
  }

  override fun shutdown() {
    super.shutdown()
    
    (service as? PicassoExecutorService)?.shutdown()

    dispatcherThread.quit()
  }

  override fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  override fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  override fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  override fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  override fun dispatchSubmit(hunter: BitmapHunter) {
    hunter.future = service.submit(hunter)
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    val message = mainHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainHandler.sendMessage(message)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    mainHandler.sendMessage(mainHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
  }
  override fun isShutdown() = service.isShutdown

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: HandlerDispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          dispatcher.mainHandler.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  private class MainDispatcherHandler(
    looper: Looper,
    val dispatcher: HandlerDispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performCompleteMain(hunter)
        }
        REQUEST_BATCH_RESUME -> {
          val batch = msg.obj as List<Action>
          dispatcher.performBatchResumeMain(batch)
        }
        else -> throw AssertionError("Unknown handler message received: " + msg.what)
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )
  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    private const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    private const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    private const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context

  @Mock internal lateinit var dispatcher: Dispatcher

  @Mock internal lateinit var requestHandler: RequestHandler

  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyNoInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsTargetsToActions() {
    picasso.targetToAction[mockImageViewTarget()] = mock(ImageViewAction::class.java)
    picasso.shutdown()
    assertThat(picasso.targetToAction).isEmpty()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat((child.dispatcher as HandlerDispatcher).service).isEqualTo((parent.dispatcher as HandlerDispatcher).service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  @Test fun cloneSharesCoroutineDispatchers() {
    val parent =
      defaultPicasso(RuntimeEnvironment.application, true, true)
        .newBuilder()
        .dispatchers()
        .build()
    val child = parent.newBuilder().build()

    val parentDispatcher = parent.dispatcher as InternalCoroutineDispatcher
    val childDispatcher = child.dispatcher as InternalCoroutineDispatcher
    assertThat(childDispatcher.mainDispatcher).isEqualTo(parentDispatcher.mainDispatcher)
    assertThat(childDispatcher.backgroundDispatcher).isEqualTo(parentDispatcher.backgroundDispatcher)
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import com.squareup.picasso3.BaseDispatcher.NetworkBroadcastReceiver
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BaseDispatcherTest {
  @Mock lateinit var context: Context

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)

    receiver.onReceive(context, null)

    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = TestUtils.mockNetworkInfo()
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    Mockito.`when`(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)

    receiver.onReceive(context, Intent(ConnectivityManager.CONNECTIVITY_ACTION))

    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)

    receiver.onReceive(context, Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED))

    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(NetworkBroadcastReceiver.EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.pm.PackageManager
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Request.Builder
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers
import org.mockito.Mock
import org.mockito.Mockito
import org.mockito.MockitoAnnotations
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows
import java.lang.Exception
import java.lang.RuntimeException
import kotlinx.coroutines.Job
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestDispatcher

@RunWith(RobolectricTestRunner::class)
class InternalCoroutineDispatcherTest {

  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: InternalCoroutineDispatcher
  private lateinit var testDispatcher: TestDispatcher

  private val cache = PlatformLruCache(2048)
  private val bitmap1 = TestUtils.makeBitmap()

  @Before fun setUp() {
    MockitoAnnotations.initMocks(this)
    Mockito.`when`(context.applicationContext).thenReturn(context)
    dispatcher = createDispatcher()
  }

  @Test fun shutdownCancelsRunningJob() {
    createDispatcher(true)
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    dispatcher.dispatchSubmit(action)

    dispatcher.shutdown()
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.isShutdown()).isEqualTo(true)
    assertThat(action.completedResult).isNull()
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    Shadows.shadowOf(Looper.getMainLooper()).idle()
    Mockito.verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun dispatchSubmitWithNewRequestQueuesHunter() {
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    dispatcher.dispatchSubmit(action)

    testDispatcher.scheduler.runCurrent()

    assertThat(action.completedResult).isNotNull()
  }

  @Test fun dispatchSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val action2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_2, TestUtils.URI_2)

    dispatcher.dispatchSubmit(action1)
    dispatcher.dispatchSubmit(action2)

    testDispatcher.scheduler.runCurrent()

    assertThat(action1.completedResult).isNotNull()
    assertThat(action2.completedResult).isNotNull()
    assertThat(action2.completedResult).isNotEqualTo(action1.completedResult)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val action2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)

    dispatcher.dispatchSubmit(action1)
    dispatcher.dispatchSubmit(action2)
    testDispatcher.scheduler.runCurrent()

    assertThat(action1.completedResult).isNotNull()
    assertThat(action2.completedResult).isEqualTo(action1.completedResult)
  }

  @Test fun dispatchSubmitWithShutdownServiceIgnoresRequest() {
    dispatcher.shutdown()

    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    dispatcher.dispatchSubmit(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.dispatchPauseTag(pausedTag)
    testDispatcher.scheduler.runCurrent()
    assertThat(dispatcher.pausedActions).isEmpty()

    var completed = false
    val fetchAction1 = noopAction(Request.Builder(TestUtils.URI_1).tag(pausedTag).build(), { completed = true })
    val fetchAction2 = noopAction(Request.Builder(TestUtils.URI_1).tag(pausedTag).build(), { completed = true })
    dispatcher.dispatchSubmit(fetchAction1)
    dispatcher.dispatchSubmit(fetchAction2)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).hasSize(2)
    assertThat(completed).isFalse()
  }

  @Test fun dispatchCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.dispatchPauseTag(pausedTag)
    testDispatcher.scheduler.runCurrent()
    assertThat(dispatcher.pausedActions).isEmpty()

    val callback = TestUtils.mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(TestUtils.URI_1).tag(pausedTag).build(), callback)
    dispatcher.dispatchSubmit(fetchAction1)
    testDispatcher.scheduler.runCurrent()
    assertThat(dispatcher.pausedActions).hasSize(1)

    dispatcher.dispatchCancel(fetchAction1)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun dispatchCancelDetachesRequestAndCleansUp() {
    val target = TestUtils.mockBitmapTarget()
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1, target)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action).apply {
      job = Job()
    }
    dispatcher.hunterMap[TestUtils.URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action

    dispatcher.dispatchCancel(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.job!!.isCancelled).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchCancelMultipleRequestsDetachesOnly() {
    val action1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val action2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[TestUtils.URI_KEY_1 + Request.KEY_SEPARATOR] = hunter

    dispatcher.dispatchCancel(action1)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun dispatchCancelUnqueuesAndDetachesPausedRequest() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    dispatcher.dispatchSubmit(action)
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()
    dispatcher.hunterMap[TestUtils.URI_KEY_1 + Request.KEY_SEPARATOR] = hunter

    dispatcher.dispatchCancel(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun dispatchCompleteSetsResultInCache() {
    val data = Request.Builder(TestUtils.URI_1).build()
    val action = noopAction(data)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    val result = hunter.result as Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun dispatchCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(TestUtils.URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun dispatchCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(TestUtils.URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isTrue()
  }

  @Test fun dispatchCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(TestUtils.URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.job = Job().apply { cancel() }

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isFalse()
  }

  @Test fun dispatchErrorCleansUpAndPostsToMain() {
    val exception = RuntimeException()
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action, exception)
    hunter.run()
    dispatcher.hunterMap[hunter.key] = hunter

    dispatcher.dispatchFailed(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isEqualTo(exception)
  }

  @Test fun dispatchErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val exception = RuntimeException()
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action, exception)
    hunter.run()
    hunter.job = Job().apply { cancel() }
    dispatcher.hunterMap[hunter.key] = hunter

    dispatcher.dispatchFailed(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isNull()
  }

  @Test fun dispatchRetrySkipsIfHunterIsCancelled() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.job = Job().apply { cancel() }

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = TestUtils.mockNetworkInfo(true)
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_2, TestUtils.URI_2)
    val e = ContentLengthException("304 error")
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun dispatchRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = TestUtils.mockNetworkInfo(true)
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    )
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = TestUtils.mockNetworkInfo(true)
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(action.willReplay).isTrue()
  }

  @Test fun dispatchRetryRetriesIfNoNetworkScanning() {
    val dispatcher = createDispatcher(false)
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true,
      dispatcher = dispatcher
    )

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(action.completedResult).isInstanceOf(Bitmap::class.java)
  }

  @Test fun dispatchRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(action.willReplay).isTrue()
  }

  @Test fun dispatchRetryRetriesIfShouldRetry() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true,
      dispatcher = dispatcher
    )

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(action.completedResult).isInstanceOf(Bitmap::class.java)
  }

  @Test fun dispatchRetrySkipIfServiceShutdown() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)

    dispatcher.shutdown()
    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()

    dispatcher.dispatchAirplaneModeChange(true)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.airplaneMode).isTrue()

    dispatcher.dispatchAirplaneModeChange(false)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun dispatchNetworkStateChangeWithDisconnectedInfoIgnores() {
    val info = TestUtils.mockNetworkInfo()
    Mockito.`when`(info.isConnectedOrConnecting).thenReturn(false)

    dispatcher.dispatchNetworkStateChange(info)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val info = TestUtils.mockNetworkInfo(true)

    dispatcher.dispatchNetworkStateChange(info)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedTags).containsExactly("tag")

    dispatcher.dispatchResumeTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun dispatchPauseTagIsIdempotent() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[TestUtils.URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()

    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)

    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun dispatchPauseTagQueuesNewRequestDoesNotComplete() {
    dispatcher.dispatchPauseTag("tag")
    val action = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      tag = "tag"
    )

    dispatcher.dispatchSubmit(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1, "anothertag")
    dispatcher.dispatchSubmit(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(action.completedResult).isNotNull()
  }

  @Test fun dispatchPauseDetachesRequestAndCancelsHunter() {
    val action = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(
      picasso = picasso,
      result = Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.job = Job()

    dispatcher.hunterMap[TestUtils.URI_KEY_1] = hunter
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchPauseOnlyDetachesPausedRequest() {
    val action1 = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      target = TestUtils.mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      target = TestUtils.mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[TestUtils.URI_KEY_1] = hunter

    dispatcher.dispatchPauseTag("tag1")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun dispatchResumeTagIsIdempotent() {
    var completedCount = 0
    val action = noopAction(Builder(TestUtils.URI_1).tag("tag").build(), { completedCount++ })

    dispatcher.dispatchPauseTag("tag")
    dispatcher.dispatchSubmit(action)
    dispatcher.dispatchResumeTag("tag")
    dispatcher.dispatchResumeTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(completedCount).isEqualTo(1)
  }

  @Test fun dispatchNetworkStateChangeFlushesFailedHunters() {
    val info = TestUtils.mockNetworkInfo(true)
    val failedAction1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val failedAction2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_2, TestUtils.URI_2)
    dispatcher.failedActions[TestUtils.URI_KEY_1] = failedAction1
    dispatcher.failedActions[TestUtils.URI_KEY_2] = failedAction2

    dispatcher.dispatchNetworkStateChange(info)
    testDispatcher.scheduler.runCurrent()

    assertThat(failedAction1.completedResult).isNotNull()
    assertThat(failedAction2.completedResult).isNotNull()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  private fun createDispatcher(
    scansNetworkChanges: Boolean = true
  ): InternalCoroutineDispatcher {
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) Mockito.mock(NetworkInfo::class.java) else null
    )
    Mockito.`when`(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    Mockito.`when`(context.checkCallingOrSelfPermission(ArgumentMatchers.anyString())).thenReturn(
      if (scansNetworkChanges) PackageManager.PERMISSION_GRANTED else PackageManager.PERMISSION_DENIED
    )

    testDispatcher = StandardTestDispatcher()
    picasso = TestUtils.mockPicasso(context).newBuilder().dispatchers(testDispatcher, testDispatcher).build()
    return InternalCoroutineDispatcher(
      context,
      Handler(Looper.getMainLooper()),
      cache,
      testDispatcher,
      testDispatcher
    )
  }

  private fun noopAction(data: Request, onComplete: () -> Unit = { }): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = onComplete()
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = this
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Request.Builder
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.shadows.ShadowLooper
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class HandlerDispatcherTest {
  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: HandlerDispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isTrue()
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isFalse()
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isSameInstanceAs(exception)
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isNull()
    assertThat(action.completedResult).isNull()
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagResumesPausedActions() {
    val action = noopAction(Builder(URI_1).tag("tag").build())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)

    dispatcher.performResumeTag("tag")

    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): HandlerDispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): HandlerDispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return HandlerDispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request, onComplete: () -> Unit = { }): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = onComplete()
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = this
    }
  }
}

<code block>

package com.example.picasso

import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Canvas
import android.os.Bundle
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells.Adaptive
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.BasicText
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import com.squareup.picasso3.compose.rememberPainter
import kotlinx.coroutines.Dispatchers

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      Content(urls)
    }

    setContentView(composeView)
  }
}

@Composable
fun Content(urls: List<String>, picasso: Picasso = PicassoInitializer.get()) {
  var contentScale by remember { mutableStateOf(ContentScale.Inside) }
  var alignment by remember { mutableStateOf(Alignment.Center) }

  Column {
    ImageGrid(
      modifier = Modifier.weight(1F),
      urls = urls,
      contentScale = contentScale,
      alignment = alignment,
      picasso = picasso
    )

    Options(
      modifier = Modifier
        .background(Color.DarkGray)
        .padding(vertical = 4.dp),
      onContentScaleSelected = { contentScale = it },
      onAlignmentSelected = { alignment = it }
    )
  }
}

@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  contentScale: ContentScale,
  alignment: Alignment,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    columns = Adaptive(150.dp),
    modifier = modifier
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = contentScale,
        alignment = alignment,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

@Composable
fun Options(
  modifier: Modifier = Modifier,
  onContentScaleSelected: (ContentScale) -> Unit,
  onAlignmentSelected: (Alignment) -> Unit
) {
  var contentScaleKey by remember { mutableStateOf("Inside") }
  var alignmentKey by remember { mutableStateOf("Center") }
  Column(modifier = modifier) {
    CONTENT_SCALES.entries.chunked(4).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = contentScaleKey == key,
            onClick = {
              contentScaleKey = key
              onContentScaleSelected(value)
            }
          )
        }
      }
    }

    Spacer(modifier = Modifier.height(8.dp))

    ALIGNMENTS.entries.chunked(3).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = alignmentKey == key,
            onClick = {
              alignmentKey = key
              onAlignmentSelected(value)
            }
          )
        }
      }
    }
  }
}

@Composable
private fun OptionText(modifier: Modifier, key: String, selected: Boolean, onClick: () -> Unit) {
  Box(modifier = modifier) {
    BasicText(
      text = key,
      modifier = Modifier
        .align(Alignment.Center)
        .clip(RoundedCornerShape(8.dp))
        .clickable(onClick = onClick)
        .background(if (selected) Color.Blue else Color.White)
        .padding(horizontal = 8.dp, vertical = 4.dp)
    )
  }
}

private val CONTENT_SCALES = mapOf(
  Pair("Crop", ContentScale.Crop),
  Pair("Fit", ContentScale.Fit),
  Pair("Inside", ContentScale.Inside),
  Pair("Fill Width", ContentScale.FillWidth),
  Pair("Fill Height", ContentScale.FillHeight),
  Pair("Fill Bounds", ContentScale.FillBounds),
  Pair("None", ContentScale.None)
)

private val ALIGNMENTS = mapOf(
  Pair("TopStart", Alignment.TopStart),
  Pair("TopCenter", Alignment.TopCenter),
  Pair("TopEnd", Alignment.TopEnd),
  Pair("CenterStart", Alignment.CenterStart),
  Pair("Center", Alignment.Center),
  Pair("CenterEnd", Alignment.CenterEnd),
  Pair("BottomStart", Alignment.BottomStart),
  Pair("BottomCenter", Alignment.BottomCenter),
  Pair("BottomEnd", Alignment.BottomEnd)
)

@Preview
@Composable
private fun ContentPreview() {
  val images = listOf(
    Color.Blue.toArgb() to IntSize(200, 100),
    Color.Red.toArgb() to IntSize(100, 200),
    Color.Green.toArgb() to IntSize(100, 100),
    Color.Yellow.toArgb() to IntSize(300, 100),
    Color.Black.toArgb() to IntSize(100, 300),
    Color.LightGray.toArgb() to IntSize(400, 100),
    Color.Cyan.toArgb() to IntSize(100, 100),
    Color.White.toArgb() to IntSize(100, 400)
  ).associateBy { (color) -> "https:

  val context = LocalContext.current
  Content(
    urls = images.keys.toList(),
    picasso = remember {
      Picasso.Builder(context)
        .callFactory { throw AssertionError() } 
        .dispatchers(
          mainDispatcher = Dispatchers.Unconfined,
          backgroundDispatcher = Dispatchers.Unconfined
        )
        .addRequestHandler(
          object : RequestHandler() {
            override fun canHandleRequest(data: Request) = data.uri?.toString()?.run(images::containsKey) == true
            override fun load(picasso: Picasso, request: Request, callback: Callback) {
              val (color, size) = images[request.uri!!.toString()]!!
              val bitmap = Bitmap.createBitmap(size.width, size.height, Config.ARGB_8888).apply {
                Canvas(this).apply {
                  drawColor(color)
                }
              }

              callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
            }
          }
        )
        .build()
    }
  )
}

<code block>

package com.example.picasso.paparazzi

import android.graphics.BitmapFactory
import android.widget.ImageView
import android.widget.ImageView.ScaleType.CENTER
import app.cash.paparazzi.Paparazzi
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import org.junit.Rule
import org.junit.Test
import kotlinx.coroutines.Dispatchers

class PicassoPaparazziTest {
  @get:Rule val paparazzi = Paparazzi()

  @Test
  fun loadsUrlIntoImageView() {
    val picasso = Picasso.Builder(paparazzi.context)
      .callFactory { throw AssertionError() } 
      .dispatchers(
        mainDispatcher = Dispatchers.Unconfined,
        backgroundDispatcher = Dispatchers.Unconfined
      )
      .addRequestHandler(FakeRequestHandler())
      .build()

    paparazzi.snapshot(
      ImageView(paparazzi.context).apply {
        scaleType = CENTER
        picasso.load("fake:
          .resize(200, 200)
          .centerInside()
          .onlyScaleDown()
          .into(this)
      }
    )
  }

  class FakeRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return "fake" == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      val imagePath = request.uri!!.lastPathSegment!!
      callback.onSuccess(Result.Bitmap(loadBitmap(imagePath)!!, MEMORY))
    }

    private fun loadBitmap(imagePath: String): android.graphics.Bitmap? {
      val resourceAsStream = javaClass.classLoader!!.getResourceAsStream(imagePath)
      return BitmapFactory.decodeStream(resourceAsStream)
    }
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_HUNTER
import com.squareup.picasso3.Utils.THREAD_PREFIX
import com.squareup.picasso3.Utils.VERB_DECODED
import com.squareup.picasso3.Utils.VERB_EXECUTING
import com.squareup.picasso3.Utils.VERB_JOINED
import com.squareup.picasso3.Utils.VERB_REMOVED
import com.squareup.picasso3.Utils.VERB_TRANSFORMED
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.io.InterruptedIOException
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Future
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicReference

internal open class BitmapHunter(
  val picasso: Picasso,
  private val dispatcher: Dispatcher,
  private val cache: PlatformLruCache,
  action: Action,
  val requestHandler: RequestHandler
) : Runnable {
  val sequence: Int = SEQUENCE_GENERATOR.incrementAndGet()
  var priority: Picasso.Priority = action.request.priority
  var data: Request = action.request
  val key: String = action.request.key
  var retryCount: Int = requestHandler.retryCount

  var action: Action? = action
    private set
  var actions: MutableList<Action>? = null
    private set

  var future: Future<*>? = null
  var result: RequestHandler.Result? = null
    private set
  var exception: Exception? = null
    private set

  val isCancelled: Boolean
    get() = future?.isCancelled ?: false

  override fun run() {
    val originalName = Thread.currentThread().name
    try {
      updateThreadName(data)

      if (picasso.isLoggingEnabled) {
        log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this))
      }

      result = hunt()
      dispatcher.dispatchComplete(this)
    } catch (e: IOException) {
      exception = e
      if (retryCount > 0) {
        dispatcher.dispatchRetry(this)
      } else {
        dispatcher.dispatchFailed(this)
      }
    } catch (e: Exception) {
      exception = e
      dispatcher.dispatchFailed(this)
    } finally {
      Thread.currentThread().name = originalName
    }
  }

  fun hunt(): Bitmap? {
    if (shouldReadFromMemoryCache(data.memoryPolicy)) {
      cache[key]?.let { bitmap ->
        picasso.cacheHit()
        if (picasso.isLoggingEnabled) {
          log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache")
        }

        return Bitmap(bitmap, LoadedFrom.MEMORY)
      }
    }

    if (retryCount == 0) {
      data = data.newBuilder().networkPolicy(NetworkPolicy.OFFLINE).build()
    }

    val resultReference = AtomicReference<RequestHandler.Result?>()
    val exceptionReference = AtomicReference<Throwable>()

    val latch = CountDownLatch(1)
    try {
      requestHandler.load(
        picasso = picasso,
        request = data,
        callback = object : RequestHandler.Callback {
          override fun onSuccess(result: RequestHandler.Result?) {
            resultReference.set(result)
            latch.countDown()
          }

          override fun onError(t: Throwable) {
            exceptionReference.set(t)
            latch.countDown()
          }
        }
      )

      latch.await()
    } catch (ie: InterruptedException) {
      val interruptedIoException = InterruptedIOException()
      interruptedIoException.initCause(ie)
      throw interruptedIoException
    }

    exceptionReference.get()?.let { throwable ->
      when (throwable) {
        is IOException, is Error, is RuntimeException -> throw throwable
        else -> throw RuntimeException(throwable)
      }
    }

    val result = resultReference.get() as? Bitmap ?: return null
    val bitmap = result.bitmap
    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_DECODED, data.logId())
    }
    picasso.bitmapDecoded(bitmap)

    val transformations = ArrayList<Transformation>(data.transformations.size + 1)
    if (data.needsMatrixTransform() || result.exifRotation != 0) {
      transformations += MatrixTransformation(data)
    }
    transformations += data.transformations

    val transformedResult =
      applyTransformations(picasso, data, transformations, result) ?: return null
    val transformedBitmap = transformedResult.bitmap
    picasso.bitmapTransformed(transformedBitmap)

    return transformedResult
  }

  fun attach(action: Action) {
    val loggingEnabled = picasso.isLoggingEnabled
    val request = action.request
    if (this.action == null) {
      this.action = action
      if (loggingEnabled) {
        if (actions.isNullOrEmpty()) {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), "to empty hunter")
        } else {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
        }
      }

      return
    }

    if (actions == null) {
      actions = ArrayList(3)
    }
    actions!!.add(action)

    if (loggingEnabled) {
      log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
    }

    val actionPriority = action.request.priority
    if (actionPriority.ordinal > priority.ordinal) {
      priority = actionPriority
    }
  }

  fun detach(action: Action) {
    val detached = when {
      this.action === action -> {
        this.action = null
        true
      }
      else -> actions?.remove(action) ?: false
    }

    
    
    if (detached && action.request.priority == priority) {
      priority = computeNewPriority()
    }

    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_REMOVED, action.request.logId(), getLogIdsForHunter(this, "from "))
    }
  }

  fun cancel(): Boolean =
    action == null && actions.isNullOrEmpty() && future?.cancel(false) ?: false

  fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
    val hasRetries = retryCount > 0
    if (!hasRetries) {
      return false
    }
    retryCount--

    return requestHandler.shouldRetry(airplaneMode, info)
  }

  fun supportsReplay(): Boolean = requestHandler.supportsReplay()

  private fun computeNewPriority(): Picasso.Priority {
    val hasMultiple = actions?.isNotEmpty() ?: false
    val hasAny = action != null || hasMultiple

    
    if (!hasAny) {
      return Picasso.Priority.LOW
    }

    var newPriority = action?.request?.priority ?: Picasso.Priority.LOW

    actions?.let { actions ->
      
      for (i in actions.indices) {
        val priority = actions[i].request.priority
        if (priority.ordinal > newPriority.ordinal) {
          newPriority = priority
        }
      }
    }

    return newPriority
  }

  companion object {
    internal val NAME_BUILDER: ThreadLocal<StringBuilder> = object : ThreadLocal<StringBuilder>() {
      override fun initialValue(): StringBuilder = StringBuilder(THREAD_PREFIX)
    }
    val SEQUENCE_GENERATOR = AtomicInteger()
    internal val ERRORING_HANDLER: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean = true

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        callback.onError(IllegalStateException("Unrecognized type of request: $request"))
      }
    }

    fun forRequest(
      picasso: Picasso,
      dispatcher: Dispatcher,
      cache: PlatformLruCache,
      action: Action
    ): BitmapHunter {
      val request = action.request
      val requestHandlers = picasso.requestHandlers

      
      for (i in requestHandlers.indices) {
        val requestHandler = requestHandlers[i]
        if (requestHandler.canHandleRequest(request)) {
          return BitmapHunter(picasso, dispatcher, cache, action, requestHandler)
        }
      }

      return BitmapHunter(picasso, dispatcher, cache, action, ERRORING_HANDLER)
    }

    fun updateThreadName(data: Request) {
      val name = data.name
      val builder = NAME_BUILDER.get()!!.also {
        it.ensureCapacity(THREAD_PREFIX.length + name.length)
        it.replace(THREAD_PREFIX.length, it.length, name)
      }

      Thread.currentThread().name = builder.toString()
    }

    fun applyTransformations(
      picasso: Picasso,
      data: Request,
      transformations: List<Transformation>,
      result: Bitmap
    ): Bitmap? {
      var res = result

      for (i in transformations.indices) {
        val transformation = transformations[i]
        val newResult = try {
          val transformedResult = transformation.transform(res)
          if (picasso.isLoggingEnabled) {
            log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), "from transformations")
          }

          transformedResult
        } catch (e: RuntimeException) {
          Picasso.HANDLER.post {
            throw RuntimeException(
              "Transformation ${transformation.key()} crashed with exception.",
              e
            )
          }

          return null
        }

        val bitmap = newResult.bitmap
        if (bitmap.isRecycled) {
          Picasso.HANDLER.post {
            throw IllegalStateException(
              "Transformation ${transformation.key()} returned a recycled Bitmap."
            )
          }

          return null
        }

        res = newResult
      }

      return res
    }
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.util.Log
import androidx.annotation.CallSuper
import androidx.annotation.MainThread
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService

internal abstract class Dispatcher internal constructor(
  private val context: Context,
  @get:JvmName("-service") internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val scansNetworkChanges: Boolean

  init {
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  @CallSuper open fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    
    mainThreadHandler.post { receiver.unregister() }
  }

  abstract fun dispatchSubmit(action: Action)

  abstract fun dispatchCancel(action: Action)

  abstract fun dispatchPauseTag(tag: Any)

  abstract fun dispatchResumeTag(tag: Any)

  abstract fun dispatchComplete(hunter: BitmapHunter)

  abstract fun dispatchRetry(hunter: BitmapHunter)

  abstract fun dispatchFailed(hunter: BitmapHunter)

  abstract fun dispatchNetworkStateChange(info: NetworkInfo)

  abstract fun dispatchAirplaneModeChange(airplaneMode: Boolean)

  abstract fun dispatchCompleteMain(hunter: BitmapHunter)

  abstract fun dispatchBatchResumeMain(batch: MutableList<Action>)

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      dispatchBatchResumeMain(batch)
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  @MainThread
  fun performCompleteMain(hunter: BitmapHunter) {
    hunter.picasso.complete(hunter)
  }

  @MainThread
  fun performBatchResumeMain(batch: List<Action>) {
    for (i in batch.indices) {
      val action = batch[i]
      action.picasso.resumeAction(action)
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    dispatchCompleteMain(hunter)

    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    const val RETRY_DELAY = 500L
    const val HUNTER_COMPLETE = 4
    const val NETWORK_STATE_CHANGE = 9
    const val REQUEST_BATCH_RESUME = 13
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import java.util.concurrent.ExecutorService
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

internal class InternalCoroutineDispatcher internal constructor(
  context: Context,
  service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache,
  val picassoDispatcher: CoroutineDispatcher
) : Dispatcher(context, service, mainThreadHandler, cache) {

  @OptIn(ExperimentalCoroutinesApi::class)
  private val scope = CoroutineScope(picassoDispatcher.limitedParallelism(1))

  override fun shutdown() {
    super.shutdown()
    scope.cancel()
  }

  override fun dispatchSubmit(action: Action) {
    scope.launch {
      performSubmit(action)
    }
  }

  override fun dispatchCancel(action: Action) {
    scope.launch {
      performCancel(action)
    }
  }

  override fun dispatchPauseTag(tag: Any) {
    scope.launch {
      performPauseTag(tag)
    }
  }

  override fun dispatchResumeTag(tag: Any) {
    scope.launch {
      performResumeTag(tag)
    }
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    scope.launch {
      performComplete(hunter)
    }
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    scope.launch {
      delay(RETRY_DELAY)
      performRetry(hunter)
    }
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    scope.launch {
      performError(hunter)
    }
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    scope.launch {
      performNetworkStateChange(info)
    }
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    scope.launch {
      performAirplaneModeChange(airplaneMode)
    }
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    scope.launch(Dispatchers.Main) {
      performCompleteMain(hunter)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    scope.launch(Dispatchers.Main) {
      performBatchResumeMain(batch)
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService
import kotlinx.coroutines.CoroutineDispatcher


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var picassoDispatcher: CoroutineDispatcher? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      picassoDispatcher = (picasso.dispatcher as? InternalCoroutineDispatcher)?.picassoDispatcher
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun dispatcher(picassoDispatcher: CoroutineDispatcher) = apply {
      this.picassoDispatcher = picassoDispatcher
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = picassoDispatcher?.let {
        InternalCoroutineDispatcher(context, service!!, HANDLER, cache!!, it)
      } ?: HandlerDispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER = Handler(Looper.getMainLooper())
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import java.util.concurrent.ExecutorService

internal class HandlerDispatcher internal constructor(
  context: Context,
  service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache
) : Dispatcher(context, service, mainThreadHandler, cache) {

  private val dispatcherThread: DispatcherThread
  private val handler: Handler
  private val mainHandler: Handler

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    mainHandler = MainDispatcherHandler(mainThreadHandler.looper, this)
  }

  override fun shutdown() {
    super.shutdown()

    dispatcherThread.quit()
  }

  override fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  override fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  override fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  override fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    val message = mainHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainHandler.sendMessage(message)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    mainHandler.sendMessage(mainHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: HandlerDispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          dispatcher.mainHandler.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  private class MainDispatcherHandler(
    looper: Looper,
    val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performCompleteMain(hunter)
        }
        REQUEST_BATCH_RESUME -> {
          val batch = msg.obj as List<Action>
          dispatcher.performBatchResumeMain(batch)
        }
        else -> throw AssertionError("Unknown handler message received: " + msg.what)
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )
  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Request.Builder
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.shadows.ShadowLooper
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask
import kotlinx.coroutines.Dispatchers

@RunWith(RobolectricTestRunner::class)
class HandlerDispatcherTest : DispatcherTest() {
  override fun createDispatcher(
    context: Context,
    service: ExecutorService,
    cache: PlatformLruCache
  ) = HandlerDispatcher(context, service, Handler(getMainLooper()), cache)
}

@RunWith(RobolectricTestRunner::class)
class CoroutineDispatcherTest : DispatcherTest() {
  override fun createDispatcher(
    context: Context,
    service: ExecutorService,
    cache: PlatformLruCache
  ) = InternalCoroutineDispatcher(context, service, Handler(getMainLooper()), cache, Dispatchers.Main)
}

abstract class DispatcherTest {

  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isTrue()
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isFalse()
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isSameInstanceAs(exception)
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isNull()
    assertThat(action.completedResult).isNull()
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagResumesPausedActions() {
    val action = noopAction(Builder(URI_1).tag("tag").build())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)

    dispatcher.performResumeTag("tag")

    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return createDispatcher(context, service, cache)
  }

  internal abstract fun createDispatcher(context: Context, service: ExecutorService, cache: PlatformLruCache): Dispatcher

  private fun noopAction(data: Request, onComplete: () -> Unit = { }): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = onComplete()
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = this
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context

  @Mock internal lateinit var dispatcher: Dispatcher

  @Mock internal lateinit var requestHandler: RequestHandler

  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyNoInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsTargetsToActions() {
    picasso.targetToAction[mockImageViewTarget()] = mock(ImageViewAction::class.java)
    picasso.shutdown()
    assertThat(picasso.targetToAction).isEmpty()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Canvas
import android.os.Bundle
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells.Adaptive
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.BasicText
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import com.squareup.picasso3.compose.rememberPainter
import com.squareup.picasso3.layoutlib.LayoutlibExecutorService

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      Content(urls)
    }

    setContentView(composeView)
  }
}

@Composable
fun Content(urls: List<String>, picasso: Picasso = PicassoInitializer.get()) {
  var contentScale by remember { mutableStateOf(ContentScale.Inside) }
  var alignment by remember { mutableStateOf(Alignment.Center) }

  Column {
    ImageGrid(
      modifier = Modifier.weight(1F),
      urls = urls,
      contentScale = contentScale,
      alignment = alignment,
      picasso = picasso
    )

    Options(
      modifier = Modifier
        .background(Color.DarkGray)
        .padding(vertical = 4.dp),
      onContentScaleSelected = { contentScale = it },
      onAlignmentSelected = { alignment = it }
    )
  }
}

@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  contentScale: ContentScale,
  alignment: Alignment,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    columns = Adaptive(150.dp),
    modifier = modifier
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = contentScale,
        alignment = alignment,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

@Composable
fun Options(
  modifier: Modifier = Modifier,
  onContentScaleSelected: (ContentScale) -> Unit,
  onAlignmentSelected: (Alignment) -> Unit
) {
  var contentScaleKey by remember { mutableStateOf("Inside") }
  var alignmentKey by remember { mutableStateOf("Center") }
  Column(modifier = modifier) {
    CONTENT_SCALES.entries.chunked(4).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = contentScaleKey == key,
            onClick = {
              contentScaleKey = key
              onContentScaleSelected(value)
            }
          )
        }
      }
    }

    Spacer(modifier = Modifier.height(8.dp))

    ALIGNMENTS.entries.chunked(3).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = alignmentKey == key,
            onClick = {
              alignmentKey = key
              onAlignmentSelected(value)
            }
          )
        }
      }
    }
  }
}

@Composable
private fun OptionText(modifier: Modifier, key: String, selected: Boolean, onClick: () -> Unit) {
  Box(modifier = modifier) {
    BasicText(
      text = key,
      modifier = Modifier
        .align(Alignment.Center)
        .clip(RoundedCornerShape(8.dp))
        .clickable(onClick = onClick)
        .background(if (selected) Color.Blue else Color.White)
        .padding(horizontal = 8.dp, vertical = 4.dp)
    )
  }
}

private val CONTENT_SCALES = mapOf(
  Pair("Crop", ContentScale.Crop),
  Pair("Fit", ContentScale.Fit),
  Pair("Inside", ContentScale.Inside),
  Pair("Fill Width", ContentScale.FillWidth),
  Pair("Fill Height", ContentScale.FillHeight),
  Pair("Fill Bounds", ContentScale.FillBounds),
  Pair("None", ContentScale.None)
)

private val ALIGNMENTS = mapOf(
  Pair("TopStart", Alignment.TopStart),
  Pair("TopCenter", Alignment.TopCenter),
  Pair("TopEnd", Alignment.TopEnd),
  Pair("CenterStart", Alignment.CenterStart),
  Pair("Center", Alignment.Center),
  Pair("CenterEnd", Alignment.CenterEnd),
  Pair("BottomStart", Alignment.BottomStart),
  Pair("BottomCenter", Alignment.BottomCenter),
  Pair("BottomEnd", Alignment.BottomEnd)
)

@Preview
@Composable
private fun ContentPreview() {
  val images = listOf(
    Color.Blue.toArgb() to IntSize(200, 100),
    Color.Red.toArgb() to IntSize(100, 200),
    Color.Green.toArgb() to IntSize(100, 100),
    Color.Yellow.toArgb() to IntSize(300, 100),
    Color.Black.toArgb() to IntSize(100, 300),
    Color.LightGray.toArgb() to IntSize(400, 100),
    Color.Cyan.toArgb() to IntSize(100, 100),
    Color.White.toArgb() to IntSize(100, 400)
  ).associateBy { (color) -> "https:

  val context = LocalContext.current
  Content(
    urls = images.keys.toList(),
    picasso = remember {
      Picasso.Builder(context)
        .callFactory { throw AssertionError() } 
        .executor(LayoutlibExecutorService()) 
        .addRequestHandler(
          object : RequestHandler() {
            override fun canHandleRequest(data: Request) = data.uri?.toString()?.run(images::containsKey) == true
            override fun load(picasso: Picasso, request: Request, callback: Callback) {
              val (color, size) = images[request.uri!!.toString()]!!
              val bitmap = Bitmap.createBitmap(size.width, size.height, Config.ARGB_8888).apply {
                Canvas(this).apply {
                  drawColor(color)
                }
              }

              callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
            }
          }
        )
        .build()
    }
  )
}

<code block>

package com.example.picasso.paparazzi

import android.graphics.BitmapFactory
import android.widget.ImageView
import android.widget.ImageView.ScaleType.CENTER
import app.cash.paparazzi.Paparazzi
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import com.squareup.picasso3.layoutlib.LayoutlibExecutorService
import org.junit.Rule
import org.junit.Test
import kotlinx.coroutines.Dispatchers

class PicassoPaparazziTest {
  @get:Rule val paparazzi = Paparazzi()

  @Test
  fun loadsUrlIntoImageView() {
    val picasso = Picasso.Builder(paparazzi.context)
      .callFactory { throw AssertionError() } 
      .executor(LayoutlibExecutorService())
      .dispatcher(Dispatchers.Main)
      .addRequestHandler(FakeRequestHandler())
      .build()

    paparazzi.snapshot(
      ImageView(paparazzi.context).apply {
        scaleType = CENTER
        picasso.load("fake:
          .resize(200, 200)
          .centerInside()
          .onlyScaleDown()
          .into(this)
      }
    )
  }

  class FakeRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return "fake" == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      val imagePath = request.uri!!.lastPathSegment!!
      callback.onSuccess(Result.Bitmap(loadBitmap(imagePath)!!, MEMORY))
    }

    private fun loadBitmap(imagePath: String): android.graphics.Bitmap? {
      val resourceAsStream = javaClass.classLoader!!.getResourceAsStream(imagePath)
      return BitmapFactory.decodeStream(resourceAsStream)
    }
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import okhttp3.Headers
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val headers: Headers? = builder.headers

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0
    var headers: Headers? = null

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    fun addHeader(
      name: String,
      value: String
    ) = apply {
      this.headers = (headers?.newBuilder() ?: Headers.Builder())
        .add(name, value)
        .build()
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    val requestHeaders = request.headers
    if (requestHeaders != null) {
      builder.headers(requestHeaders)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun customHeaders() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(
      picasso,
      key = URI_KEY_1,
      uri = URI_1,
      headers = mapOf(CUSTOM_HEADER_NAME to CUSTOM_HEADER_VALUE)
    )
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          with(requests.first.headers) {
            assertThat(names()).containsExactly(CUSTOM_HEADER_NAME)
            assertThat(values(CUSTOM_HEADER_NAME)).containsExactly(CUSTOM_HEADER_VALUE)
          }
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NOOP_REQUEST_HANDLER
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context, NOOP_REQUEST_HANDLER)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(eventRecorder.decodedBitmap).isEqualTo(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    assertThat(eventRecorder.decodedBitmap).isNull()
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val picasso = mockPicasso(context, ContentStreamRequestHandler(context))
    val action = mockAction(picasso, CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val picasso = mockPicasso(context, MediaStoreRequestHandler(context))
    val action = mockAction(picasso, MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val picasso = mockPicasso(context, AssetRequestHandler(context))
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, "keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val handler = AssetRequestHandler(context)
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      listOf(handler), emptyList(), ARGB_8888, false, false
    )
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val picasso = mockPicasso(context)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(request, target)
  }

  @JvmStatic fun mockAction(request: Request, target: Any = mockTarget()): FakeAction =
    FakeAction(mockPicasso(), request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = mockPicasso(),
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(requestHandler)
  }

  @JvmStatic fun mockPicasso(requestHandler: RequestHandler): Picasso {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.getRequestHandlers()).thenReturn(listOf(requestHandler))
    return picasso
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyLong
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso).downloadFinished(10)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        verify(picasso, never()).downloadFinished(anyLong())
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso, never()).downloadFinished(anyLong())
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  @Mock lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    verify(picasso).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    verify(picasso, never()).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val action = mockAction(CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(ContentStreamRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val action = mockAction(MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(MediaStoreRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val action = mockAction(CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val action = mockAction(CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val action = mockAction(FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(
      mockPicasso(FileRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val action = mockAction(RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val action = mockAction(RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(mockPicasso(AssetRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val action = mockAction("keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(mockPicasso(FileRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val handler = AssetRequestHandler(context)
    val handlers = listOf(handler)
    val eventListeners = emptyList<EventListener>()
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      handlers, eventListeners, ARGB_8888, false, false
    )
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val action = mockAction(URI_KEY_1, URI_1)
    val picasso = mockPicasso()
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val action = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    urlBuilder.filter(ThumborUrlBuilder.format(WEBP))

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = statFs.blockCountLong
      val blockSize = statFs.blockSizeLong
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    val bitmap = if (isWebPFile) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizing() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
  }

  @Test fun createWithConfigAndNotInJustDecodeBounds() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR2) {
      urlBuilder.filter(ThumborUrlBuilder.format(WEBP))
    }

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [17], manifest = Config.NONE)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST).buildImage(IMAGE).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Config(sdk = [18])
  @Test fun simpleResizeOnJbMr2UsesWebP() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun purgeable(): RequestCreator {
    data.purgeable()
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.provider.Settings.System
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockCount.toLong()
      } else {
        statFs.blockCountLong
      }
      val blockSize = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockSize.toLong()
      } else {
        statFs.blockSizeLong
      }
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR1) {
        System.getInt(contentResolver, System.AIRPLANE_MODE_ON, 0) != 0
      } else {
        Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
      }
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val purgeable: Boolean = builder.purgeable

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (purgeable) {
        append(" purgeable")
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var purgeable = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      purgeable = request.purgeable
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    fun purgeable() = apply {
      purgeable = true
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null || data.purgeable) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        inInputShareable = data.purgeable
        inPurgeable = data.purgeable
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val isPurgeable = request.purgeable && VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    
    val bitmap = if (isWebPFile || isPurgeable) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.annotation.Config
import java.io.File

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [23]) 
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Config(sdk = [16]) 
  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("packageName", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizingOrPurgeable() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
    assertThat(resizeOptions.inPurgeable).isFalse()
    assertThat(resizeOptions.inInputShareable).isFalse()
  }

  @Test fun inPurgeableIfInPurgeable() {
    val request = Request.Builder(URI_1).purgeable().build()
    val options = createBitmapOptions(request)
    assertThat(options).isNotNull()
    assertThat(options!!.inPurgeable).isTrue()
    assertThat(options.inInputShareable).isTrue()
    assertThat(options.inJustDecodeBounds).isFalse()
  }

  @Test fun createWithConfigAndNotInJustDecodeBoundsOrInPurgeable() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
    assertThat(configOptions.inPurgeable).isFalse()
    assertThat(configOptions.inInputShareable).isFalse()
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    urlBuilder.filter(ThumborUrlBuilder.format(WEBP))

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = statFs.blockCountLong
      val blockSize = statFs.blockSizeLong
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    val bitmap = if (isWebPFile) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizing() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
  }

  @Test fun createWithConfigAndNotInJustDecodeBounds() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR2) {
      urlBuilder.filter(ThumborUrlBuilder.format(WEBP))
    }

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [17], manifest = Config.NONE)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST).buildImage(IMAGE).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Config(sdk = [18])
  @Test fun simpleResizeOnJbMr2UsesWebP() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun purgeable(): RequestCreator {
    data.purgeable()
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.provider.Settings.System
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockCount.toLong()
      } else {
        statFs.blockCountLong
      }
      val blockSize = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockSize.toLong()
      } else {
        statFs.blockSizeLong
      }
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR1) {
        System.getInt(contentResolver, System.AIRPLANE_MODE_ON, 0) != 0
      } else {
        Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
      }
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val purgeable: Boolean = builder.purgeable

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (purgeable) {
        append(" purgeable")
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var purgeable = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      purgeable = request.purgeable
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    fun purgeable() = apply {
      purgeable = true
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null || data.purgeable) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        inInputShareable = data.purgeable
        inPurgeable = data.purgeable
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val isPurgeable = request.purgeable && VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    
    val bitmap = if (isWebPFile || isPurgeable) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.annotation.Config
import java.io.File

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [23]) 
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Config(sdk = [16]) 
  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("packageName", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizingOrPurgeable() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
    assertThat(resizeOptions.inPurgeable).isFalse()
    assertThat(resizeOptions.inInputShareable).isFalse()
  }

  @Test fun inPurgeableIfInPurgeable() {
    val request = Request.Builder(URI_1).purgeable().build()
    val options = createBitmapOptions(request)
    assertThat(options).isNotNull()
    assertThat(options!!.inPurgeable).isTrue()
    assertThat(options.inInputShareable).isTrue()
    assertThat(options.inJustDecodeBounds).isFalse()
  }

  @Test fun createWithConfigAndNotInJustDecodeBoundsOrInPurgeable() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
    assertThat(configOptions.inPurgeable).isFalse()
    assertThat(configOptions.inInputShareable).isFalse()
  }
}

<code block>

package com.squareup.picasso3.compose

import android.graphics.drawable.Drawable
import androidx.compose.runtime.Composable
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.DefaultAlpha
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.painter.Painter
import com.google.accompanist.drawablepainter.DrawablePainter
import com.squareup.picasso3.DrawableTarget
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestCreator

@Composable
fun Picasso.rememberPainter(
  key: Any? = null,
  onError: ((Exception) -> Unit)? = null,
  request: (Picasso) -> RequestCreator,
): Painter {
  return remember(key) { PicassoPainter(this, request, onError) }
}

internal class PicassoPainter(
  private val picasso: Picasso,
  private val request: (Picasso) -> RequestCreator,
  private val onError: ((Exception) -> Unit)? = null
) : Painter(), RememberObserver, DrawableTarget {

  private var painter: Painter by mutableStateOf(EmptyPainter)
  private var alpha: Float by mutableStateOf(DefaultAlpha)
  private var colorFilter: ColorFilter? by mutableStateOf(null)

  override val intrinsicSize: Size
    get() = painter.intrinsicSize

  override fun applyAlpha(alpha: Float): Boolean {
    this.alpha = alpha
    return true
  }

  override fun applyColorFilter(colorFilter: ColorFilter?): Boolean {
    this.colorFilter = colorFilter
    return true
  }

  override fun DrawScope.onDraw() {
    with(painter) {
      draw(size, alpha, colorFilter)
    }
  }

  override fun onRemembered() {
    request.invoke(picasso).into(this)
  }

  override fun onAbandoned() {
    (painter as? RememberObserver)?.onAbandoned()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onForgotten() {
    (painter as? RememberObserver)?.onForgotten()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onPrepareLoad(placeHolderDrawable: Drawable?) {
    placeHolderDrawable?.let(::setPainter)
  }

  override fun onDrawableLoaded(drawable: Drawable, from: LoadedFrom) {
    setPainter(drawable)
  }

  override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) {
    onError?.invoke(e)
    errorDrawable?.let(::setPainter)
  }

  private fun setPainter(drawable: Drawable) {
    (painter as? RememberObserver)?.onForgotten()
    painter = DrawablePainter(drawable).apply(DrawablePainter::onRemembered)
  }
}

private object EmptyPainter : Painter() {
  override val intrinsicSize = Size.Zero
  override fun DrawScope.onDraw() = Unit
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom


interface DrawableTarget {
  
  fun onDrawableLoaded(
    drawable: Drawable,
    from: LoadedFrom
  )

  
  fun onDrawableFailed(
    e: Exception,
    errorDrawable: Drawable?
  )

  
  fun onPrepareLoad(placeHolderDrawable: Drawable?)
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  fun into(target: DrawableTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    val placeHolderDrawable = if (setPlaceholder) getPlaceholderDrawable() else null
    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(placeHolderDrawable)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onDrawableLoaded(
          PicassoDrawable(
            context = picasso.context,
            bitmap = bitmap,
            placeholder = null,
            loadedFrom = LoadedFrom.MEMORY,
            noFade = noFade,
            debugging = picasso.indicatorsEnabled
          ),
          LoadedFrom.MEMORY
        )
        return
      }
    }

    target.onPrepareLoad(placeHolderDrawable)
    val action = DrawableTargetAction(picasso, target, request, noFade, placeHolderDrawable, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class DrawableTargetAction(
  picasso: Picasso,
  private val target: DrawableTarget,
  data: Request,
  private val noFade: Boolean,
  private val placeholderDrawable: Drawable?,
  private val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onDrawableLoaded(
        PicassoDrawable(
          context = picasso.context,
          bitmap = bitmap,
          placeholder = placeholderDrawable,
          loadedFrom = result.loadedFrom,
          noFade = noFade,
          debugging = picasso.indicatorsEnabled
        ),
        result.loadedFrom
      )
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onDrawableFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.mockito.Mockito.mock
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DrawableTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockDrawableTarget()
    val drawableCaptor = argumentCaptor<PicassoDrawable>()
    val placeholder = mock(Drawable::class.java)
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = false,
      placeholderDrawable = placeholder,
      errorDrawable = null,
      errorResId = 0
    )

    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))

    Mockito.verify(target).onDrawableLoaded(drawableCaptor.capture(), eq(NETWORK))
    with(drawableCaptor.value) {
      assertThat(this.bitmap).isEqualTo(bitmap)
      assertThat(this.placeholder).isEqualTo(placeholder)
      assertThat(this.animating).isTrue()
    }
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher,
      TestUtils.UNUSED_CALL_FACTORY, null, cache, null,
      TestUtils.NO_TRANSFORMERS,
      TestUtils.NO_HANDLERS,
      TestUtils.NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)

    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = TestUtils.RESOURCE_ID_1
    )

    Mockito.`when`(context.getDrawable(TestUtils.RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = TestUtils.mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = object : DrawableTarget {
        override fun onDrawableLoaded(drawable: Drawable, from: Picasso.LoadedFrom) = (drawable as PicassoDrawable).bitmap.recycle()
        override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = 0
    )

    try {
      action.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      Assert.fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockBitmapTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoDrawableTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockDrawableTarget())
      fail("Calling into() drawable target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoDrawableTargetNoPlaceholderCallsWithNull() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoDrawableTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoDrawableTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onDrawableLoaded(any(PicassoDrawable::class.java), eq(MEMORY))
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoDrawableTargetWithSkipMemoryPolicy() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoDrawableTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(DrawableTargetAction::class.java)
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockBitmapTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockBitmapTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockBitmapTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockBitmapTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockBitmapTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockBitmapTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockDrawableTarget(): DrawableTarget = mock(DrawableTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.os.Bundle
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.lazy.GridCells.Adaptive
import androidx.compose.foundation.lazy.LazyVerticalGrid
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.ContentScale.Companion.Crop
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.compose.rememberPainter

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      ImageGrid(urls = urls)
    }

    setContentView(composeView)
  }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    cells = Adaptive(150.dp),
    modifier = modifier,
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = Crop,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    COMPOSE_UI("Compose UI", SampleComposeActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3.compose

import android.graphics.drawable.Drawable
import androidx.compose.runtime.Composable
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.DefaultAlpha
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.painter.Painter
import com.google.accompanist.drawablepainter.DrawablePainter
import com.squareup.picasso3.DrawableTarget
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestCreator

@Composable
fun Picasso.rememberPainter(
  key: Any? = null,
  onError: ((Exception) -> Unit)? = null,
  request: (Picasso) -> RequestCreator,
): Painter {
  return remember(key) { PicassoPainter(this, request, onError) }
}

internal class PicassoPainter(
  private val picasso: Picasso,
  private val request: (Picasso) -> RequestCreator,
  private val onError: ((Exception) -> Unit)? = null
) : Painter(), RememberObserver, DrawableTarget {

  private var painter: Painter by mutableStateOf(EmptyPainter)
  private var alpha: Float by mutableStateOf(DefaultAlpha)
  private var colorFilter: ColorFilter? by mutableStateOf(null)

  override val intrinsicSize: Size
    get() = painter.intrinsicSize

  override fun applyAlpha(alpha: Float): Boolean {
    this.alpha = alpha
    return true
  }

  override fun applyColorFilter(colorFilter: ColorFilter?): Boolean {
    this.colorFilter = colorFilter
    return true
  }

  override fun DrawScope.onDraw() {
    with(painter) {
      draw(size, alpha, colorFilter)
    }
  }

  override fun onRemembered() {
    request.invoke(picasso).into(this)
  }

  override fun onAbandoned() {
    (painter as? RememberObserver)?.onAbandoned()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onForgotten() {
    (painter as? RememberObserver)?.onForgotten()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onPrepareLoad(placeHolderDrawable: Drawable?) {
    placeHolderDrawable?.let(::setPainter)
  }

  override fun onDrawableLoaded(drawable: Drawable, from: LoadedFrom) {
    setPainter(drawable)
  }

  override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) {
    onError?.invoke(e)
    errorDrawable?.let(::setPainter)
  }

  private fun setPainter(drawable: Drawable) {
    (painter as? RememberObserver)?.onForgotten()
    painter = DrawablePainter(drawable).apply(DrawablePainter::onRemembered)
  }
}

private object EmptyPainter : Painter() {
  override val intrinsicSize = Size.Zero
  override fun DrawScope.onDraw() = Unit
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom


interface DrawableTarget {
  
  fun onDrawableLoaded(
    drawable: Drawable,
    from: LoadedFrom
  )

  
  fun onDrawableFailed(
    e: Exception,
    errorDrawable: Drawable?
  )

  
  fun onPrepareLoad(placeHolderDrawable: Drawable?)
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  fun into(target: DrawableTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    val placeHolderDrawable = if (setPlaceholder) getPlaceholderDrawable() else null
    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(placeHolderDrawable)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onDrawableLoaded(
          PicassoDrawable(
            context = picasso.context,
            bitmap = bitmap,
            placeholder = null,
            loadedFrom = LoadedFrom.MEMORY,
            noFade = noFade,
            debugging = picasso.indicatorsEnabled
          ),
          LoadedFrom.MEMORY
        )
        return
      }
    }

    target.onPrepareLoad(placeHolderDrawable)
    val action = DrawableTargetAction(picasso, target, request, noFade, placeHolderDrawable, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class DrawableTargetAction(
  picasso: Picasso,
  private val target: DrawableTarget,
  data: Request,
  private val noFade: Boolean,
  private val placeholderDrawable: Drawable?,
  private val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onDrawableLoaded(
        PicassoDrawable(
          context = picasso.context,
          bitmap = bitmap,
          placeholder = placeholderDrawable,
          loadedFrom = result.loadedFrom,
          noFade = noFade,
          debugging = picasso.indicatorsEnabled
        ),
        result.loadedFrom
      )
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onDrawableFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.mockito.Mockito.mock
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DrawableTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockDrawableTarget()
    val drawableCaptor = argumentCaptor<PicassoDrawable>()
    val placeholder = mock(Drawable::class.java)
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = false,
      placeholderDrawable = placeholder,
      errorDrawable = null,
      errorResId = 0
    )

    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))

    Mockito.verify(target).onDrawableLoaded(drawableCaptor.capture(), eq(NETWORK))
    with(drawableCaptor.value) {
      assertThat(this.bitmap).isEqualTo(bitmap)
      assertThat(this.placeholder).isEqualTo(placeholder)
      assertThat(this.animating).isTrue()
    }
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher,
      TestUtils.UNUSED_CALL_FACTORY, null, cache, null,
      TestUtils.NO_TRANSFORMERS,
      TestUtils.NO_HANDLERS,
      TestUtils.NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)

    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = TestUtils.RESOURCE_ID_1
    )

    Mockito.`when`(context.getDrawable(TestUtils.RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = TestUtils.mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = object : DrawableTarget {
        override fun onDrawableLoaded(drawable: Drawable, from: Picasso.LoadedFrom) = (drawable as PicassoDrawable).bitmap.recycle()
        override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = 0
    )

    try {
      action.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      Assert.fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockBitmapTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoDrawableTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockDrawableTarget())
      fail("Calling into() drawable target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoDrawableTargetNoPlaceholderCallsWithNull() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoDrawableTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoDrawableTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onDrawableLoaded(any(PicassoDrawable::class.java), eq(MEMORY))
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoDrawableTargetWithSkipMemoryPolicy() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoDrawableTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(DrawableTargetAction::class.java)
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockBitmapTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockBitmapTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockBitmapTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockBitmapTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockBitmapTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockBitmapTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockDrawableTarget(): DrawableTarget = mock(DrawableTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.os.Bundle
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.lazy.GridCells.Adaptive
import androidx.compose.foundation.lazy.LazyVerticalGrid
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.ContentScale.Companion.Crop
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.compose.rememberPainter

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      ImageGrid(urls = urls)
    }

    setContentView(composeView)
  }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    cells = Adaptive(150.dp),
    modifier = modifier,
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = Crop,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    COMPOSE_UI("Compose UI", SampleComposeActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
      update()
      callback?.onSuccess()
    }
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result.Drawable(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result.Bitmap(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {

    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3

import com.squareup.picasso3.RequestHandler.Result


interface Transformation {
  
  fun transform(source: Result.Bitmap): Result.Bitmap

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.Picasso.LoadedFrom
import java.io.IOException


abstract class RequestHandler {
  
  sealed class Result constructor(
    
    @JvmField val loadedFrom: LoadedFrom,
    
    @JvmField val exifRotation: Int = 0
  ) {
    class Bitmap @JvmOverloads constructor(
      val bitmap: android.graphics.Bitmap,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)

    class Drawable @JvmOverloads constructor(
      val drawable: android.graphics.drawable.Drawable,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)
  }

  interface Callback {
    fun onSuccess(result: Result?)
    fun onError(t: Throwable)
  }

  
  abstract fun canHandleRequest(data: Request): Boolean

  
  @Throws(IOException::class)
  abstract fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  )

  open val retryCount = 0

  open fun shouldRetry(
    airplaneMode: Boolean,
    info: NetworkInfo?
  ) = false

  open fun supportsReplay() = false
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result.Bitmap): Result.Bitmap {
    val bitmap = source.bitmap

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result.Bitmap(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
    update()
    callback?.onSuccess()
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    val bitmap = result.bitmap
    if (bitmap != null) {
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3


interface Transformation {
  
  fun transform(source: RequestHandler.Result): RequestHandler.Result

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result): Result {
    val bitmap = source.bitmap ?: return source

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import android.util.Log
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.TAG
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.concurrent.ExecutorService

internal class Dispatcher internal constructor(
  private val context: Context,
  @JvmField internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  private val dispatcherThread: DispatcherThread
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()
  internal val failedActions = mutableMapOf<Any, Action>()
  internal val pausedActions = mutableMapOf<Any, Action>()
  internal val pausedTags = mutableSetOf<Any>()
  private val handler: Handler
  internal val receiver: NetworkBroadcastReceiver
  private val scansNetworkChanges: Boolean

  @JvmField internal var airplaneMode = isAirplaneModeOn(context)

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    dispatcherThread.quit()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  @JvmOverloads
  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.loggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while(iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.loggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.loggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return  
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import org.robolectric.RobolectricTestRunner
import org.mockito.Mock
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    
    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = picasso,
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  private val picasso = mockPicasso(RuntimeEnvironment.application)

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator(picasso).tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val spyPicasso = spy(picasso) 
    val creator = RequestCreator(spyPicasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
    verify(spyPicasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Captor
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  @Mock private lateinit var picasso: Picasso
  @Captor private lateinit var actionCaptor: ArgumentCaptor<Action>

  private val bitmap = makeBitmap()

  @Before fun shutUp() {
    initMocks(this)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)
  }

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator().resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator().placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator().noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator().error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator().priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator().tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator().transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mock(Picasso::class.java)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mock(Picasso::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mock(Picasso::class.java)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.Captor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  @Captor
  internal lateinit var actionCaptor: ArgumentCaptor<Action>

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator().tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)

    val creator = RequestCreator(picasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NOOP_REQUEST_HANDLER
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context, NOOP_REQUEST_HANDLER)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(eventRecorder.decodedBitmap).isEqualTo(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    assertThat(eventRecorder.decodedBitmap).isNull()
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val picasso = mockPicasso(context, ContentStreamRequestHandler(context))
    val action = mockAction(picasso, CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val picasso = mockPicasso(context, MediaStoreRequestHandler(context))
    val action = mockAction(picasso, MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val picasso = mockPicasso(context, AssetRequestHandler(context))
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, "keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val handler = AssetRequestHandler(context)
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      listOf(handler), emptyList(), ARGB_8888, false, false
    )
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val picasso = mockPicasso(context)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(request, target)
  }

  @JvmStatic fun mockAction(request: Request, target: Any = mockTarget()): FakeAction =
    FakeAction(mockPicasso(), request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = mockPicasso(),
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(requestHandler)
  }

  @JvmStatic fun mockPicasso(requestHandler: RequestHandler): Picasso {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.getRequestHandlers()).thenReturn(listOf(requestHandler))
    return picasso
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyLong
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso).downloadFinished(10)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        verify(picasso, never()).downloadFinished(anyLong())
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso, never()).downloadFinished(anyLong())
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  @Mock lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    verify(picasso).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    verify(picasso, never()).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val action = mockAction(CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(ContentStreamRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val action = mockAction(MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(MediaStoreRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val action = mockAction(CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val action = mockAction(CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val action = mockAction(FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(
      mockPicasso(FileRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val action = mockAction(RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val action = mockAction(RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(mockPicasso(AssetRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val action = mockAction("keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(mockPicasso(FileRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val handler = AssetRequestHandler(context)
    val handlers = listOf(handler)
    val eventListeners = emptyList<EventListener>()
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      handlers, eventListeners, ARGB_8888, false, false
    )
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val action = mockAction(URI_KEY_1, URI_1)
    val picasso = mockPicasso()
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val action = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import android.util.Log
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.TAG
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.concurrent.ExecutorService

internal class Dispatcher internal constructor(
  private val context: Context,
  @JvmField internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  private val dispatcherThread: DispatcherThread
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()
  internal val failedActions = mutableMapOf<Any, Action>()
  internal val pausedActions = mutableMapOf<Any, Action>()
  internal val pausedTags = mutableSetOf<Any>()
  private val handler: Handler
  internal val receiver: NetworkBroadcastReceiver
  private val scansNetworkChanges: Boolean

  @JvmField internal var airplaneMode = isAirplaneModeOn(context)

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    dispatcherThread.quit()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  @JvmOverloads
  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.loggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while(iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.loggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.loggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return  
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import org.robolectric.RobolectricTestRunner
import org.mockito.Mock
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    
    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = picasso,
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  private val picasso = mockPicasso(RuntimeEnvironment.application)

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator(picasso).tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val spyPicasso = spy(picasso) 
    val creator = RequestCreator(spyPicasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
    verify(spyPicasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Captor
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  @Mock private lateinit var picasso: Picasso
  @Captor private lateinit var actionCaptor: ArgumentCaptor<Action>

  private val bitmap = makeBitmap()

  @Before fun shutUp() {
    initMocks(this)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)
  }

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator().resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator().placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator().noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator().error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator().priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator().tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator().transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mock(Picasso::class.java)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mock(Picasso::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mock(Picasso::class.java)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.Captor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  @Captor
  internal lateinit var actionCaptor: ArgumentCaptor<Action>

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator().tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)

    val creator = RequestCreator(picasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}