
package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
      update()
      callback?.onSuccess()
    }
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result.Drawable(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result.Bitmap(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {

    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3

import com.squareup.picasso3.RequestHandler.Result


interface Transformation {
  
  fun transform(source: Result.Bitmap): Result.Bitmap

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.Picasso.LoadedFrom
import java.io.IOException


abstract class RequestHandler {
  
  sealed class Result constructor(
    
    @JvmField val loadedFrom: LoadedFrom,
    
    @JvmField val exifRotation: Int = 0
  ) {
    class Bitmap @JvmOverloads constructor(
      val bitmap: android.graphics.Bitmap,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)

    class Drawable @JvmOverloads constructor(
      val drawable: android.graphics.drawable.Drawable,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)
  }

  interface Callback {
    fun onSuccess(result: Result?)
    fun onError(t: Throwable)
  }

  
  abstract fun canHandleRequest(data: Request): Boolean

  
  @Throws(IOException::class)
  abstract fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  )

  open val retryCount = 0

  open fun shouldRetry(
    airplaneMode: Boolean,
    info: NetworkInfo?
  ) = false

  open fun supportsReplay() = false
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result.Bitmap): Result.Bitmap {
    val bitmap = source.bitmap

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result.Bitmap(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
    update()
    callback?.onSuccess()
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    val bitmap = result.bitmap
    if (bitmap != null) {
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3


interface Transformation {
  
  fun transform(source: RequestHandler.Result): RequestHandler.Result

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result): Result {
    val bitmap = source.bitmap ?: return source

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import okhttp3.Headers
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val headers: Headers? = builder.headers

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0
    var headers: Headers? = null

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    fun addHeader(
      name: String,
      value: String
    ) = apply {
      this.headers = (headers?.newBuilder() ?: Headers.Builder())
        .add(name, value)
        .build()
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    val requestHeaders = request.headers
    if (requestHeaders != null) {
      builder.headers(requestHeaders)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun customHeaders() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(
      picasso,
      key = URI_KEY_1,
      uri = URI_1,
      headers = mapOf(CUSTOM_HEADER_NAME to CUSTOM_HEADER_VALUE)
    )
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          with(requests.first.headers) {
            assertThat(names()).containsExactly(CUSTOM_HEADER_NAME)
            assertThat(values(CUSTOM_HEADER_NAME)).containsExactly(CUSTOM_HEADER_VALUE)
          }
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3.stats

import android.graphics.Bitmap
import android.util.Log
import androidx.core.graphics.BitmapCompat
import com.squareup.picasso3.EventListener
import com.squareup.picasso3.Picasso
import okio.Buffer
import okio.BufferedSink
import java.io.IOException
import kotlin.math.ceil

class StatsEventListener : EventListener {
  private var maxCacheSize = 0
  private var cacheSize = 0

  private var cacheHits = 0L
  private var cacheMisses = 0L
  private var totalDownloadSize = 0L
  private var totalOriginalBitmapSize = 0L
  private var totalTransformedBitmapSize = 0L

  private var averageDownloadSize = 0.0
  private var averageOriginalBitmapSize = 0.0
  private var averageTransformedBitmapSize = 0.0

  private var downloadCount = 0
  private var originalBitmapCount = 0
  private var transformedBitmapCount = 0

  override fun cacheMaxSize(maxSize: Int) {
    maxCacheSize = maxSize
  }

  override fun cacheSize(size: Int) {
    cacheSize = size
  }

  override fun cacheHit() {
    cacheHits++
  }

  override fun cacheMiss() {
    cacheMisses++
  }

  override fun downloadFinished(size: Long) {
    downloadCount++
    totalDownloadSize += size
    averageDownloadSize = average(downloadCount, totalDownloadSize)
  }

  override fun bitmapDecoded(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    originalBitmapCount++
    totalOriginalBitmapSize += bitmapSize
    averageOriginalBitmapSize = average(originalBitmapCount, totalOriginalBitmapSize)
  }

  override fun bitmapTransformed(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    transformedBitmapCount++
    totalTransformedBitmapSize += bitmapSize
    averageTransformedBitmapSize = average(originalBitmapCount, totalTransformedBitmapSize)
  }

  fun getSnapshot() = Snapshot(
      maxCacheSize, cacheSize, cacheHits, cacheMisses,
      totalDownloadSize, totalOriginalBitmapSize, totalTransformedBitmapSize, averageDownloadSize,
      averageOriginalBitmapSize, averageTransformedBitmapSize, downloadCount, originalBitmapCount,
      transformedBitmapCount, System.currentTimeMillis()
  )

  private fun average(
    count: Int,
    totalSize: Long
  ): Double = totalSize * 1.0 / count

  data class Snapshot(
    val maxSize: Int,
    val size: Int,
    val cacheHits: Long,
    val cacheMisses: Long,
    val totalDownloadSize: Long,
    val totalOriginalBitmapSize: Long,
    val totalTransformedBitmapSize: Long,
    val averageDownloadSize: Double,
    val averageOriginalBitmapSize: Double,
    val averageTransformedBitmapSize: Double,
    val downloadCount: Int,
    val originalBitmapCount: Int,
    val transformedBitmapCount: Int,
    val timeStamp: Long
  ) {
    
    fun dump() {
      val buffer = Buffer()
      try {
        dump(buffer)
      } catch (e: IOException) {
        throw AssertionError(e)
      }

      Log.i(Picasso.TAG, buffer.readUtf8())
    }

    
    @Throws(IOException::class)
    fun dump(sink: BufferedSink) {
      sink.writeUtf8("===============BEGIN PICASSO STATS ===============")
      sink.writeUtf8("\n")
      sink.writeUtf8("Memory Cache Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Max Cache Size: ")
      sink.writeUtf8(maxSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Size: ")
      sink.writeUtf8(size.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache % Full: ")
      sink.writeUtf8(ceil((size.toDouble() / maxSize * 100)).toInt().toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Hits: ")
      sink.writeUtf8(cacheHits.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Misses: ")
      sink.writeUtf8(cacheMisses.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Network Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Download Count: ")
      sink.writeUtf8(downloadCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Download Size: ")
      sink.writeUtf8(totalDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Download Size: ")
      sink.writeUtf8(averageDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Bitmap Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmaps Decoded: ")
      sink.writeUtf8(originalBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmap Size: ")
      sink.writeUtf8(totalOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmaps: ")
      sink.writeUtf8(transformedBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmap Size: ")
      sink.writeUtf8(totalTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Bitmap Size: ")
      sink.writeUtf8(averageOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Transformed Bitmap Size: ")
      sink.writeUtf8(averageTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("===============END PICASSO STATS ===============")
      sink.writeUtf8("\n")
    }
  }
}
<code block>
package com.example.picasso.provider

import com.squareup.picasso3.Picasso
import com.squareup.picasso3.stats.StatsEventListener


object PicassoProvider {
  private val instance: Picasso by lazy {
    Picasso
        .Builder(PicassoContentProvider.autoContext!!)
        .addEventListener(StatsEventListener())
        .build()
  }

  @JvmStatic
  fun get() = instance
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.util.Log
import androidx.core.graphics.BitmapCompat
import okio.Buffer
import okio.BufferedSink
import java.io.IOException
import kotlin.math.ceil

class StatsEventListener : EventListener {
  private var maxCacheSize = 0
  private var cacheSize = 0

  private var cacheHits = 0L
  private var cacheMisses = 0L
  private var totalDownloadSize = 0L
  private var totalOriginalBitmapSize = 0L
  private var totalTransformedBitmapSize = 0L

  private var averageDownloadSize = 0.0
  private var averageOriginalBitmapSize = 0.0
  private var averageTransformedBitmapSize = 0.0

  private var downloadCount = 0
  private var originalBitmapCount = 0
  private var transformedBitmapCount = 0

  override fun cacheMaxSize(maxSize: Int) {
    maxCacheSize = maxSize
  }

  override fun cacheSize(size: Int) {
    cacheSize = size
  }

  override fun cacheHit() {
    cacheHits++
  }

  override fun cacheMiss() {
    cacheMisses++
  }

  override fun downloadFinished(size: Long) {
    downloadCount++
    totalDownloadSize += size
    averageDownloadSize = average(downloadCount, totalDownloadSize)
  }

  override fun bitmapDecoded(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    originalBitmapCount++
    totalOriginalBitmapSize += bitmapSize
    averageOriginalBitmapSize = average(originalBitmapCount, totalOriginalBitmapSize)
  }

  override fun bitmapTransformed(bitmap: Bitmap) {
    val bitmapSize = BitmapCompat.getAllocationByteCount(bitmap)

    transformedBitmapCount++
    totalTransformedBitmapSize += bitmapSize
    averageTransformedBitmapSize = average(originalBitmapCount, totalTransformedBitmapSize)
  }

  fun getSnapshot() = Snapshot(
      maxCacheSize, cacheSize, cacheHits, cacheMisses,
      totalDownloadSize, totalOriginalBitmapSize, totalTransformedBitmapSize, averageDownloadSize,
      averageOriginalBitmapSize, averageTransformedBitmapSize, downloadCount, originalBitmapCount,
      transformedBitmapCount, System.currentTimeMillis()
  )

  private fun average(
    count: Int,
    totalSize: Long
  ): Double = totalSize * 1.0 / count

  data class Snapshot(
    val maxSize: Int,
    val size: Int,
    val cacheHits: Long,
    val cacheMisses: Long,
    val totalDownloadSize: Long,
    val totalOriginalBitmapSize: Long,
    val totalTransformedBitmapSize: Long,
    val averageDownloadSize: Double,
    val averageOriginalBitmapSize: Double,
    val averageTransformedBitmapSize: Double,
    val downloadCount: Int,
    val originalBitmapCount: Int,
    val transformedBitmapCount: Int,
    val timeStamp: Long
  ) {
    
    fun dump() {
      val buffer = Buffer()
      try {
        dump(buffer)
      } catch (e: IOException) {
        throw AssertionError(e)
      }

      Log.i(Picasso.TAG, buffer.readUtf8())
    }

    
    @Throws(IOException::class)
    fun dump(sink: BufferedSink) {
      sink.writeUtf8("===============BEGIN PICASSO STATS ===============")
      sink.writeUtf8("\n")
      sink.writeUtf8("Memory Cache Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Max Cache Size: ")
      sink.writeUtf8(maxSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Size: ")
      sink.writeUtf8(size.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache % Full: ")
      sink.writeUtf8(ceil((size.toDouble() / maxSize * 100)).toInt().toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Hits: ")
      sink.writeUtf8(cacheHits.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Cache Misses: ")
      sink.writeUtf8(cacheMisses.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Network Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Download Count: ")
      sink.writeUtf8(downloadCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Download Size: ")
      sink.writeUtf8(totalDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Download Size: ")
      sink.writeUtf8(averageDownloadSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("Bitmap Stats")
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmaps Decoded: ")
      sink.writeUtf8(originalBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Bitmap Size: ")
      sink.writeUtf8(totalOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmaps: ")
      sink.writeUtf8(transformedBitmapCount.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Total Transformed Bitmap Size: ")
      sink.writeUtf8(totalTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Bitmap Size: ")
      sink.writeUtf8(averageOriginalBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("  Average Transformed Bitmap Size: ")
      sink.writeUtf8(averageTransformedBitmapSize.toString())
      sink.writeUtf8("\n")
      sink.writeUtf8("===============END PICASSO STATS ===============")
      sink.writeUtf8("\n")
    }
  }
}
<code block>
package com.example.picasso.provider

import com.squareup.picasso3.Picasso
import com.squareup.picasso3.StatsEventListener


object PicassoProvider {
  private val instance: Picasso by lazy {
    Picasso
        .Builder(PicassoContentProvider.autoContext!!)
        .addEventListener(StatsEventListener())
        .build()
  }

  @JvmStatic
  fun get() = instance
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.util.Log
import androidx.annotation.CallSuper
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService

internal abstract class Dispatcher internal constructor(
  private val context: Context,
  @get:JvmName("-service") internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val scansNetworkChanges: Boolean

  init {
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  @CallSuper open fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  abstract fun dispatchSubmit(action: Action)

  abstract fun dispatchCancel(action: Action)

  abstract fun dispatchPauseTag(tag: Any)

  abstract fun dispatchResumeTag(tag: Any)

  abstract fun dispatchComplete(hunter: BitmapHunter)

  abstract fun dispatchRetry(hunter: BitmapHunter)

  abstract fun dispatchFailed(hunter: BitmapHunter)

  abstract fun dispatchNetworkStateChange(info: NetworkInfo)

  abstract fun dispatchAirplaneModeChange(airplaneMode: Boolean)

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    const val RETRY_DELAY = 500L
    const val HUNTER_COMPLETE = 4
    const val NETWORK_STATE_CHANGE = 9
    const val REQUEST_BATCH_RESUME = 13
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = HandlerDispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import java.util.concurrent.ExecutorService

internal class HandlerDispatcher internal constructor(
  context: Context,
  service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache
) : Dispatcher(context, service, mainThreadHandler, cache) {

  private val dispatcherThread: DispatcherThread
  private val handler: Handler

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
  }

  override fun shutdown() {
    super.shutdown()

    dispatcherThread.quit()
  }

  override fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  override fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  override fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  override fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )
  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return HandlerDispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import android.util.Log
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService

internal class Dispatcher internal constructor(
  private val context: Context,
  @get:JvmName("-service") internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val dispatcherThread: DispatcherThread
  private val handler: Handler
  private val scansNetworkChanges: Boolean

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    dispatcherThread.quit()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.util.Log
import androidx.annotation.CallSuper
import androidx.annotation.MainThread
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap

internal abstract class BaseDispatcher internal constructor(
  private val context: Context,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) : Dispatcher {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val scansNetworkChanges: Boolean

  init {
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  @CallSuper override fun shutdown() {
    
    mainThreadHandler.post { receiver.unregister() }
  }

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (isShutdown()) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    dispatchSubmit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      dispatchBatchResumeMain(batch)
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (isShutdown()) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      dispatchSubmit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  @MainThread
  fun performCompleteMain(hunter: BitmapHunter) {
    hunter.picasso.complete(hunter)
  }

  @MainThread
  fun performBatchResumeMain(batch: List<Action>) {
    for (i in batch.indices) {
      val action = batch[i]
      action.picasso.resumeAction(action)
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    dispatchCompleteMain(hunter)
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  internal class NetworkBroadcastReceiver(
    private val dispatcher: BaseDispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_HUNTER
import com.squareup.picasso3.Utils.THREAD_PREFIX
import com.squareup.picasso3.Utils.VERB_DECODED
import com.squareup.picasso3.Utils.VERB_EXECUTING
import com.squareup.picasso3.Utils.VERB_JOINED
import com.squareup.picasso3.Utils.VERB_REMOVED
import com.squareup.picasso3.Utils.VERB_TRANSFORMED
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.io.InterruptedIOException
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Future
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicReference
import kotlinx.coroutines.Job

internal open class BitmapHunter(
  val picasso: Picasso,
  private val dispatcher: Dispatcher,
  private val cache: PlatformLruCache,
  action: Action,
  val requestHandler: RequestHandler
) : Runnable {
  val sequence: Int = SEQUENCE_GENERATOR.incrementAndGet()
  var priority: Picasso.Priority = action.request.priority
  var data: Request = action.request
  val key: String = action.request.key
  var retryCount: Int = requestHandler.retryCount

  var action: Action? = action
    private set
  var actions: MutableList<Action>? = null
    private set

  var future: Future<*>? = null

  var job: Job? = null

  var result: RequestHandler.Result? = null
    private set
  var exception: Exception? = null
    private set

  val isCancelled: Boolean
    get() = future?.isCancelled ?: job?.isCancelled ?: false

  override fun run() {
    val originalName = Thread.currentThread().name
    try {
      Thread.currentThread().name = getName()

      if (picasso.isLoggingEnabled) {
        log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this))
      }

      result = hunt()
      dispatcher.dispatchComplete(this)
    } catch (e: IOException) {
      exception = e
      if (retryCount > 0) {
        dispatcher.dispatchRetry(this)
      } else {
        dispatcher.dispatchFailed(this)
      }
    } catch (e: Exception) {
      exception = e
      dispatcher.dispatchFailed(this)
    } finally {
      Thread.currentThread().name = originalName
    }
  }

  fun getName() = NAME_BUILDER.get()!!.also {
    val name = data.name
    it.ensureCapacity(THREAD_PREFIX.length + name.length)
    it.replace(THREAD_PREFIX.length, it.length, name)
  }.toString()

  fun hunt(): Bitmap? {
    if (shouldReadFromMemoryCache(data.memoryPolicy)) {
      cache[key]?.let { bitmap ->
        picasso.cacheHit()
        if (picasso.isLoggingEnabled) {
          log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache")
        }

        return Bitmap(bitmap, LoadedFrom.MEMORY)
      }
    }

    if (retryCount == 0) {
      data = data.newBuilder().networkPolicy(NetworkPolicy.OFFLINE).build()
    }

    val resultReference = AtomicReference<RequestHandler.Result?>()
    val exceptionReference = AtomicReference<Throwable>()

    val latch = CountDownLatch(1)
    try {
      requestHandler.load(
        picasso = picasso,
        request = data,
        callback = object : RequestHandler.Callback {
          override fun onSuccess(result: RequestHandler.Result?) {
            resultReference.set(result)
            latch.countDown()
          }

          override fun onError(t: Throwable) {
            exceptionReference.set(t)
            latch.countDown()
          }
        }
      )

      latch.await()
    } catch (ie: InterruptedException) {
      val interruptedIoException = InterruptedIOException()
      interruptedIoException.initCause(ie)
      throw interruptedIoException
    }

    exceptionReference.get()?.let { throwable ->
      when (throwable) {
        is IOException, is Error, is RuntimeException -> throw throwable
        else -> throw RuntimeException(throwable)
      }
    }

    val result = resultReference.get() as? Bitmap ?: return null
    val bitmap = result.bitmap
    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_DECODED, data.logId())
    }
    picasso.bitmapDecoded(bitmap)

    val transformations = ArrayList<Transformation>(data.transformations.size + 1)
    if (data.needsMatrixTransform() || result.exifRotation != 0) {
      transformations += MatrixTransformation(data)
    }
    transformations += data.transformations

    val transformedResult =
      applyTransformations(picasso, data, transformations, result) ?: return null
    val transformedBitmap = transformedResult.bitmap
    picasso.bitmapTransformed(transformedBitmap)

    return transformedResult
  }

  fun attach(action: Action) {
    val loggingEnabled = picasso.isLoggingEnabled
    val request = action.request
    if (this.action == null) {
      this.action = action
      if (loggingEnabled) {
        if (actions.isNullOrEmpty()) {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), "to empty hunter")
        } else {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
        }
      }

      return
    }

    if (actions == null) {
      actions = ArrayList(3)
    }
    actions!!.add(action)

    if (loggingEnabled) {
      log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
    }

    val actionPriority = action.request.priority
    if (actionPriority.ordinal > priority.ordinal) {
      priority = actionPriority
    }
  }

  fun detach(action: Action) {
    val detached = when {
      this.action === action -> {
        this.action = null
        true
      }
      else -> actions?.remove(action) ?: false
    }

    
    
    if (detached && action.request.priority == priority) {
      priority = computeNewPriority()
    }

    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_REMOVED, action.request.logId(), getLogIdsForHunter(this, "from "))
    }
  }

  fun cancel(): Boolean =
    action == null && actions.isNullOrEmpty() && future?.cancel(false) ?: job?.let { it.cancel(); true } ?: false

  fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
    val hasRetries = retryCount > 0
    if (!hasRetries) {
      return false
    }
    retryCount--

    return requestHandler.shouldRetry(airplaneMode, info)
  }

  fun supportsReplay(): Boolean = requestHandler.supportsReplay()

  private fun computeNewPriority(): Picasso.Priority {
    val hasMultiple = actions?.isNotEmpty() ?: false
    val hasAny = action != null || hasMultiple

    
    if (!hasAny) {
      return Picasso.Priority.LOW
    }

    var newPriority = action?.request?.priority ?: Picasso.Priority.LOW

    actions?.let { actions ->
      
      for (i in actions.indices) {
        val priority = actions[i].request.priority
        if (priority.ordinal > newPriority.ordinal) {
          newPriority = priority
        }
      }
    }

    return newPriority
  }

  companion object {
    internal val NAME_BUILDER: ThreadLocal<StringBuilder> = object : ThreadLocal<StringBuilder>() {
      override fun initialValue(): StringBuilder = StringBuilder(THREAD_PREFIX)
    }
    val SEQUENCE_GENERATOR = AtomicInteger()
    internal val ERRORING_HANDLER: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean = true

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        callback.onError(IllegalStateException("Unrecognized type of request: $request"))
      }
    }

    fun forRequest(
      picasso: Picasso,
      dispatcher: Dispatcher,
      cache: PlatformLruCache,
      action: Action
    ): BitmapHunter {
      val request = action.request
      val requestHandlers = picasso.requestHandlers

      
      for (i in requestHandlers.indices) {
        val requestHandler = requestHandlers[i]
        if (requestHandler.canHandleRequest(request)) {
          return BitmapHunter(picasso, dispatcher, cache, action, requestHandler)
        }
      }

      return BitmapHunter(picasso, dispatcher, cache, action, ERRORING_HANDLER)
    }

    fun applyTransformations(
      picasso: Picasso,
      data: Request,
      transformations: List<Transformation>,
      result: Bitmap
    ): Bitmap? {
      var res = result

      for (i in transformations.indices) {
        val transformation = transformations[i]
        val newResult = try {
          val transformedResult = transformation.transform(res)
          if (picasso.isLoggingEnabled) {
            log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), "from transformations")
          }

          transformedResult
        } catch (e: RuntimeException) {
          Picasso.HANDLER.post {
            throw RuntimeException(
              "Transformation ${transformation.key()} crashed with exception.",
              e
            )
          }

          return null
        }

        val bitmap = newResult.bitmap
        if (bitmap.isRecycled) {
          Picasso.HANDLER.post {
            throw IllegalStateException(
              "Transformation ${transformation.key()} returned a recycled Bitmap."
            )
          }

          return null
        }

        res = newResult
      }

      return res
    }
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo

internal interface Dispatcher {
  fun shutdown()

  fun dispatchSubmit(action: Action)

  fun dispatchCancel(action: Action)

  fun dispatchPauseTag(tag: Any)

  fun dispatchResumeTag(tag: Any)

  fun dispatchComplete(hunter: BitmapHunter)

  fun dispatchRetry(hunter: BitmapHunter)

  fun dispatchFailed(hunter: BitmapHunter)

  fun dispatchNetworkStateChange(info: NetworkInfo)

  fun dispatchAirplaneModeChange(airplaneMode: Boolean)

  fun dispatchSubmit(hunter: BitmapHunter)

  fun dispatchCompleteMain(hunter: BitmapHunter)

  fun dispatchBatchResumeMain(batch: MutableList<Action>)

  fun isShutdown(): Boolean

  companion object {
    const val RETRY_DELAY = 500L
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import com.squareup.picasso3.Dispatcher.Companion.RETRY_DELAY
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

@OptIn(ExperimentalCoroutinesApi::class)
internal class InternalCoroutineDispatcher internal constructor(
  context: Context,
  mainThreadHandler: Handler,
  cache: PlatformLruCache,
  val mainDispatcher: CoroutineDispatcher,
  val backgroundDispatcher: CoroutineDispatcher
) : BaseDispatcher(context, mainThreadHandler, cache) {

  private val scope = CoroutineScope(SupervisorJob() + backgroundDispatcher)
  private val channel = Channel<() -> Unit>(capacity = Channel.UNLIMITED)

  init {
    
    scope.launch {
      while (!channel.isClosedForReceive) {
        channel.receive().invoke()
      }
    }
  }

  override fun shutdown() {
    super.shutdown()
    channel.close()
    scope.cancel()
  }

  override fun dispatchSubmit(action: Action) {
    channel.trySend {
      performSubmit(action)
    }
  }

  override fun dispatchCancel(action: Action) {
    channel.trySend {
      performCancel(action)
    }
  }

  override fun dispatchPauseTag(tag: Any) {
    channel.trySend {
      performPauseTag(tag)
    }
  }

  override fun dispatchResumeTag(tag: Any) {
    channel.trySend {
      performResumeTag(tag)
    }
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    channel.trySend {
      performComplete(hunter)
    }
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    scope.launch {
      delay(RETRY_DELAY)
      channel.send {
        performRetry(hunter)
      }
    }
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    channel.trySend {
      performError(hunter)
    }
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    channel.trySend {
      performNetworkStateChange(info)
    }
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    channel.trySend {
      performAirplaneModeChange(airplaneMode)
    }
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    scope.launch(mainDispatcher) {
      performCompleteMain(hunter)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    scope.launch(mainDispatcher) {
      performBatchResumeMain(batch)
    }
  }

  override fun dispatchSubmit(hunter: BitmapHunter) {
    hunter.job = scope.launch(CoroutineName(hunter.getName())) {
      hunter.run()
    }
  }

  override fun isShutdown() = !scope.isActive
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var mainDispatcher: CoroutineDispatcher? = null
    private var backgroundDispatcher: CoroutineDispatcher? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = (picasso.dispatcher as? HandlerDispatcher)?.service
      mainDispatcher = (picasso.dispatcher as? InternalCoroutineDispatcher)?.mainDispatcher
      backgroundDispatcher = (picasso.dispatcher as? InternalCoroutineDispatcher)?.backgroundDispatcher
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun dispatchers(
      mainDispatcher: CoroutineDispatcher = Dispatchers.Main,
      backgroundDispatcher: CoroutineDispatcher = Dispatchers.IO
    ) = apply {
      this.mainDispatcher = mainDispatcher
      this.backgroundDispatcher = backgroundDispatcher
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }

      val dispatcher = if (backgroundDispatcher != null) {
        InternalCoroutineDispatcher(context, HANDLER, cache!!, mainDispatcher!!, backgroundDispatcher!!)
      } else {
        if (service == null) {
          service = PicassoExecutorService()
        }

        HandlerDispatcher(context, service!!, HANDLER, cache!!)
      }

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER = Handler(Looper.getMainLooper())
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import java.util.concurrent.ExecutorService

internal class HandlerDispatcher internal constructor(
  context: Context,
  @get:JvmName("-service") val service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache
) : BaseDispatcher(context, mainThreadHandler, cache) {

  private val dispatcherThread: DispatcherThread
  private val handler: Handler
  private val mainHandler: Handler

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    mainHandler = MainDispatcherHandler(mainThreadHandler.looper, this)
  }

  override fun shutdown() {
    super.shutdown()
    
    (service as? PicassoExecutorService)?.shutdown()

    dispatcherThread.quit()
  }

  override fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  override fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  override fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  override fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  override fun dispatchSubmit(hunter: BitmapHunter) {
    hunter.future = service.submit(hunter)
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    val message = mainHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainHandler.sendMessage(message)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    mainHandler.sendMessage(mainHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
  }
  override fun isShutdown() = service.isShutdown

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: HandlerDispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          dispatcher.mainHandler.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  private class MainDispatcherHandler(
    looper: Looper,
    val dispatcher: HandlerDispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performCompleteMain(hunter)
        }
        REQUEST_BATCH_RESUME -> {
          val batch = msg.obj as List<Action>
          dispatcher.performBatchResumeMain(batch)
        }
        else -> throw AssertionError("Unknown handler message received: " + msg.what)
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )
  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    private const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    private const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    private const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context

  @Mock internal lateinit var dispatcher: Dispatcher

  @Mock internal lateinit var requestHandler: RequestHandler

  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyNoInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsTargetsToActions() {
    picasso.targetToAction[mockImageViewTarget()] = mock(ImageViewAction::class.java)
    picasso.shutdown()
    assertThat(picasso.targetToAction).isEmpty()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat((child.dispatcher as HandlerDispatcher).service).isEqualTo((parent.dispatcher as HandlerDispatcher).service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  @Test fun cloneSharesCoroutineDispatchers() {
    val parent =
      defaultPicasso(RuntimeEnvironment.application, true, true)
        .newBuilder()
        .dispatchers()
        .build()
    val child = parent.newBuilder().build()

    val parentDispatcher = parent.dispatcher as InternalCoroutineDispatcher
    val childDispatcher = child.dispatcher as InternalCoroutineDispatcher
    assertThat(childDispatcher.mainDispatcher).isEqualTo(parentDispatcher.mainDispatcher)
    assertThat(childDispatcher.backgroundDispatcher).isEqualTo(parentDispatcher.backgroundDispatcher)
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import com.squareup.picasso3.BaseDispatcher.NetworkBroadcastReceiver
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BaseDispatcherTest {
  @Mock lateinit var context: Context

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)

    receiver.onReceive(context, null)

    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = TestUtils.mockNetworkInfo()
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    Mockito.`when`(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)

    receiver.onReceive(context, Intent(ConnectivityManager.CONNECTIVITY_ACTION))

    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)

    receiver.onReceive(context, Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED))

    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(BaseDispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(NetworkBroadcastReceiver.EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.pm.PackageManager
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Request.Builder
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers
import org.mockito.Mock
import org.mockito.Mockito
import org.mockito.MockitoAnnotations
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows
import java.lang.Exception
import java.lang.RuntimeException
import kotlinx.coroutines.Job
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestDispatcher

@RunWith(RobolectricTestRunner::class)
class InternalCoroutineDispatcherTest {

  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: InternalCoroutineDispatcher
  private lateinit var testDispatcher: TestDispatcher

  private val cache = PlatformLruCache(2048)
  private val bitmap1 = TestUtils.makeBitmap()

  @Before fun setUp() {
    MockitoAnnotations.initMocks(this)
    Mockito.`when`(context.applicationContext).thenReturn(context)
    dispatcher = createDispatcher()
  }

  @Test fun shutdownCancelsRunningJob() {
    createDispatcher(true)
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    dispatcher.dispatchSubmit(action)

    dispatcher.shutdown()
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.isShutdown()).isEqualTo(true)
    assertThat(action.completedResult).isNull()
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    Shadows.shadowOf(Looper.getMainLooper()).idle()
    Mockito.verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun dispatchSubmitWithNewRequestQueuesHunter() {
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    dispatcher.dispatchSubmit(action)

    testDispatcher.scheduler.runCurrent()

    assertThat(action.completedResult).isNotNull()
  }

  @Test fun dispatchSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val action2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_2, TestUtils.URI_2)

    dispatcher.dispatchSubmit(action1)
    dispatcher.dispatchSubmit(action2)

    testDispatcher.scheduler.runCurrent()

    assertThat(action1.completedResult).isNotNull()
    assertThat(action2.completedResult).isNotNull()
    assertThat(action2.completedResult).isNotEqualTo(action1.completedResult)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val action2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)

    dispatcher.dispatchSubmit(action1)
    dispatcher.dispatchSubmit(action2)
    testDispatcher.scheduler.runCurrent()

    assertThat(action1.completedResult).isNotNull()
    assertThat(action2.completedResult).isEqualTo(action1.completedResult)
  }

  @Test fun dispatchSubmitWithShutdownServiceIgnoresRequest() {
    dispatcher.shutdown()

    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    dispatcher.dispatchSubmit(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.dispatchPauseTag(pausedTag)
    testDispatcher.scheduler.runCurrent()
    assertThat(dispatcher.pausedActions).isEmpty()

    var completed = false
    val fetchAction1 = noopAction(Request.Builder(TestUtils.URI_1).tag(pausedTag).build(), { completed = true })
    val fetchAction2 = noopAction(Request.Builder(TestUtils.URI_1).tag(pausedTag).build(), { completed = true })
    dispatcher.dispatchSubmit(fetchAction1)
    dispatcher.dispatchSubmit(fetchAction2)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).hasSize(2)
    assertThat(completed).isFalse()
  }

  @Test fun dispatchCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.dispatchPauseTag(pausedTag)
    testDispatcher.scheduler.runCurrent()
    assertThat(dispatcher.pausedActions).isEmpty()

    val callback = TestUtils.mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(TestUtils.URI_1).tag(pausedTag).build(), callback)
    dispatcher.dispatchSubmit(fetchAction1)
    testDispatcher.scheduler.runCurrent()
    assertThat(dispatcher.pausedActions).hasSize(1)

    dispatcher.dispatchCancel(fetchAction1)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun dispatchCancelDetachesRequestAndCleansUp() {
    val target = TestUtils.mockBitmapTarget()
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1, target)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action).apply {
      job = Job()
    }
    dispatcher.hunterMap[TestUtils.URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action

    dispatcher.dispatchCancel(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.job!!.isCancelled).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchCancelMultipleRequestsDetachesOnly() {
    val action1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val action2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[TestUtils.URI_KEY_1 + Request.KEY_SEPARATOR] = hunter

    dispatcher.dispatchCancel(action1)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun dispatchCancelUnqueuesAndDetachesPausedRequest() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    dispatcher.dispatchSubmit(action)
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()
    dispatcher.hunterMap[TestUtils.URI_KEY_1 + Request.KEY_SEPARATOR] = hunter

    dispatcher.dispatchCancel(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun dispatchCompleteSetsResultInCache() {
    val data = Request.Builder(TestUtils.URI_1).build()
    val action = noopAction(data)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    val result = hunter.result as Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun dispatchCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(TestUtils.URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun dispatchCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(TestUtils.URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isTrue()
  }

  @Test fun dispatchCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(TestUtils.URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.job = Job().apply { cancel() }

    dispatcher.dispatchComplete(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isFalse()
  }

  @Test fun dispatchErrorCleansUpAndPostsToMain() {
    val exception = RuntimeException()
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action, exception)
    hunter.run()
    dispatcher.hunterMap[hunter.key] = hunter

    dispatcher.dispatchFailed(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isEqualTo(exception)
  }

  @Test fun dispatchErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val exception = RuntimeException()
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action, exception)
    hunter.run()
    hunter.job = Job().apply { cancel() }
    dispatcher.hunterMap[hunter.key] = hunter

    dispatcher.dispatchFailed(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isNull()
  }

  @Test fun dispatchRetrySkipsIfHunterIsCancelled() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    hunter.job = Job().apply { cancel() }

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.runCurrent()

    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = TestUtils.mockNetworkInfo(true)
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_2, TestUtils.URI_2)
    val e = ContentLengthException("304 error")
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun dispatchRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = TestUtils.mockNetworkInfo(true)
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    )
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = TestUtils.mockNetworkInfo(true)
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(action.willReplay).isTrue()
  }

  @Test fun dispatchRetryRetriesIfNoNetworkScanning() {
    val dispatcher = createDispatcher(false)
    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true,
      dispatcher = dispatcher
    )

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(action.completedResult).isInstanceOf(Bitmap::class.java)
  }

  @Test fun dispatchRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(action.willReplay).isTrue()
  }

  @Test fun dispatchRetryRetriesIfShouldRetry() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(
      picasso,
      Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true,
      dispatcher = dispatcher
    )

    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(action.completedResult).isInstanceOf(Bitmap::class.java)
  }

  @Test fun dispatchRetrySkipIfServiceShutdown() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget()
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)

    dispatcher.shutdown()
    dispatcher.dispatchRetry(hunter)
    testDispatcher.scheduler.advanceUntilIdle()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()

    dispatcher.dispatchAirplaneModeChange(true)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.airplaneMode).isTrue()

    dispatcher.dispatchAirplaneModeChange(false)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun dispatchNetworkStateChangeWithDisconnectedInfoIgnores() {
    val info = TestUtils.mockNetworkInfo()
    Mockito.`when`(info.isConnectedOrConnecting).thenReturn(false)

    dispatcher.dispatchNetworkStateChange(info)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val info = TestUtils.mockNetworkInfo(true)

    dispatcher.dispatchNetworkStateChange(info)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun dispatchPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedTags).containsExactly("tag")

    dispatcher.dispatchResumeTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun dispatchPauseTagIsIdempotent() {
    val action = TestUtils.mockAction(
      picasso,
      TestUtils.URI_KEY_1,
      TestUtils.URI_1,
      TestUtils.mockBitmapTarget(),
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[TestUtils.URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()

    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)

    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun dispatchPauseTagQueuesNewRequestDoesNotComplete() {
    dispatcher.dispatchPauseTag("tag")
    val action = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      tag = "tag"
    )

    dispatcher.dispatchSubmit(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    val action = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1, "anothertag")
    dispatcher.dispatchSubmit(action)
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(action.completedResult).isNotNull()
  }

  @Test fun dispatchPauseDetachesRequestAndCancelsHunter() {
    val action = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      tag = "tag"
    )
    val hunter = TestUtils.mockHunter(
      picasso = picasso,
      result = Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.job = Job()

    dispatcher.hunterMap[TestUtils.URI_KEY_1] = hunter
    dispatcher.dispatchPauseTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(action.completedResult).isNull()
  }

  @Test fun dispatchPauseOnlyDetachesPausedRequest() {
    val action1 = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      target = TestUtils.mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = TestUtils.mockAction(
      picasso = picasso,
      key = TestUtils.URI_KEY_1,
      uri = TestUtils.URI_1,
      target = TestUtils.mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = TestUtils.mockHunter(picasso, Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[TestUtils.URI_KEY_1] = hunter

    dispatcher.dispatchPauseTag("tag1")
    testDispatcher.scheduler.runCurrent()

    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun dispatchResumeTagIsIdempotent() {
    var completedCount = 0
    val action = noopAction(Builder(TestUtils.URI_1).tag("tag").build(), { completedCount++ })

    dispatcher.dispatchPauseTag("tag")
    dispatcher.dispatchSubmit(action)
    dispatcher.dispatchResumeTag("tag")
    dispatcher.dispatchResumeTag("tag")
    testDispatcher.scheduler.runCurrent()

    assertThat(completedCount).isEqualTo(1)
  }

  @Test fun dispatchNetworkStateChangeFlushesFailedHunters() {
    val info = TestUtils.mockNetworkInfo(true)
    val failedAction1 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_1, TestUtils.URI_1)
    val failedAction2 = TestUtils.mockAction(picasso, TestUtils.URI_KEY_2, TestUtils.URI_2)
    dispatcher.failedActions[TestUtils.URI_KEY_1] = failedAction1
    dispatcher.failedActions[TestUtils.URI_KEY_2] = failedAction2

    dispatcher.dispatchNetworkStateChange(info)
    testDispatcher.scheduler.runCurrent()

    assertThat(failedAction1.completedResult).isNotNull()
    assertThat(failedAction2.completedResult).isNotNull()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  private fun createDispatcher(
    scansNetworkChanges: Boolean = true
  ): InternalCoroutineDispatcher {
    Mockito.`when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) Mockito.mock(NetworkInfo::class.java) else null
    )
    Mockito.`when`(context.getSystemService(Context.CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    Mockito.`when`(context.checkCallingOrSelfPermission(ArgumentMatchers.anyString())).thenReturn(
      if (scansNetworkChanges) PackageManager.PERMISSION_GRANTED else PackageManager.PERMISSION_DENIED
    )

    testDispatcher = StandardTestDispatcher()
    picasso = TestUtils.mockPicasso(context).newBuilder().dispatchers(testDispatcher, testDispatcher).build()
    return InternalCoroutineDispatcher(
      context,
      Handler(Looper.getMainLooper()),
      cache,
      testDispatcher,
      testDispatcher
    )
  }

  private fun noopAction(data: Request, onComplete: () -> Unit = { }): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = onComplete()
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = this
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Request.Builder
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.shadows.ShadowLooper
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class HandlerDispatcherTest {
  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: HandlerDispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isTrue()
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isFalse()
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isSameInstanceAs(exception)
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isNull()
    assertThat(action.completedResult).isNull()
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagResumesPausedActions() {
    val action = noopAction(Builder(URI_1).tag("tag").build())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)

    dispatcher.performResumeTag("tag")

    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): HandlerDispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): HandlerDispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return HandlerDispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request, onComplete: () -> Unit = { }): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = onComplete()
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = this
    }
  }
}

<code block>

package com.example.picasso

import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Canvas
import android.os.Bundle
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells.Adaptive
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.BasicText
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import com.squareup.picasso3.compose.rememberPainter
import kotlinx.coroutines.Dispatchers

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      Content(urls)
    }

    setContentView(composeView)
  }
}

@Composable
fun Content(urls: List<String>, picasso: Picasso = PicassoInitializer.get()) {
  var contentScale by remember { mutableStateOf(ContentScale.Inside) }
  var alignment by remember { mutableStateOf(Alignment.Center) }

  Column {
    ImageGrid(
      modifier = Modifier.weight(1F),
      urls = urls,
      contentScale = contentScale,
      alignment = alignment,
      picasso = picasso
    )

    Options(
      modifier = Modifier
        .background(Color.DarkGray)
        .padding(vertical = 4.dp),
      onContentScaleSelected = { contentScale = it },
      onAlignmentSelected = { alignment = it }
    )
  }
}

@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  contentScale: ContentScale,
  alignment: Alignment,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    columns = Adaptive(150.dp),
    modifier = modifier
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = contentScale,
        alignment = alignment,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

@Composable
fun Options(
  modifier: Modifier = Modifier,
  onContentScaleSelected: (ContentScale) -> Unit,
  onAlignmentSelected: (Alignment) -> Unit
) {
  var contentScaleKey by remember { mutableStateOf("Inside") }
  var alignmentKey by remember { mutableStateOf("Center") }
  Column(modifier = modifier) {
    CONTENT_SCALES.entries.chunked(4).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = contentScaleKey == key,
            onClick = {
              contentScaleKey = key
              onContentScaleSelected(value)
            }
          )
        }
      }
    }

    Spacer(modifier = Modifier.height(8.dp))

    ALIGNMENTS.entries.chunked(3).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = alignmentKey == key,
            onClick = {
              alignmentKey = key
              onAlignmentSelected(value)
            }
          )
        }
      }
    }
  }
}

@Composable
private fun OptionText(modifier: Modifier, key: String, selected: Boolean, onClick: () -> Unit) {
  Box(modifier = modifier) {
    BasicText(
      text = key,
      modifier = Modifier
        .align(Alignment.Center)
        .clip(RoundedCornerShape(8.dp))
        .clickable(onClick = onClick)
        .background(if (selected) Color.Blue else Color.White)
        .padding(horizontal = 8.dp, vertical = 4.dp)
    )
  }
}

private val CONTENT_SCALES = mapOf(
  Pair("Crop", ContentScale.Crop),
  Pair("Fit", ContentScale.Fit),
  Pair("Inside", ContentScale.Inside),
  Pair("Fill Width", ContentScale.FillWidth),
  Pair("Fill Height", ContentScale.FillHeight),
  Pair("Fill Bounds", ContentScale.FillBounds),
  Pair("None", ContentScale.None)
)

private val ALIGNMENTS = mapOf(
  Pair("TopStart", Alignment.TopStart),
  Pair("TopCenter", Alignment.TopCenter),
  Pair("TopEnd", Alignment.TopEnd),
  Pair("CenterStart", Alignment.CenterStart),
  Pair("Center", Alignment.Center),
  Pair("CenterEnd", Alignment.CenterEnd),
  Pair("BottomStart", Alignment.BottomStart),
  Pair("BottomCenter", Alignment.BottomCenter),
  Pair("BottomEnd", Alignment.BottomEnd)
)

@Preview
@Composable
private fun ContentPreview() {
  val images = listOf(
    Color.Blue.toArgb() to IntSize(200, 100),
    Color.Red.toArgb() to IntSize(100, 200),
    Color.Green.toArgb() to IntSize(100, 100),
    Color.Yellow.toArgb() to IntSize(300, 100),
    Color.Black.toArgb() to IntSize(100, 300),
    Color.LightGray.toArgb() to IntSize(400, 100),
    Color.Cyan.toArgb() to IntSize(100, 100),
    Color.White.toArgb() to IntSize(100, 400)
  ).associateBy { (color) -> "https:

  val context = LocalContext.current
  Content(
    urls = images.keys.toList(),
    picasso = remember {
      Picasso.Builder(context)
        .callFactory { throw AssertionError() } 
        .dispatchers(
          mainDispatcher = Dispatchers.Unconfined,
          backgroundDispatcher = Dispatchers.Unconfined
        )
        .addRequestHandler(
          object : RequestHandler() {
            override fun canHandleRequest(data: Request) = data.uri?.toString()?.run(images::containsKey) == true
            override fun load(picasso: Picasso, request: Request, callback: Callback) {
              val (color, size) = images[request.uri!!.toString()]!!
              val bitmap = Bitmap.createBitmap(size.width, size.height, Config.ARGB_8888).apply {
                Canvas(this).apply {
                  drawColor(color)
                }
              }

              callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
            }
          }
        )
        .build()
    }
  )
}

<code block>

package com.example.picasso.paparazzi

import android.graphics.BitmapFactory
import android.widget.ImageView
import android.widget.ImageView.ScaleType.CENTER
import app.cash.paparazzi.Paparazzi
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import org.junit.Rule
import org.junit.Test
import kotlinx.coroutines.Dispatchers

class PicassoPaparazziTest {
  @get:Rule val paparazzi = Paparazzi()

  @Test
  fun loadsUrlIntoImageView() {
    val picasso = Picasso.Builder(paparazzi.context)
      .callFactory { throw AssertionError() } 
      .dispatchers(
        mainDispatcher = Dispatchers.Unconfined,
        backgroundDispatcher = Dispatchers.Unconfined
      )
      .addRequestHandler(FakeRequestHandler())
      .build()

    paparazzi.snapshot(
      ImageView(paparazzi.context).apply {
        scaleType = CENTER
        picasso.load("fake:
          .resize(200, 200)
          .centerInside()
          .onlyScaleDown()
          .into(this)
      }
    )
  }

  class FakeRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return "fake" == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      val imagePath = request.uri!!.lastPathSegment!!
      callback.onSuccess(Result.Bitmap(loadBitmap(imagePath)!!, MEMORY))
    }

    private fun loadBitmap(imagePath: String): android.graphics.Bitmap? {
      val resourceAsStream = javaClass.classLoader!!.getResourceAsStream(imagePath)
      return BitmapFactory.decodeStream(resourceAsStream)
    }
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_HUNTER
import com.squareup.picasso3.Utils.THREAD_PREFIX
import com.squareup.picasso3.Utils.VERB_DECODED
import com.squareup.picasso3.Utils.VERB_EXECUTING
import com.squareup.picasso3.Utils.VERB_JOINED
import com.squareup.picasso3.Utils.VERB_REMOVED
import com.squareup.picasso3.Utils.VERB_TRANSFORMED
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.io.InterruptedIOException
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Future
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicReference

internal open class BitmapHunter(
  val picasso: Picasso,
  private val dispatcher: Dispatcher,
  private val cache: PlatformLruCache,
  action: Action,
  val requestHandler: RequestHandler
) : Runnable {
  val sequence: Int = SEQUENCE_GENERATOR.incrementAndGet()
  var priority: Picasso.Priority = action.request.priority
  var data: Request = action.request
  val key: String = action.request.key
  var retryCount: Int = requestHandler.retryCount

  var action: Action? = action
    private set
  var actions: MutableList<Action>? = null
    private set

  var future: Future<*>? = null
  var result: RequestHandler.Result? = null
    private set
  var exception: Exception? = null
    private set

  val isCancelled: Boolean
    get() = future?.isCancelled ?: false

  override fun run() {
    val originalName = Thread.currentThread().name
    try {
      updateThreadName(data)

      if (picasso.isLoggingEnabled) {
        log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this))
      }

      result = hunt()
      dispatcher.dispatchComplete(this)
    } catch (e: IOException) {
      exception = e
      if (retryCount > 0) {
        dispatcher.dispatchRetry(this)
      } else {
        dispatcher.dispatchFailed(this)
      }
    } catch (e: Exception) {
      exception = e
      dispatcher.dispatchFailed(this)
    } finally {
      Thread.currentThread().name = originalName
    }
  }

  fun hunt(): Bitmap? {
    if (shouldReadFromMemoryCache(data.memoryPolicy)) {
      cache[key]?.let { bitmap ->
        picasso.cacheHit()
        if (picasso.isLoggingEnabled) {
          log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache")
        }

        return Bitmap(bitmap, LoadedFrom.MEMORY)
      }
    }

    if (retryCount == 0) {
      data = data.newBuilder().networkPolicy(NetworkPolicy.OFFLINE).build()
    }

    val resultReference = AtomicReference<RequestHandler.Result?>()
    val exceptionReference = AtomicReference<Throwable>()

    val latch = CountDownLatch(1)
    try {
      requestHandler.load(
        picasso = picasso,
        request = data,
        callback = object : RequestHandler.Callback {
          override fun onSuccess(result: RequestHandler.Result?) {
            resultReference.set(result)
            latch.countDown()
          }

          override fun onError(t: Throwable) {
            exceptionReference.set(t)
            latch.countDown()
          }
        }
      )

      latch.await()
    } catch (ie: InterruptedException) {
      val interruptedIoException = InterruptedIOException()
      interruptedIoException.initCause(ie)
      throw interruptedIoException
    }

    exceptionReference.get()?.let { throwable ->
      when (throwable) {
        is IOException, is Error, is RuntimeException -> throw throwable
        else -> throw RuntimeException(throwable)
      }
    }

    val result = resultReference.get() as? Bitmap ?: return null
    val bitmap = result.bitmap
    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_DECODED, data.logId())
    }
    picasso.bitmapDecoded(bitmap)

    val transformations = ArrayList<Transformation>(data.transformations.size + 1)
    if (data.needsMatrixTransform() || result.exifRotation != 0) {
      transformations += MatrixTransformation(data)
    }
    transformations += data.transformations

    val transformedResult =
      applyTransformations(picasso, data, transformations, result) ?: return null
    val transformedBitmap = transformedResult.bitmap
    picasso.bitmapTransformed(transformedBitmap)

    return transformedResult
  }

  fun attach(action: Action) {
    val loggingEnabled = picasso.isLoggingEnabled
    val request = action.request
    if (this.action == null) {
      this.action = action
      if (loggingEnabled) {
        if (actions.isNullOrEmpty()) {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), "to empty hunter")
        } else {
          log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
        }
      }

      return
    }

    if (actions == null) {
      actions = ArrayList(3)
    }
    actions!!.add(action)

    if (loggingEnabled) {
      log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, "to "))
    }

    val actionPriority = action.request.priority
    if (actionPriority.ordinal > priority.ordinal) {
      priority = actionPriority
    }
  }

  fun detach(action: Action) {
    val detached = when {
      this.action === action -> {
        this.action = null
        true
      }
      else -> actions?.remove(action) ?: false
    }

    
    
    if (detached && action.request.priority == priority) {
      priority = computeNewPriority()
    }

    if (picasso.isLoggingEnabled) {
      log(OWNER_HUNTER, VERB_REMOVED, action.request.logId(), getLogIdsForHunter(this, "from "))
    }
  }

  fun cancel(): Boolean =
    action == null && actions.isNullOrEmpty() && future?.cancel(false) ?: false

  fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
    val hasRetries = retryCount > 0
    if (!hasRetries) {
      return false
    }
    retryCount--

    return requestHandler.shouldRetry(airplaneMode, info)
  }

  fun supportsReplay(): Boolean = requestHandler.supportsReplay()

  private fun computeNewPriority(): Picasso.Priority {
    val hasMultiple = actions?.isNotEmpty() ?: false
    val hasAny = action != null || hasMultiple

    
    if (!hasAny) {
      return Picasso.Priority.LOW
    }

    var newPriority = action?.request?.priority ?: Picasso.Priority.LOW

    actions?.let { actions ->
      
      for (i in actions.indices) {
        val priority = actions[i].request.priority
        if (priority.ordinal > newPriority.ordinal) {
          newPriority = priority
        }
      }
    }

    return newPriority
  }

  companion object {
    internal val NAME_BUILDER: ThreadLocal<StringBuilder> = object : ThreadLocal<StringBuilder>() {
      override fun initialValue(): StringBuilder = StringBuilder(THREAD_PREFIX)
    }
    val SEQUENCE_GENERATOR = AtomicInteger()
    internal val ERRORING_HANDLER: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean = true

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        callback.onError(IllegalStateException("Unrecognized type of request: $request"))
      }
    }

    fun forRequest(
      picasso: Picasso,
      dispatcher: Dispatcher,
      cache: PlatformLruCache,
      action: Action
    ): BitmapHunter {
      val request = action.request
      val requestHandlers = picasso.requestHandlers

      
      for (i in requestHandlers.indices) {
        val requestHandler = requestHandlers[i]
        if (requestHandler.canHandleRequest(request)) {
          return BitmapHunter(picasso, dispatcher, cache, action, requestHandler)
        }
      }

      return BitmapHunter(picasso, dispatcher, cache, action, ERRORING_HANDLER)
    }

    fun updateThreadName(data: Request) {
      val name = data.name
      val builder = NAME_BUILDER.get()!!.also {
        it.ensureCapacity(THREAD_PREFIX.length + name.length)
        it.replace(THREAD_PREFIX.length, it.length, name)
      }

      Thread.currentThread().name = builder.toString()
    }

    fun applyTransformations(
      picasso: Picasso,
      data: Request,
      transformations: List<Transformation>,
      result: Bitmap
    ): Bitmap? {
      var res = result

      for (i in transformations.indices) {
        val transformation = transformations[i]
        val newResult = try {
          val transformedResult = transformation.transform(res)
          if (picasso.isLoggingEnabled) {
            log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), "from transformations")
          }

          transformedResult
        } catch (e: RuntimeException) {
          Picasso.HANDLER.post {
            throw RuntimeException(
              "Transformation ${transformation.key()} crashed with exception.",
              e
            )
          }

          return null
        }

        val bitmap = newResult.bitmap
        if (bitmap.isRecycled) {
          Picasso.HANDLER.post {
            throw IllegalStateException(
              "Transformation ${transformation.key()} returned a recycled Bitmap."
            )
          }

          return null
        }

        res = newResult
      }

      return res
    }
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.util.Log
import androidx.annotation.CallSuper
import androidx.annotation.MainThread
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService

internal abstract class Dispatcher internal constructor(
  private val context: Context,
  @get:JvmName("-service") internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  @get:JvmName("-hunterMap")
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()

  @get:JvmName("-failedActions")
  internal val failedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedActions")
  internal val pausedActions = WeakHashMap<Any, Action>()

  @get:JvmName("-pausedTags")
  internal val pausedTags = mutableSetOf<Any>()

  @get:JvmName("-receiver")
  internal val receiver: NetworkBroadcastReceiver

  @get:JvmName("-airplaneMode")
  @set:JvmName("-airplaneMode")
  internal var airplaneMode = isAirplaneModeOn(context)

  private val scansNetworkChanges: Boolean

  init {
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  @CallSuper open fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    
    mainThreadHandler.post { receiver.unregister() }
  }

  abstract fun dispatchSubmit(action: Action)

  abstract fun dispatchCancel(action: Action)

  abstract fun dispatchPauseTag(tag: Any)

  abstract fun dispatchResumeTag(tag: Any)

  abstract fun dispatchComplete(hunter: BitmapHunter)

  abstract fun dispatchRetry(hunter: BitmapHunter)

  abstract fun dispatchFailed(hunter: BitmapHunter)

  abstract fun dispatchNetworkStateChange(info: NetworkInfo)

  abstract fun dispatchAirplaneModeChange(airplaneMode: Boolean)

  abstract fun dispatchCompleteMain(hunter: BitmapHunter)

  abstract fun dispatchBatchResumeMain(batch: MutableList<Action>)

  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.isLoggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.isLoggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.isLoggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while (iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.isLoggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      dispatchBatchResumeMain(batch)
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.isLoggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  @MainThread
  fun performCompleteMain(hunter: BitmapHunter) {
    hunter.picasso.complete(hunter)
  }

  @MainThread
  fun performBatchResumeMain(batch: List<Action>) {
    for (i in batch.indices) {
      val action = batch[i]
      action.picasso.resumeAction(action)
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.isLoggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    dispatchCompleteMain(hunter)

    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.isLoggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return 
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    const val RETRY_DELAY = 500L
    const val HUNTER_COMPLETE = 4
    const val NETWORK_STATE_CHANGE = 9
    const val REQUEST_BATCH_RESUME = 13
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import java.util.concurrent.ExecutorService
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

internal class InternalCoroutineDispatcher internal constructor(
  context: Context,
  service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache,
  val picassoDispatcher: CoroutineDispatcher
) : Dispatcher(context, service, mainThreadHandler, cache) {

  @OptIn(ExperimentalCoroutinesApi::class)
  private val scope = CoroutineScope(picassoDispatcher.limitedParallelism(1))

  override fun shutdown() {
    super.shutdown()
    scope.cancel()
  }

  override fun dispatchSubmit(action: Action) {
    scope.launch {
      performSubmit(action)
    }
  }

  override fun dispatchCancel(action: Action) {
    scope.launch {
      performCancel(action)
    }
  }

  override fun dispatchPauseTag(tag: Any) {
    scope.launch {
      performPauseTag(tag)
    }
  }

  override fun dispatchResumeTag(tag: Any) {
    scope.launch {
      performResumeTag(tag)
    }
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    scope.launch {
      performComplete(hunter)
    }
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    scope.launch {
      delay(RETRY_DELAY)
      performRetry(hunter)
    }
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    scope.launch {
      performError(hunter)
    }
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    scope.launch {
      performNetworkStateChange(info)
    }
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    scope.launch {
      performAirplaneModeChange(airplaneMode)
    }
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    scope.launch(Dispatchers.Main) {
      performCompleteMain(hunter)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    scope.launch(Dispatchers.Main) {
      performBatchResumeMain(batch)
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.WeakHashMap
import java.util.concurrent.ExecutorService
import kotlinx.coroutines.CoroutineDispatcher


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = WeakHashMap<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = WeakHashMap<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val target = actions[i].getTarget() ?: continue
      cancelExistingRequest(target)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        val target = action.getTarget() ?: continue
        cancelExistingRequest(target)
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToAction.clear()
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget() ?: return
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var picassoDispatcher: CoroutineDispatcher? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      picassoDispatcher = (picasso.dispatcher as? InternalCoroutineDispatcher)?.picassoDispatcher
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun dispatcher(picassoDispatcher: CoroutineDispatcher) = apply {
      this.picassoDispatcher = picassoDispatcher
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = picassoDispatcher?.let {
        InternalCoroutineDispatcher(context, service!!, HANDLER, cache!!, it)
      } ?: HandlerDispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,

    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER = Handler(Looper.getMainLooper())
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import java.util.concurrent.ExecutorService

internal class HandlerDispatcher internal constructor(
  context: Context,
  service: ExecutorService,
  mainThreadHandler: Handler,
  cache: PlatformLruCache
) : Dispatcher(context, service, mainThreadHandler, cache) {

  private val dispatcherThread: DispatcherThread
  private val handler: Handler
  private val mainHandler: Handler

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    mainHandler = MainDispatcherHandler(mainThreadHandler.looper, this)
  }

  override fun shutdown() {
    super.shutdown()

    dispatcherThread.quit()
  }

  override fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  override fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  override fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  override fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  override fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  override fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  override fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  override fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  override fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  override fun dispatchCompleteMain(hunter: BitmapHunter) {
    val message = mainHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainHandler.sendMessage(message)
    }
  }

  override fun dispatchBatchResumeMain(batch: MutableList<Action>) {
    mainHandler.sendMessage(mainHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: HandlerDispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          dispatcher.mainHandler.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  private class MainDispatcherHandler(
    looper: Looper,
    val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performCompleteMain(hunter)
        }
        REQUEST_BATCH_RESUME -> {
          val batch = msg.obj as List<Action>
          dispatcher.performBatchResumeMain(batch)
        }
        else -> throw AssertionError("Unknown handler message received: " + msg.what)
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )
  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Request.Builder
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.shadows.ShadowLooper
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.FutureTask
import kotlinx.coroutines.Dispatchers

@RunWith(RobolectricTestRunner::class)
class HandlerDispatcherTest : DispatcherTest() {
  override fun createDispatcher(
    context: Context,
    service: ExecutorService,
    cache: PlatformLruCache
  ) = HandlerDispatcher(context, service, Handler(getMainLooper()), cache)
}

@RunWith(RobolectricTestRunner::class)
class CoroutineDispatcherTest : DispatcherTest() {
  override fun createDispatcher(
    context: Context,
    service: ExecutorService,
    cache: PlatformLruCache
  ) = InternalCoroutineDispatcher(context, service, Handler(getMainLooper()), cache, Dispatchers.Main)
}

abstract class DispatcherTest {

  @Mock lateinit var context: Context

  @Mock lateinit var connectivityManager: ConnectivityManager

  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val executorService = spy(PicassoExecutorService())
  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(executorService)
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    doReturn(mock(Future::class.java)).`when`(executorService).submit(any(Runnable::class.java))
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isTrue()
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    var completed = false
    val action = noopAction(data, onComplete = { completed = true })
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(completed).isFalse()
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isSameInstanceAs(exception)
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val exception = RuntimeException()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, exception)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    hunter.run()

    dispatcher.performError(hunter)
    ShadowLooper.idleMainLooper()

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(action.errorException).isNull()
    assertThat(action.completedResult).isNull()
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null,
      shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = false,
      supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null,
      shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = URI_1,
      target = mockBitmapTarget(),
      tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagResumesPausedActions() {
    val action = noopAction(Builder(URI_1).tag("tag").build())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)

    dispatcher.performResumeTag("tag")

    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyNoInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyNoInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return createDispatcher(context, service, cache)
  }

  internal abstract fun createDispatcher(context: Context, service: ExecutorService, cache: PlatformLruCache): Dispatcher

  private fun noopAction(data: Request, onComplete: () -> Unit = { }): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = onComplete()
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = this
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context

  @Mock internal lateinit var dispatcher: Dispatcher

  @Mock internal lateinit var requestHandler: RequestHandler

  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyNoInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsTargetsToActions() {
    picasso.targetToAction[mockImageViewTarget()] = mock(ImageViewAction::class.java)
    picasso.shutdown()
    assertThat(picasso.targetToAction).isEmpty()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Canvas
import android.os.Bundle
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells.Adaptive
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.BasicText
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import com.squareup.picasso3.compose.rememberPainter
import com.squareup.picasso3.layoutlib.LayoutlibExecutorService

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      Content(urls)
    }

    setContentView(composeView)
  }
}

@Composable
fun Content(urls: List<String>, picasso: Picasso = PicassoInitializer.get()) {
  var contentScale by remember { mutableStateOf(ContentScale.Inside) }
  var alignment by remember { mutableStateOf(Alignment.Center) }

  Column {
    ImageGrid(
      modifier = Modifier.weight(1F),
      urls = urls,
      contentScale = contentScale,
      alignment = alignment,
      picasso = picasso
    )

    Options(
      modifier = Modifier
        .background(Color.DarkGray)
        .padding(vertical = 4.dp),
      onContentScaleSelected = { contentScale = it },
      onAlignmentSelected = { alignment = it }
    )
  }
}

@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  contentScale: ContentScale,
  alignment: Alignment,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    columns = Adaptive(150.dp),
    modifier = modifier
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = contentScale,
        alignment = alignment,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

@Composable
fun Options(
  modifier: Modifier = Modifier,
  onContentScaleSelected: (ContentScale) -> Unit,
  onAlignmentSelected: (Alignment) -> Unit
) {
  var contentScaleKey by remember { mutableStateOf("Inside") }
  var alignmentKey by remember { mutableStateOf("Center") }
  Column(modifier = modifier) {
    CONTENT_SCALES.entries.chunked(4).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = contentScaleKey == key,
            onClick = {
              contentScaleKey = key
              onContentScaleSelected(value)
            }
          )
        }
      }
    }

    Spacer(modifier = Modifier.height(8.dp))

    ALIGNMENTS.entries.chunked(3).forEach { entries ->
      Row(
        modifier = Modifier
          .padding(2.dp)
          .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
      ) {
        entries.forEach { (key, value) ->
          OptionText(
            modifier = Modifier.weight(1F),
            key = key,
            selected = alignmentKey == key,
            onClick = {
              alignmentKey = key
              onAlignmentSelected(value)
            }
          )
        }
      }
    }
  }
}

@Composable
private fun OptionText(modifier: Modifier, key: String, selected: Boolean, onClick: () -> Unit) {
  Box(modifier = modifier) {
    BasicText(
      text = key,
      modifier = Modifier
        .align(Alignment.Center)
        .clip(RoundedCornerShape(8.dp))
        .clickable(onClick = onClick)
        .background(if (selected) Color.Blue else Color.White)
        .padding(horizontal = 8.dp, vertical = 4.dp)
    )
  }
}

private val CONTENT_SCALES = mapOf(
  Pair("Crop", ContentScale.Crop),
  Pair("Fit", ContentScale.Fit),
  Pair("Inside", ContentScale.Inside),
  Pair("Fill Width", ContentScale.FillWidth),
  Pair("Fill Height", ContentScale.FillHeight),
  Pair("Fill Bounds", ContentScale.FillBounds),
  Pair("None", ContentScale.None)
)

private val ALIGNMENTS = mapOf(
  Pair("TopStart", Alignment.TopStart),
  Pair("TopCenter", Alignment.TopCenter),
  Pair("TopEnd", Alignment.TopEnd),
  Pair("CenterStart", Alignment.CenterStart),
  Pair("Center", Alignment.Center),
  Pair("CenterEnd", Alignment.CenterEnd),
  Pair("BottomStart", Alignment.BottomStart),
  Pair("BottomCenter", Alignment.BottomCenter),
  Pair("BottomEnd", Alignment.BottomEnd)
)

@Preview
@Composable
private fun ContentPreview() {
  val images = listOf(
    Color.Blue.toArgb() to IntSize(200, 100),
    Color.Red.toArgb() to IntSize(100, 200),
    Color.Green.toArgb() to IntSize(100, 100),
    Color.Yellow.toArgb() to IntSize(300, 100),
    Color.Black.toArgb() to IntSize(100, 300),
    Color.LightGray.toArgb() to IntSize(400, 100),
    Color.Cyan.toArgb() to IntSize(100, 100),
    Color.White.toArgb() to IntSize(100, 400)
  ).associateBy { (color) -> "https:

  val context = LocalContext.current
  Content(
    urls = images.keys.toList(),
    picasso = remember {
      Picasso.Builder(context)
        .callFactory { throw AssertionError() } 
        .executor(LayoutlibExecutorService()) 
        .addRequestHandler(
          object : RequestHandler() {
            override fun canHandleRequest(data: Request) = data.uri?.toString()?.run(images::containsKey) == true
            override fun load(picasso: Picasso, request: Request, callback: Callback) {
              val (color, size) = images[request.uri!!.toString()]!!
              val bitmap = Bitmap.createBitmap(size.width, size.height, Config.ARGB_8888).apply {
                Canvas(this).apply {
                  drawColor(color)
                }
              }

              callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
            }
          }
        )
        .build()
    }
  )
}

<code block>

package com.example.picasso.paparazzi

import android.graphics.BitmapFactory
import android.widget.ImageView
import android.widget.ImageView.ScaleType.CENTER
import app.cash.paparazzi.Paparazzi
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Request
import com.squareup.picasso3.RequestHandler
import com.squareup.picasso3.layoutlib.LayoutlibExecutorService
import org.junit.Rule
import org.junit.Test
import kotlinx.coroutines.Dispatchers

class PicassoPaparazziTest {
  @get:Rule val paparazzi = Paparazzi()

  @Test
  fun loadsUrlIntoImageView() {
    val picasso = Picasso.Builder(paparazzi.context)
      .callFactory { throw AssertionError() } 
      .executor(LayoutlibExecutorService())
      .dispatcher(Dispatchers.Main)
      .addRequestHandler(FakeRequestHandler())
      .build()

    paparazzi.snapshot(
      ImageView(paparazzi.context).apply {
        scaleType = CENTER
        picasso.load("fake:
          .resize(200, 200)
          .centerInside()
          .onlyScaleDown()
          .into(this)
      }
    )
  }

  class FakeRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return "fake" == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      val imagePath = request.uri!!.lastPathSegment!!
      callback.onSuccess(Result.Bitmap(loadBitmap(imagePath)!!, MEMORY))
    }

    private fun loadBitmap(imagePath: String): android.graphics.Bitmap? {
      val resourceAsStream = javaClass.classLoader!!.getResourceAsStream(imagePath)
      return BitmapFactory.decodeStream(resourceAsStream)
    }
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import okhttp3.Headers
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val headers: Headers? = builder.headers

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0
    var headers: Headers? = null

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    fun addHeader(
      name: String,
      value: String
    ) = apply {
      this.headers = (headers?.newBuilder() ?: Headers.Builder())
        .add(name, value)
        .build()
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    val requestHeaders = request.headers
    if (requestHeaders != null) {
      builder.headers(requestHeaders)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun customHeaders() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(
      picasso,
      key = URI_KEY_1,
      uri = URI_1,
      headers = mapOf(CUSTOM_HEADER_NAME to CUSTOM_HEADER_VALUE)
    )
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          with(requests.first.headers) {
            assertThat(names()).containsExactly(CUSTOM_HEADER_NAME)
            assertThat(values(CUSTOM_HEADER_NAME)).containsExactly(CUSTOM_HEADER_VALUE)
          }
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.NetworkPolicy.Companion.isOfflineOnly
import com.squareup.picasso3.NetworkPolicy.Companion.shouldReadFromDiskCache
import com.squareup.picasso3.NetworkPolicy.Companion.shouldWriteToDiskCache
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import okhttp3.CacheControl
import okhttp3.Call
import okhttp3.Response
import java.io.IOException

internal class NetworkRequestHandler(
  private val callFactory: Call.Factory
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri ?: return false
    val scheme = uri.scheme
    return SCHEME_HTTP.equals(scheme, ignoreCase = true) ||
      SCHEME_HTTPS.equals(scheme, ignoreCase = true)
  }

  override fun load(picasso: Picasso, request: Request, callback: Callback) {
    val callRequest = createRequest(request)
    callFactory
      .newCall(callRequest)
      .enqueue(object : okhttp3.Callback {
        override fun onResponse(call: Call, response: Response) {
          if (!response.isSuccessful) {
            callback.onError(ResponseException(response.code, request.networkPolicy))
            return
          }

          
          
          
          val loadedFrom = if (response.cacheResponse == null) NETWORK else DISK

          
          
          val body = response.body
          if (loadedFrom == DISK && body!!.contentLength() == 0L) {
            body.close()
            callback.onError(
              ContentLengthException("Received response with 0 content-length header.")
            )
            return
          }
          if (loadedFrom == NETWORK && body!!.contentLength() > 0) {
            picasso.downloadFinished(body.contentLength())
          }
          try {
            val bitmap = decodeStream(body!!.source(), request)
            callback.onSuccess(Result.Bitmap(bitmap, loadedFrom))
          } catch (e: IOException) {
            body!!.close()
            callback.onError(e)
          }
        }

        override fun onFailure(call: Call, e: IOException) {
          callback.onError(e)
        }
      })
  }

  override val retryCount: Int
    get() = 2

  override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean =
    info == null || info.isConnected

  override fun supportsReplay(): Boolean = true

  private fun createRequest(request: Request): okhttp3.Request {
    var cacheControl: CacheControl? = null
    val networkPolicy = request.networkPolicy
    if (networkPolicy != 0) {
      cacheControl = if (isOfflineOnly(networkPolicy)) {
        CacheControl.FORCE_CACHE
      } else {
        val builder = CacheControl.Builder()
        if (!shouldReadFromDiskCache(networkPolicy)) {
          builder.noCache()
        }
        if (!shouldWriteToDiskCache(networkPolicy)) {
          builder.noStore()
        }
        builder.build()
      }
    }

    val uri = checkNotNull(request.uri) { "request.uri == null" }
    val builder = okhttp3.Request.Builder().url(uri.toString())
    if (cacheControl != null) {
      builder.cacheControl(cacheControl)
    }
    return builder.build()
  }

  internal class ContentLengthException(message: String) : RuntimeException(message)
  internal class ResponseException(
    val code: Int,
    val networkPolicy: Int
  ) : RuntimeException("HTTP $code")

  private companion object {
    private const val SCHEME_HTTP = "http"
    private const val SCHEME_HTTPS = "https"
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          try {
            assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
            latch.countDown()
          } catch (e: InterruptedException) {
            throw AssertionError(e)
          }
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?): Unit = throw AssertionError()

        override fun onError(t: Throwable) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          assertTrue(closed.get())
          latch.countDown()
        }
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(
      picasso = picasso,
      request = action.request,
      callback = object : RequestHandler.Callback {
        override fun onSuccess(result: Result?) {
          assertThat(eventRecorder.downloadSize).isEqualTo(0)
          latch.countDown()
        }

        override fun onError(t: Throwable): Unit = throw AssertionError(t)
      }
    )
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NOOP_REQUEST_HANDLER
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context, NOOP_REQUEST_HANDLER)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(eventRecorder.decodedBitmap).isEqualTo(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    assertThat(eventRecorder.decodedBitmap).isNull()
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val picasso = mockPicasso(context, ContentStreamRequestHandler(context))
    val action = mockAction(picasso, CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val picasso = mockPicasso(context, MediaStoreRequestHandler(context))
    val action = mockAction(picasso, MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val picasso = mockPicasso(context, AssetRequestHandler(context))
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, "keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val handler = AssetRequestHandler(context)
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      listOf(handler), emptyList(), ARGB_8888, false, false
    )
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val picasso = mockPicasso(context)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(request, target)
  }

  @JvmStatic fun mockAction(request: Request, target: Any = mockTarget()): FakeAction =
    FakeAction(mockPicasso(), request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = mockPicasso(),
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(requestHandler)
  }

  @JvmStatic fun mockPicasso(requestHandler: RequestHandler): Picasso {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.getRequestHandlers()).thenReturn(listOf(requestHandler))
    return picasso
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyLong
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso).downloadFinished(10)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        verify(picasso, never()).downloadFinished(anyLong())
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso, never()).downloadFinished(anyLong())
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  @Mock lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    verify(picasso).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    verify(picasso, never()).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val action = mockAction(CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(ContentStreamRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val action = mockAction(MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(MediaStoreRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val action = mockAction(CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val action = mockAction(CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val action = mockAction(FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(
      mockPicasso(FileRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val action = mockAction(RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val action = mockAction(RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(mockPicasso(AssetRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val action = mockAction("keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(mockPicasso(FileRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val handler = AssetRequestHandler(context)
    val handlers = listOf(handler)
    val eventListeners = emptyList<EventListener>()
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      handlers, eventListeners, ARGB_8888, false, false
    )
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val action = mockAction(URI_KEY_1, URI_1)
    val picasso = mockPicasso()
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val action = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    urlBuilder.filter(ThumborUrlBuilder.format(WEBP))

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = statFs.blockCountLong
      val blockSize = statFs.blockSizeLong
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    val bitmap = if (isWebPFile) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizing() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
  }

  @Test fun createWithConfigAndNotInJustDecodeBounds() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR2) {
      urlBuilder.filter(ThumborUrlBuilder.format(WEBP))
    }

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [17], manifest = Config.NONE)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST).buildImage(IMAGE).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Config(sdk = [18])
  @Test fun simpleResizeOnJbMr2UsesWebP() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun purgeable(): RequestCreator {
    data.purgeable()
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.provider.Settings.System
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockCount.toLong()
      } else {
        statFs.blockCountLong
      }
      val blockSize = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockSize.toLong()
      } else {
        statFs.blockSizeLong
      }
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR1) {
        System.getInt(contentResolver, System.AIRPLANE_MODE_ON, 0) != 0
      } else {
        Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
      }
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val purgeable: Boolean = builder.purgeable

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (purgeable) {
        append(" purgeable")
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var purgeable = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      purgeable = request.purgeable
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    fun purgeable() = apply {
      purgeable = true
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null || data.purgeable) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        inInputShareable = data.purgeable
        inPurgeable = data.purgeable
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val isPurgeable = request.purgeable && VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    
    val bitmap = if (isWebPFile || isPurgeable) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.annotation.Config
import java.io.File

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [23]) 
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Config(sdk = [16]) 
  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("packageName", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizingOrPurgeable() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
    assertThat(resizeOptions.inPurgeable).isFalse()
    assertThat(resizeOptions.inInputShareable).isFalse()
  }

  @Test fun inPurgeableIfInPurgeable() {
    val request = Request.Builder(URI_1).purgeable().build()
    val options = createBitmapOptions(request)
    assertThat(options).isNotNull()
    assertThat(options!!.inPurgeable).isTrue()
    assertThat(options.inInputShareable).isTrue()
    assertThat(options.inJustDecodeBounds).isFalse()
  }

  @Test fun createWithConfigAndNotInJustDecodeBoundsOrInPurgeable() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
    assertThat(configOptions.inPurgeable).isFalse()
    assertThat(configOptions.inInputShareable).isFalse()
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    urlBuilder.filter(ThumborUrlBuilder.format(WEBP))

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .fitIn()
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = statFs.blockCountLong
      val blockSize = statFs.blockSizeLong
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    val bitmap = if (isWebPFile) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizing() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
  }

  @Test fun createWithConfigAndNotInJustDecodeBounds() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.Request
import com.squareup.picasso3.pollexor.PollexorRequestTransformer.Callback
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP


class PollexorRequestTransformer @JvmOverloads constructor(
  private val thumbor: Thumbor,
  private val alwaysTransform: Boolean = false,
  private val callback: Callback = NONE
) : RequestTransformer {
  constructor(thumbor: Thumbor, callback: Callback) : this(thumbor, false, callback)

  override fun transformRequest(request: Request): Request {
    if (request.resourceId != 0) {
      return request 
    }
    val uri = requireNotNull(request.uri) { "Null uri passed to ${javaClass.canonicalName}" }

    val scheme = uri.scheme
    if ("https" != scheme && "http" != scheme) {
      return request 
    }

    
    if (!request.hasSize() && !alwaysTransform) {
      return request
    }

    
    val newRequest = request.newBuilder()

    
    val urlBuilder = thumbor.buildImage(uri.toString())
    callback.configure(urlBuilder)

    
    if (request.hasSize()) {
      urlBuilder.resize(request.targetWidth, request.targetHeight)
      newRequest.clearResize()
    }

    
    if (request.centerInside) {
      urlBuilder.fitIn()
      newRequest.clearCenterInside()
    }

    
    if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR2) {
      urlBuilder.filter(ThumborUrlBuilder.format(WEBP))
    }

    
    newRequest.setUri(Uri.parse(urlBuilder.toUrl()))
    return newRequest.build()
  }

  fun interface Callback {
    fun configure(builder: ThumborUrlBuilder)
  }

  companion object {
    private val NONE = Callback { }
  }
}

<code block>

package com.squareup.picasso3.pollexor

import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Request.Builder
import com.squareup.pollexor.Thumbor
import com.squareup.pollexor.ThumborUrlBuilder
import com.squareup.pollexor.ThumborUrlBuilder.ImageFormat.WEBP
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [17], manifest = Config.NONE)
class PollexorRequestTransformerTest {
  private val transformer = PollexorRequestTransformer(Thumbor.create(HOST))
  private val secureTransformer = PollexorRequestTransformer(Thumbor.create(HOST, KEY))
  private val alwaysResizeTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), alwaysTransform = true
  )
  private val callbackTransformer = PollexorRequestTransformer(
    Thumbor.create(HOST), callback = { it.filter("custom") }
  )

  @Test fun resourceIdRequestsAreNotTransformed() {
    val input = Builder(12).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun resourceIdRequestsAreNotTransformedWhenAlwaysTransformIsTrue() {
    val input = Builder(12).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonHttpRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreNotTransformed() {
    val input = Builder(IMAGE_URI).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isSameInstanceAs(input)
  }

  @Test fun nonResizedRequestsAreTransformedWhenAlwaysTransformIsSet() {
    val input = Builder(IMAGE_URI).build()
    val output = alwaysResizeTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST).buildImage(IMAGE).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResize() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Config(sdk = [18])
  @Test fun simpleResizeOnJbMr2UsesWebP() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter(ThumborUrlBuilder.format(WEBP))
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterCrop() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerCrop().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerCrop).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInside() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = transformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun simpleResizeWithCenterInsideAndEncryption() {
    val input = Builder(IMAGE_URI).resize(50, 50).centerInside().build()
    val output = secureTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    assertThat(output.centerInside).isFalse()

    val expected = Thumbor.create(HOST, KEY).buildImage(IMAGE).resize(50, 50).fitIn().toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  @Test fun configureCallback() {
    val input = Builder(IMAGE_URI).resize(50, 50).build()
    val output = callbackTransformer.transformRequest(input)
    assertThat(output).isNotSameInstanceAs(input)
    assertThat(output.hasSize()).isFalse()
    val expected = Thumbor.create(HOST)
      .buildImage(IMAGE)
      .resize(50, 50)
      .filter("custom")
      .toUrl()
    assertThat(output.uri.toString()).isEqualTo(expected)
  }

  companion object {
    private const val HOST = "http:
    private const val KEY = "omgsecretpassword"
    private const val IMAGE = "http:
    private val IMAGE_URI = Uri.parse(IMAGE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun purgeable(): RequestCreator {
    data.purgeable()
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.ActivityManager
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.StatFs
import android.provider.Settings.Global
import android.provider.Settings.System
import android.util.Log
import androidx.core.content.ContextCompat
import okio.BufferedSource
import okio.ByteString
import okio.ByteString.Companion.encodeUtf8
import java.io.File
import java.io.FileNotFoundException
import kotlin.math.max
import kotlin.math.min

internal object Utils {
  const val THREAD_PREFIX = "Picasso-"
  const val THREAD_IDLE_NAME = THREAD_PREFIX + "Idle"
  private const val PICASSO_CACHE = "picasso-cache"
  private const val MIN_DISK_CACHE_SIZE = 5 * 1024 * 1024 
  private const val MAX_DISK_CACHE_SIZE = 50 * 1024 * 1024 
  const val THREAD_LEAK_CLEANING_MS = 1000

  
  val MAIN_THREAD_KEY_BUILDER = StringBuilder()

  
  const val OWNER_MAIN = "Main"
  const val OWNER_DISPATCHER = "Dispatcher"
  const val OWNER_HUNTER = "Hunter"
  const val VERB_CREATED = "created"
  const val VERB_CHANGED = "changed"
  const val VERB_IGNORED = "ignored"
  const val VERB_ENQUEUED = "enqueued"
  const val VERB_CANCELED = "canceled"
  const val VERB_RETRYING = "retrying"
  const val VERB_EXECUTING = "executing"
  const val VERB_DECODED = "decoded"
  const val VERB_TRANSFORMED = "transformed"
  const val VERB_JOINED = "joined"
  const val VERB_REMOVED = "removed"
  const val VERB_DELIVERED = "delivered"
  const val VERB_REPLAYING = "replaying"
  const val VERB_COMPLETED = "completed"
  const val VERB_ERRORED = "errored"
  const val VERB_PAUSED = "paused"
  const val VERB_RESUMED = "resumed"

  
  private val WEBP_FILE_HEADER_RIFF: ByteString = "RIFF".encodeUtf8()
  private val WEBP_FILE_HEADER_WEBP: ByteString = "WEBP".encodeUtf8()

  fun <T> checkNotNull(value: T?, message: String?): T {
    if (value == null) {
      throw NullPointerException(message)
    }
    return value
  }

  fun checkNotMain() {
    check(!isMain) { "Method call should not happen from the main thread." }
  }

  fun checkMain() {
    check(isMain) { "Method call should happen from the main thread." }
  }

  private val isMain: Boolean
    get() = Looper.getMainLooper().thread === Thread.currentThread()

  fun getLogIdsForHunter(hunter: BitmapHunter, prefix: String = ""): String {
    return buildString {
      append(prefix)
      val action = hunter.action
      if (action != null) {
        append(action.request.logId())
      }
      val actions = hunter.actions
      if (actions != null) {
        for (i in actions.indices) {
          if (i > 0 || action != null) append(", ")
          append(actions[i].request.logId())
        }
      }
    }
  }

  fun log(owner: String, verb: String, logId: String, extras: String? = "") {
    Log.d(TAG, String.format("%1$-11s %2$-12s %3\$s %4\$s", owner, verb, logId, extras ?: ""))
  }

  fun createDefaultCacheDir(context: Context): File {
    val cache = File(context.applicationContext.cacheDir, PICASSO_CACHE)
    if (!cache.exists()) {
      cache.mkdirs()
    }
    return cache
  }

  fun calculateDiskCacheSize(dir: File): Long {
    var size = MIN_DISK_CACHE_SIZE.toLong()

    try {
      val statFs = StatFs(dir.absolutePath)
      val blockCount = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockCount.toLong()
      } else {
        statFs.blockCountLong
      }
      val blockSize = if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR2) {
        statFs.blockSize.toLong()
      } else {
        statFs.blockSizeLong
      }
      val available = blockCount * blockSize
      
      size = available / 50
    } catch (ignored: IllegalArgumentException) {
    }

    
    return max(min(size, MAX_DISK_CACHE_SIZE.toLong()), MIN_DISK_CACHE_SIZE.toLong())
  }

  fun calculateMemoryCacheSize(context: Context): Int {
    val am = ContextCompat.getSystemService(context, ActivityManager::class.java)
    val largeHeap = context.applicationInfo.flags and ApplicationInfo.FLAG_LARGE_HEAP != 0
    val memoryClass = if (largeHeap) am!!.largeMemoryClass else am!!.memoryClass
    
    return (1024L * 1024L * memoryClass / 7).toInt()
  }

  fun isAirplaneModeOn(context: Context): Boolean {
    return try {
      val contentResolver = context.contentResolver
      if (VERSION.SDK_INT < VERSION_CODES.JELLY_BEAN_MR1) {
        System.getInt(contentResolver, System.AIRPLANE_MODE_ON, 0) != 0
      } else {
        Global.getInt(contentResolver, Global.AIRPLANE_MODE_ON, 0) != 0
      }
    } catch (e: NullPointerException) {
      
      
      false
    } catch (e: SecurityException) {
      
      false
    }
  }

  fun hasPermission(context: Context, permission: String): Boolean {
    return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
  }

  fun isWebPFile(source: BufferedSource): Boolean {
    return source.rangeEquals(0, WEBP_FILE_HEADER_RIFF) &&
      source.rangeEquals(8, WEBP_FILE_HEADER_WEBP)
  }

  fun getResourceId(resources: Resources, data: Request): Int {
    if (data.resourceId != 0 || data.uri == null) {
      return data.resourceId
    }

    val pkg = data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)

    val segments = data.uri.pathSegments
    return when (segments?.size ?: 0) {
      0 -> throw FileNotFoundException("No path segments: " + data.uri)
      1 -> {
        try {
          segments[0].toInt()
        } catch (e: NumberFormatException) {
          throw FileNotFoundException("Last path segment is not a resource ID: " + data.uri)
        }
      }
      2 -> {
        val type = segments[0]
        val name = segments[1]
        resources.getIdentifier(name, type, pkg)
      }
      else -> throw FileNotFoundException("More than two path segments: " + data.uri)
    }
  }

  fun getResources(
    context: Context,
    data: Request
  ): Resources {
    if (data.resourceId != 0 || data.uri == null) {
      return context.resources
    }

    return try {
      val pkg =
        data.uri.authority ?: throw FileNotFoundException("No package provided: " + data.uri)
      context.packageManager.getResourcesForApplication(pkg)
    } catch (e: NameNotFoundException) {
      throw FileNotFoundException("Unable to obtain resources for package: " + data.uri)
    }
  }

  
  fun flushStackLocalLeaks(looper: Looper) {
    val handler: Handler = object : Handler(looper) {
      override fun handleMessage(msg: Message) {
        sendMessageDelayed(obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
      }
    }
    handler.sendMessageDelayed(handler.obtainMessage(), THREAD_LEAK_CLEANING_MS.toLong())
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.annotation.DrawableRes
import androidx.annotation.Px
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.Priority.NORMAL
import java.util.ArrayList
import java.util.concurrent.TimeUnit.NANOSECONDS
import java.util.concurrent.TimeUnit.SECONDS


class Request internal constructor(builder: Builder) {
  
  @JvmField var id = 0

  
  @JvmField var started: Long = 0

  
  @JvmField val memoryPolicy: Int = builder.memoryPolicy

  
  @JvmField val networkPolicy: Int = builder.networkPolicy

  
  @JvmField val uri: Uri? = builder.uri

  
  @JvmField val resourceId: Int = builder.resourceId

  
  val stableKey: String? = builder.stableKey

  
  @JvmField var transformations: List<Transformation> =
    if (builder.transformations == null) {
      emptyList()
    } else {
      builder.transformations!!.toList()
    }

  
  @JvmField val targetWidth: Int = builder.targetWidth

  
  @JvmField val targetHeight: Int = builder.targetHeight

  
  @JvmField val centerCrop: Boolean = builder.centerCrop

  
  @JvmField val centerCropGravity: Int = builder.centerCropGravity

  
  @JvmField val centerInside: Boolean = builder.centerInside

  @JvmField val onlyScaleDown: Boolean = builder.onlyScaleDown

  
  @JvmField val rotationDegrees: Float = builder.rotationDegrees

  
  @JvmField val rotationPivotX: Float = builder.rotationPivotX

  
  @JvmField val rotationPivotY: Float = builder.rotationPivotY

  
  @JvmField val hasRotationPivot: Boolean = builder.hasRotationPivot

  
  @JvmField val purgeable: Boolean = builder.purgeable

  
  @JvmField val config: Config? = builder.config

  
  @JvmField val priority: Priority = checkNotNull(builder.priority)

  
  @JvmField var key: String =
    if (Looper.myLooper() == Looper.getMainLooper()) {
      createKey()
    } else {
      createKey(StringBuilder())
    }

  
  val tag: Any? = builder.tag

  override fun toString() =
    buildString {
      append("Request{")
      if (resourceId > 0) {
        append(resourceId)
      } else {
        append(uri)
      }
      for (transformation in transformations) {
        append(' ')
        append(transformation.key())
      }
      if (stableKey != null) {
        append(" stableKey(")
        append(stableKey)
        append(')')
      }
      if (targetWidth > 0) {
        append(" resize(")
        append(targetWidth)
        append(',')
        append(targetHeight)
        append(')')
      }
      if (centerCrop) {
        append(" centerCrop")
      }
      if (centerInside) {
        append(" centerInside")
      }
      if (rotationDegrees != 0f) {
        append(" rotation(")
        append(rotationDegrees)
        if (hasRotationPivot) {
          append(" @ ")
          append(rotationPivotX)
          append(',')
          append(rotationPivotY)
        }
        append(')')
      }
      if (purgeable) {
        append(" purgeable")
      }
      if (config != null) {
        append(' ')
        append(config)
      }
      append('}')
    }

  
  fun logId(): String {
    val delta = System.nanoTime() - started
    return if (delta > TOO_LONG_LOG) {
      "${plainId()}+${NANOSECONDS.toSeconds(delta)}s"
    } else {
      "${plainId()}+${NANOSECONDS.toMillis(delta)}ms"
    }
  }

  
  fun plainId() = "[R$id]"

  
  val name: String
    get() = uri?.path ?: Integer.toHexString(resourceId)

  
  fun hasSize(): Boolean = targetWidth != 0 || targetHeight != 0

  
  fun needsMatrixTransform(): Boolean = hasSize() || rotationDegrees != 0f

  fun newBuilder(): Builder = Builder(this)

  private fun createKey(): String {
    val result = createKey(Utils.MAIN_THREAD_KEY_BUILDER)
    Utils.MAIN_THREAD_KEY_BUILDER.setLength(0)
    return result
  }

  private fun createKey(builder: StringBuilder): String {
    val data = this
    if (data.stableKey != null) {
      builder.ensureCapacity(data.stableKey.length + KEY_PADDING)
      builder.append(data.stableKey)
    } else if (data.uri != null) {
      val path = data.uri.toString()
      builder.ensureCapacity(path.length + KEY_PADDING)
      builder.append(path)
    } else {
      builder.ensureCapacity(KEY_PADDING)
      builder.append(data.resourceId)
    }

    builder.append(KEY_SEPARATOR)

    if (data.rotationDegrees != 0f) {
      builder
        .append("rotation:")
        .append(data.rotationDegrees)

      if (data.hasRotationPivot) {
        builder
          .append('@')
          .append(data.rotationPivotX)
          .append('x')
          .append(data.rotationPivotY)
      }

      builder.append(KEY_SEPARATOR)
    }

    if (data.hasSize()) {
      builder
        .append("resize:")
        .append(data.targetWidth)
        .append('x')
        .append(data.targetHeight)

      builder.append(KEY_SEPARATOR)
    }

    if (data.centerCrop) {
      builder
        .append("centerCrop:")
        .append(data.centerCropGravity)
        .append(KEY_SEPARATOR)
    } else if (data.centerInside) {
      builder
        .append("centerInside")
        .append(KEY_SEPARATOR)
    }

    for (i in data.transformations.indices) {
      builder.append(data.transformations[i].key())
      builder.append(KEY_SEPARATOR)
    }

    return builder.toString()
  }

  
  class Builder {
    var uri: Uri? = null
    var resourceId = 0
    var stableKey: String? = null
    var targetWidth = 0
    var targetHeight = 0
    var centerCrop = false
    var centerCropGravity = 0
    var centerInside = false
    var onlyScaleDown = false
    var rotationDegrees = 0f
    var rotationPivotX = 0f
    var rotationPivotY = 0f
    var hasRotationPivot = false
    var purgeable = false
    var transformations: MutableList<Transformation>? = null
    var config: Config? = null
    var priority: Priority? = null
    
    var tag: Any? = null
    var memoryPolicy = 0
    var networkPolicy = 0

    
    constructor(uri: Uri) {
      setUri(uri)
    }

    
    constructor(@DrawableRes resourceId: Int) {
      setResourceId(resourceId)
    }

    internal constructor(
      uri: Uri?,
      resourceId: Int,
      bitmapConfig: Config?
    ) {
      this.uri = uri
      this.resourceId = resourceId
      config = bitmapConfig
    }

    internal constructor(request: Request) {
      uri = request.uri
      resourceId = request.resourceId
      stableKey = request.stableKey
      targetWidth = request.targetWidth
      targetHeight = request.targetHeight
      centerCrop = request.centerCrop
      centerInside = request.centerInside
      centerCropGravity = request.centerCropGravity
      rotationDegrees = request.rotationDegrees
      rotationPivotX = request.rotationPivotX
      rotationPivotY = request.rotationPivotY
      hasRotationPivot = request.hasRotationPivot
      purgeable = request.purgeable
      onlyScaleDown = request.onlyScaleDown
      transformations = request.transformations.toMutableList()
      config = request.config
      priority = request.priority
      memoryPolicy = request.memoryPolicy
      networkPolicy = request.networkPolicy
    }

    fun hasImage(): Boolean {
      return uri != null || resourceId != 0
    }

    fun hasSize(): Boolean {
      return targetWidth != 0 || targetHeight != 0
    }

    fun hasPriority(): Boolean {
      return priority != null
    }

    
    fun setUri(uri: Uri) = apply {
      this.uri = uri
      resourceId = 0
    }

    
    fun setResourceId(@DrawableRes resourceId: Int) = apply {
      require(resourceId != 0) { "Image resource ID may not be 0." }
      this.resourceId = resourceId
      uri = null
    }

    
    fun stableKey(stableKey: String?) = apply {
      this.stableKey = stableKey
    }

    
    fun tag(tag: Any) = apply {
      check(this.tag == null) { "Tag already set." }
      this.tag = tag
    }

    
    fun clearTag() = apply {
      tag = null
    }

    
    fun resize(@Px targetWidth: Int, @Px targetHeight: Int) = apply {
      require(targetWidth >= 0) { "Width must be positive number or 0." }
      require(targetHeight >= 0) { "Height must be positive number or 0." }
      require(
        !(targetHeight == 0 && targetWidth == 0)
      ) { "At least one dimension has to be positive number." }
      this.targetWidth = targetWidth
      this.targetHeight = targetHeight
    }

    
    fun clearResize() = apply {
      targetWidth = 0
      targetHeight = 0
      centerCrop = false
      centerInside = false
    }

    
    @JvmOverloads
    fun centerCrop(alignGravity: Int = Gravity.CENTER) = apply {
      check(!centerInside) { "Center crop can not be used after calling centerInside" }
      centerCrop = true
      centerCropGravity = alignGravity
    }

    
    fun clearCenterCrop() = apply {
      centerCrop = false
      centerCropGravity = Gravity.CENTER
    }

    
    fun centerInside() = apply {
      check(!centerCrop) { "Center inside can not be used after calling centerCrop" }
      centerInside = true
    }

    
    fun clearCenterInside() = apply {
      centerInside = false
    }

    
    fun onlyScaleDown() = apply {
      check(!(targetHeight == 0 && targetWidth == 0)) {
        "onlyScaleDown can not be applied without resize"
      }
      onlyScaleDown = true
    }

    
    fun clearOnlyScaleDown() = apply {
      onlyScaleDown = false
    }

    
    fun rotate(degrees: Float) = apply {
      rotationDegrees = degrees
    }

    
    fun rotate(
      degrees: Float,
      pivotX: Float,
      pivotY: Float
    ) = apply {
      rotationDegrees = degrees
      rotationPivotX = pivotX
      rotationPivotY = pivotY
      hasRotationPivot = true
    }

    
    fun clearRotation() = apply {
      rotationDegrees = 0f
      rotationPivotX = 0f
      rotationPivotY = 0f
      hasRotationPivot = false
    }

    fun purgeable() = apply {
      purgeable = true
    }

    
    fun config(config: Config) = apply {
      this.config = config
    }

    
    fun priority(priority: Priority) = apply {
      check(this.priority == null) { "Priority already set." }
      this.priority = priority
    }

    
    fun transform(transformation: Transformation) = apply {
      requireNotNull(transformation.key()) { "Transformation key must not be null." }
      if (transformations == null) {
        transformations = ArrayList(2)
      }
      transformations!!.add(transformation)
    }

    
    fun transform(transformations: List<Transformation>) = apply {
      for (i in transformations.indices) {
        transform(transformations[i])
      }
    }

    
    fun memoryPolicy(
      policy: MemoryPolicy,
      vararg additional: MemoryPolicy
    ) = apply {
      memoryPolicy = memoryPolicy or policy.index

      for (i in additional.indices) {
        this.memoryPolicy = this.memoryPolicy or additional[i].index
      }
    }

    
    fun networkPolicy(
      policy: NetworkPolicy,
      vararg additional: NetworkPolicy
    ) = apply {
      networkPolicy = networkPolicy or policy.index

      for (i in additional.indices) {
        this.networkPolicy = this.networkPolicy or additional[i].index
      }
    }

    
    fun build(): Request {
      check(!(centerInside && centerCrop)) {
        "Center crop and center inside can not be used together."
      }
      check(!(centerCrop && targetWidth == 0 && targetHeight == 0)) {
        "Center crop requires calling resize with positive width and height."
      }
      check(!(centerInside && targetWidth == 0 && targetHeight == 0)) {
        "Center inside requires calling resize with positive width and height."
      }
      if (priority == null) {
        priority = NORMAL
      }
      return Request(this)
    }
  }

  internal companion object {
    private val TOO_LONG_LOG = SECONDS.toNanos(5)
    private const val KEY_PADDING = 50 
    const val KEY_SEPARATOR = '\n'
  }
}

<code block>

package com.squareup.picasso3

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.ImageDecoder
import android.os.Build
import android.os.Build.VERSION
import android.util.TypedValue
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import okio.Buffer
import okio.BufferedSource
import okio.ForwardingSource
import okio.Source
import okio.buffer
import java.io.IOException
import java.nio.ByteBuffer
import kotlin.math.max
import kotlin.math.min

internal object BitmapUtils {
  
  fun createBitmapOptions(data: Request): BitmapFactory.Options? {
    val justBounds = data.hasSize()
    return if (justBounds || data.config != null || data.purgeable) {
      BitmapFactory.Options().apply {
        inJustDecodeBounds = justBounds
        inInputShareable = data.purgeable
        inPurgeable = data.purgeable
        if (data.config != null) {
          inPreferredConfig = data.config
        }
      }
    } else null
  }

  fun requiresInSampleSize(options: BitmapFactory.Options?): Boolean {
    return options != null && options.inJustDecodeBounds
  }

  fun calculateInSampleSize(
    reqWidth: Int,
    reqHeight: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    calculateInSampleSize(
      reqWidth, reqHeight, options.outWidth, options.outHeight, options, request
    )
  }

  fun shouldResize(
    onlyScaleDown: Boolean,
    inWidth: Int,
    inHeight: Int,
    targetWidth: Int,
    targetHeight: Int
  ): Boolean {
    return (
      !onlyScaleDown || targetWidth != 0 && inWidth > targetWidth ||
        targetHeight != 0 && inHeight > targetHeight
      )
  }

  fun calculateInSampleSize(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    options: BitmapFactory.Options,
    request: Request
  ) {
    options.inSampleSize = ratio(requestWidth, requestHeight, width, height, request)
    options.inJustDecodeBounds = false
  }

  
  fun decodeStream(source: Source, request: Request): Bitmap {
    val exceptionCatchingSource = ExceptionCatchingSource(source)
    val bufferedSource = exceptionCatchingSource.buffer()
    val bitmap =
      if (VERSION.SDK_INT >= 28)
        decodeStreamP(request, bufferedSource)
      else
        decodeStreamPreP(request, bufferedSource)
    exceptionCatchingSource.throwIfCaught()
    return bitmap
  }

  @RequiresApi(28)
  @SuppressLint("Override")
  private fun decodeStreamP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val imageSource = ImageDecoder.createSource(ByteBuffer.wrap(bufferedSource.readByteArray()))
    return decodeImageSource(imageSource, request)
  }

  private fun decodeStreamPreP(request: Request, bufferedSource: BufferedSource): Bitmap {
    val isWebPFile = Utils.isWebPFile(bufferedSource)
    val isPurgeable = request.purgeable && VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP
    val options = createBitmapOptions(request)
    val calculateSize = requiresInSampleSize(options)
    
    
    
    val bitmap = if (isWebPFile || isPurgeable) {
      val bytes = bufferedSource.readByteArray()
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeByteArray(bytes, 0, bytes.size, options)
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(bufferedSource.peek().inputStream(), null, options)
        calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
      }
      BitmapFactory.decodeStream(bufferedSource.inputStream(), null, options)
    }
    if (bitmap == null) {
      
      throw IOException("Failed to decode bitmap.")
    }
    return bitmap
  }

  fun decodeResource(context: Context, request: Request): Bitmap {
    if (VERSION.SDK_INT >= 28) {
      return decodeResourceP(context, request)
    }
    val resources = Utils.getResources(context, request)
    val id = Utils.getResourceId(resources, request)
    return decodeResourcePreP(resources, id, request)
  }

  @RequiresApi(28)
  private fun decodeResourceP(context: Context, request: Request): Bitmap {
    val imageSource = ImageDecoder.createSource(context.resources, request.resourceId)
    return decodeImageSource(imageSource, request)
  }

  private fun decodeResourcePreP(resources: Resources, id: Int, request: Request): Bitmap {
    val options = createBitmapOptions(request)
    if (requiresInSampleSize(options)) {
      BitmapFactory.decodeResource(resources, id, options)
      calculateInSampleSize(request.targetWidth, request.targetHeight, options!!, request)
    }
    return BitmapFactory.decodeResource(resources, id, options)
  }

  @RequiresApi(28)
  private fun decodeImageSource(imageSource: ImageDecoder.Source, request: Request): Bitmap {
    return ImageDecoder.decodeBitmap(imageSource) { imageDecoder, imageInfo, source ->
      imageDecoder.isMutableRequired = true
      if (request.hasSize()) {
        val size = imageInfo.size
        val width = size.width
        val height = size.height
        val targetWidth = request.targetWidth
        val targetHeight = request.targetHeight
        if (shouldResize(request.onlyScaleDown, width, height, targetWidth, targetHeight)) {
          val ratio = ratio(targetWidth, targetHeight, width, height, request)
          imageDecoder.setTargetSize(width / ratio, height / ratio)
        }
      }
    }
  }

  private fun ratio(
    requestWidth: Int,
    requestHeight: Int,
    width: Int,
    height: Int,
    request: Request
  ): Int =
    if (height > requestHeight || width > requestWidth) {
      val ratio = if (requestHeight == 0) {
        width / requestWidth
      } else if (requestWidth == 0) {
        height / requestHeight
      } else {
        val heightRatio = height / requestHeight
        val widthRatio = width / requestWidth
        if (request.centerInside)
          max(heightRatio, widthRatio)
        else
          min(heightRatio, widthRatio)
      }
      if (ratio != 0) ratio else 1
    } else {
      1
    }

  fun isXmlResource(resources: Resources, @DrawableRes drawableId: Int): Boolean {
    val typedValue = TypedValue()
    resources.getValue(drawableId, typedValue, true)
    val file = typedValue.string
    return file != null && file.toString().endsWith(".xml")
  }

  internal class ExceptionCatchingSource(delegate: Source) : ForwardingSource(delegate) {
    var thrownException: IOException? = null

    override fun read(sink: Buffer, byteCount: Long): Long {
      return try {
        super.read(sink, byteCount)
      } catch (e: IOException) {
        thrownException = e
        throw e
      }
    }

    fun throwIfCaught() {
      if (thrownException is IOException) {
        
        
        throw thrownException as IOException
      }
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.annotation.Config
import java.io.File

@RunWith(RobolectricTestRunner::class)
@Config(sdk = [23]) 
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Config(sdk = [16]) 
  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("packageName", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.RGB_565
import android.graphics.BitmapFactory
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapUtils.calculateInSampleSize
import com.squareup.picasso3.BitmapUtils.createBitmapOptions
import com.squareup.picasso3.BitmapUtils.requiresInSampleSize
import com.squareup.picasso3.TestUtils.URI_1
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapUtilsTest {

  @Test fun bitmapConfig() {
    for (config in Bitmap.Config.values()) {
      val data = Request.Builder(URI_1).config(config).build()
      val copy = data.newBuilder().build()

      assertThat(createBitmapOptions(data)!!.inPreferredConfig).isSameInstanceAs(config)
      assertThat(createBitmapOptions(copy)!!.inPreferredConfig).isSameInstanceAs(config)
    }
  }

  @Test fun requiresComputeInSampleSize() {
    assertThat(requiresInSampleSize(null)).isFalse()

    val defaultOptions = BitmapFactory.Options()
    assertThat(requiresInSampleSize(defaultOptions)).isFalse()

    val justBounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    assertThat(requiresInSampleSize(justBounds)).isTrue()
  }

  @Test fun calculateInSampleSizeNoResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 150, 150, options, data)
    assertThat(options.inSampleSize).isEqualTo(1)
  }

  @Test fun calculateInSampleSizeResize() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).build()
    calculateInSampleSize(100, 100, 200, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeResizeCenterInside() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).centerInside().resize(100, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 400, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(4)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithWidth() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(400, 0).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun calculateInSampleSizeKeepAspectRatioWithHeight() {
    val options = BitmapFactory.Options()
    val data = Request.Builder(URI_1).resize(0, 100).build()
    calculateInSampleSize(data.targetWidth, data.targetHeight, 800, 200, options, data)
    assertThat(options.inSampleSize).isEqualTo(2)
  }

  @Test fun nullBitmapOptionsIfNoResizingOrPurgeable() {
    
    val noResize = Request.Builder(URI_1).build()
    val noResizeOptions = createBitmapOptions(noResize)
    assertThat(noResizeOptions).isNull()
  }

  @Test fun inJustDecodeBoundsIfResizing() {
    
    val requiresResize = Request.Builder(URI_1).resize(20, 15).build()
    val resizeOptions = createBitmapOptions(requiresResize)
    assertThat(resizeOptions).isNotNull()
    assertThat(resizeOptions!!.inJustDecodeBounds).isTrue()
    assertThat(resizeOptions.inPurgeable).isFalse()
    assertThat(resizeOptions.inInputShareable).isFalse()
  }

  @Test fun inPurgeableIfInPurgeable() {
    val request = Request.Builder(URI_1).purgeable().build()
    val options = createBitmapOptions(request)
    assertThat(options).isNotNull()
    assertThat(options!!.inPurgeable).isTrue()
    assertThat(options.inInputShareable).isTrue()
    assertThat(options.inJustDecodeBounds).isFalse()
  }

  @Test fun createWithConfigAndNotInJustDecodeBoundsOrInPurgeable() {
    
    val config = Request.Builder(URI_1).config(RGB_565).build()
    val configOptions = createBitmapOptions(config)
    assertThat(configOptions).isNotNull()
    assertThat(configOptions!!.inJustDecodeBounds).isFalse()
    assertThat(configOptions.inPurgeable).isFalse()
    assertThat(configOptions.inInputShareable).isFalse()
  }
}

<code block>

package com.squareup.picasso3.compose

import android.graphics.drawable.Drawable
import androidx.compose.runtime.Composable
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.DefaultAlpha
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.painter.Painter
import com.google.accompanist.drawablepainter.DrawablePainter
import com.squareup.picasso3.DrawableTarget
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestCreator

@Composable
fun Picasso.rememberPainter(
  key: Any? = null,
  onError: ((Exception) -> Unit)? = null,
  request: (Picasso) -> RequestCreator,
): Painter {
  return remember(key) { PicassoPainter(this, request, onError) }
}

internal class PicassoPainter(
  private val picasso: Picasso,
  private val request: (Picasso) -> RequestCreator,
  private val onError: ((Exception) -> Unit)? = null
) : Painter(), RememberObserver, DrawableTarget {

  private var painter: Painter by mutableStateOf(EmptyPainter)
  private var alpha: Float by mutableStateOf(DefaultAlpha)
  private var colorFilter: ColorFilter? by mutableStateOf(null)

  override val intrinsicSize: Size
    get() = painter.intrinsicSize

  override fun applyAlpha(alpha: Float): Boolean {
    this.alpha = alpha
    return true
  }

  override fun applyColorFilter(colorFilter: ColorFilter?): Boolean {
    this.colorFilter = colorFilter
    return true
  }

  override fun DrawScope.onDraw() {
    with(painter) {
      draw(size, alpha, colorFilter)
    }
  }

  override fun onRemembered() {
    request.invoke(picasso).into(this)
  }

  override fun onAbandoned() {
    (painter as? RememberObserver)?.onAbandoned()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onForgotten() {
    (painter as? RememberObserver)?.onForgotten()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onPrepareLoad(placeHolderDrawable: Drawable?) {
    placeHolderDrawable?.let(::setPainter)
  }

  override fun onDrawableLoaded(drawable: Drawable, from: LoadedFrom) {
    setPainter(drawable)
  }

  override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) {
    onError?.invoke(e)
    errorDrawable?.let(::setPainter)
  }

  private fun setPainter(drawable: Drawable) {
    (painter as? RememberObserver)?.onForgotten()
    painter = DrawablePainter(drawable).apply(DrawablePainter::onRemembered)
  }
}

private object EmptyPainter : Painter() {
  override val intrinsicSize = Size.Zero
  override fun DrawScope.onDraw() = Unit
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom


interface DrawableTarget {
  
  fun onDrawableLoaded(
    drawable: Drawable,
    from: LoadedFrom
  )

  
  fun onDrawableFailed(
    e: Exception,
    errorDrawable: Drawable?
  )

  
  fun onPrepareLoad(placeHolderDrawable: Drawable?)
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  fun into(target: DrawableTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    val placeHolderDrawable = if (setPlaceholder) getPlaceholderDrawable() else null
    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(placeHolderDrawable)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onDrawableLoaded(
          PicassoDrawable(
            context = picasso.context,
            bitmap = bitmap,
            placeholder = null,
            loadedFrom = LoadedFrom.MEMORY,
            noFade = noFade,
            debugging = picasso.indicatorsEnabled
          ),
          LoadedFrom.MEMORY
        )
        return
      }
    }

    target.onPrepareLoad(placeHolderDrawable)
    val action = DrawableTargetAction(picasso, target, request, noFade, placeHolderDrawable, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class DrawableTargetAction(
  picasso: Picasso,
  private val target: DrawableTarget,
  data: Request,
  private val noFade: Boolean,
  private val placeholderDrawable: Drawable?,
  private val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onDrawableLoaded(
        PicassoDrawable(
          context = picasso.context,
          bitmap = bitmap,
          placeholder = placeholderDrawable,
          loadedFrom = result.loadedFrom,
          noFade = noFade,
          debugging = picasso.indicatorsEnabled
        ),
        result.loadedFrom
      )
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onDrawableFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.mockito.Mockito.mock
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DrawableTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockDrawableTarget()
    val drawableCaptor = argumentCaptor<PicassoDrawable>()
    val placeholder = mock(Drawable::class.java)
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = false,
      placeholderDrawable = placeholder,
      errorDrawable = null,
      errorResId = 0
    )

    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))

    Mockito.verify(target).onDrawableLoaded(drawableCaptor.capture(), eq(NETWORK))
    with(drawableCaptor.value) {
      assertThat(this.bitmap).isEqualTo(bitmap)
      assertThat(this.placeholder).isEqualTo(placeholder)
      assertThat(this.animating).isTrue()
    }
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher,
      TestUtils.UNUSED_CALL_FACTORY, null, cache, null,
      TestUtils.NO_TRANSFORMERS,
      TestUtils.NO_HANDLERS,
      TestUtils.NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)

    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = TestUtils.RESOURCE_ID_1
    )

    Mockito.`when`(context.getDrawable(TestUtils.RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = TestUtils.mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = object : DrawableTarget {
        override fun onDrawableLoaded(drawable: Drawable, from: Picasso.LoadedFrom) = (drawable as PicassoDrawable).bitmap.recycle()
        override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = 0
    )

    try {
      action.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      Assert.fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockBitmapTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoDrawableTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockDrawableTarget())
      fail("Calling into() drawable target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoDrawableTargetNoPlaceholderCallsWithNull() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoDrawableTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoDrawableTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onDrawableLoaded(any(PicassoDrawable::class.java), eq(MEMORY))
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoDrawableTargetWithSkipMemoryPolicy() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoDrawableTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(DrawableTargetAction::class.java)
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockBitmapTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockBitmapTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockBitmapTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockBitmapTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockBitmapTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockBitmapTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockDrawableTarget(): DrawableTarget = mock(DrawableTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.os.Bundle
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.lazy.GridCells.Adaptive
import androidx.compose.foundation.lazy.LazyVerticalGrid
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.ContentScale.Companion.Crop
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.compose.rememberPainter

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      ImageGrid(urls = urls)
    }

    setContentView(composeView)
  }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    cells = Adaptive(150.dp),
    modifier = modifier,
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = Crop,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    COMPOSE_UI("Compose UI", SampleComposeActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3.compose

import android.graphics.drawable.Drawable
import androidx.compose.runtime.Composable
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.DefaultAlpha
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.painter.Painter
import com.google.accompanist.drawablepainter.DrawablePainter
import com.squareup.picasso3.DrawableTarget
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.RequestCreator

@Composable
fun Picasso.rememberPainter(
  key: Any? = null,
  onError: ((Exception) -> Unit)? = null,
  request: (Picasso) -> RequestCreator,
): Painter {
  return remember(key) { PicassoPainter(this, request, onError) }
}

internal class PicassoPainter(
  private val picasso: Picasso,
  private val request: (Picasso) -> RequestCreator,
  private val onError: ((Exception) -> Unit)? = null
) : Painter(), RememberObserver, DrawableTarget {

  private var painter: Painter by mutableStateOf(EmptyPainter)
  private var alpha: Float by mutableStateOf(DefaultAlpha)
  private var colorFilter: ColorFilter? by mutableStateOf(null)

  override val intrinsicSize: Size
    get() = painter.intrinsicSize

  override fun applyAlpha(alpha: Float): Boolean {
    this.alpha = alpha
    return true
  }

  override fun applyColorFilter(colorFilter: ColorFilter?): Boolean {
    this.colorFilter = colorFilter
    return true
  }

  override fun DrawScope.onDraw() {
    with(painter) {
      draw(size, alpha, colorFilter)
    }
  }

  override fun onRemembered() {
    request.invoke(picasso).into(this)
  }

  override fun onAbandoned() {
    (painter as? RememberObserver)?.onAbandoned()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onForgotten() {
    (painter as? RememberObserver)?.onForgotten()
    painter = EmptyPainter
    picasso.cancelRequest(this)
  }

  override fun onPrepareLoad(placeHolderDrawable: Drawable?) {
    placeHolderDrawable?.let(::setPainter)
  }

  override fun onDrawableLoaded(drawable: Drawable, from: LoadedFrom) {
    setPainter(drawable)
  }

  override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) {
    onError?.invoke(e)
    errorDrawable?.let(::setPainter)
  }

  private fun setPainter(drawable: Drawable) {
    (painter as? RememberObserver)?.onForgotten()
    painter = DrawablePainter(drawable).apply(DrawablePainter::onRemembered)
  }
}

private object EmptyPainter : Painter() {
  override val intrinsicSize = Size.Zero
  override fun DrawScope.onDraw() = Unit
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom


interface DrawableTarget {
  
  fun onDrawableLoaded(
    drawable: Drawable,
    from: LoadedFrom
  )

  
  fun onDrawableFailed(
    e: Exception,
    errorDrawable: Drawable?
  )

  
  fun onPrepareLoad(placeHolderDrawable: Drawable?)
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  fun into(target: DrawableTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    val placeHolderDrawable = if (setPlaceholder) getPlaceholderDrawable() else null
    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(placeHolderDrawable)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onDrawableLoaded(
          PicassoDrawable(
            context = picasso.context,
            bitmap = bitmap,
            placeholder = null,
            loadedFrom = LoadedFrom.MEMORY,
            noFade = noFade,
            debugging = picasso.indicatorsEnabled
          ),
          LoadedFrom.MEMORY
        )
        return
      }
    }

    target.onPrepareLoad(placeHolderDrawable)
    val action = DrawableTargetAction(picasso, target, request, noFade, placeHolderDrawable, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class DrawableTargetAction(
  picasso: Picasso,
  private val target: DrawableTarget,
  data: Request,
  private val noFade: Boolean,
  private val placeholderDrawable: Drawable?,
  private val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onDrawableLoaded(
        PicassoDrawable(
          context = picasso.context,
          bitmap = bitmap,
          placeholder = placeholderDrawable,
          loadedFrom = result.loadedFrom,
          noFade = noFade,
          debugging = picasso.indicatorsEnabled
        ),
        result.loadedFrom
      )
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onDrawableFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(target: DrawableTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockBitmapTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockBitmapTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.mockito.Mockito.mock
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DrawableTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockDrawableTarget()
    val drawableCaptor = argumentCaptor<PicassoDrawable>()
    val placeholder = mock(Drawable::class.java)
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = false,
      placeholderDrawable = placeholder,
      errorDrawable = null,
      errorResId = 0
    )

    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))

    Mockito.verify(target).onDrawableLoaded(drawableCaptor.capture(), eq(NETWORK))
    with(drawableCaptor.value) {
      assertThat(this.bitmap).isEqualTo(bitmap)
      assertThat(this.placeholder).isEqualTo(placeholder)
      assertThat(this.animating).isTrue()
    }
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = TestUtils.mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher,
      TestUtils.UNUSED_CALL_FACTORY, null, cache, null,
      TestUtils.NO_TRANSFORMERS,
      TestUtils.NO_HANDLERS,
      TestUtils.NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)

    val target = mockDrawableTarget()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = target,
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = TestUtils.RESOURCE_ID_1
    )

    Mockito.`when`(context.getDrawable(TestUtils.RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    action.error(e)

    Mockito.verify(target).onDrawableFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = TestUtils.mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val action = DrawableTargetAction(
      picasso = picasso,
      target = object : DrawableTarget {
        override fun onDrawableLoaded(drawable: Drawable, from: Picasso.LoadedFrom) = (drawable as PicassoDrawable).bitmap.recycle()
        override fun onDrawableFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = TestUtils.SIMPLE_REQUEST,
      noFade = true,
      placeholderDrawable = null,
      errorDrawable = null,
      errorResId = 0
    )

    try {
      action.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      Assert.fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockBitmapTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockBitmapTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockBitmapTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockBitmapTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoDrawableTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockDrawableTarget())
      fail("Calling into() drawable target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoDrawableTargetNoPlaceholderCallsWithNull() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoDrawableTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoDrawableTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onDrawableLoaded(any(PicassoDrawable::class.java), eq(MEMORY))
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoDrawableTargetWithSkipMemoryPolicy() {
    val target = mockDrawableTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoDrawableTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockDrawableTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(DrawableTargetAction::class.java)
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockBitmapTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockBitmapTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockBitmapTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockBitmapTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockBitmapTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockBitmapTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockDrawableTarget(): DrawableTarget = mock(DrawableTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockBitmapTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockBitmapTarget
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockDrawableTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithBitmapTarget() {
    val target = mockBitmapTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDrawableTarget() {
    val target = mockDrawableTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.os.Bundle
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.lazy.GridCells.Adaptive
import androidx.compose.foundation.lazy.LazyVerticalGrid
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.ContentScale.Companion.Crop
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.unit.dp
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.compose.rememberPainter

class SampleComposeActivity : PicassoSampleActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val composeView = ComposeView(this)

    val urls = Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled() +
      Data.URLS.toMutableList().shuffled()

    composeView.setContent {
      ImageGrid(urls = urls)
    }

    setContentView(composeView)
  }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ImageGrid(
  modifier: Modifier = Modifier,
  urls: List<String>,
  picasso: Picasso = PicassoInitializer.get()
) {
  LazyVerticalGrid(
    cells = Adaptive(150.dp),
    modifier = modifier,
  ) {
    items(urls.size) {
      val url = urls[it]
      Image(
        painter = picasso.rememberPainter(key = url) {
          it.load(url).placeholder(R.drawable.placeholder).error(R.drawable.error)
        },
        contentDescription = null,
        contentScale = Crop,
        modifier = Modifier
          .fillMaxWidth()
          .aspectRatio(1f)
      )
    }
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    COMPOSE_UI("Compose UI", SampleComposeActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config
import android.graphics.Color
import android.net.Uri
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.lifecycle.Lifecycle.Event.ON_DESTROY
import androidx.lifecycle.Lifecycle.Event.ON_START
import androidx.lifecycle.Lifecycle.Event.ON_STOP
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent
import com.squareup.picasso3.Dispatcher.Companion.HUNTER_COMPLETE
import com.squareup.picasso3.Dispatcher.Companion.REQUEST_BATCH_RESUME
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.VERB_ERRORED
import com.squareup.picasso3.Utils.VERB_RESUMED
import com.squareup.picasso3.Utils.calculateDiskCacheSize
import com.squareup.picasso3.Utils.calculateMemoryCacheSize
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.createDefaultCacheDir
import com.squareup.picasso3.Utils.log
import okhttp3.Cache
import okhttp3.Call
import okhttp3.OkHttpClient
import java.io.File
import java.io.IOException
import java.util.concurrent.ExecutorService


@OptIn(ExperimentalStdlibApi::class)
class Picasso internal constructor(
  @get:JvmName("-context") internal val context: Context,
  @get:JvmName("-dispatcher") internal val dispatcher: Dispatcher,
  @get:JvmName("-callFactory") internal val callFactory: Call.Factory,
  private val closeableCache: Cache?,
  @get:JvmName("-cache") internal val cache: PlatformLruCache,
  @get:JvmName("-listener") internal val listener: Listener?,
  requestTransformers: List<RequestTransformer>,
  extraRequestHandlers: List<RequestHandler>,
  eventListeners: List<EventListener>,
  @get:JvmName("-defaultBitmapConfig") internal val defaultBitmapConfig: Config?,
  
  var indicatorsEnabled: Boolean,
  
  @Volatile var isLoggingEnabled: Boolean
) : LifecycleObserver {
  @get:JvmName("-requestTransformers")
  internal val requestTransformers: List<RequestTransformer> = requestTransformers.toList()

  @get:JvmName("-requestHandlers")
  internal val requestHandlers: List<RequestHandler>

  @get:JvmName("-eventListeners")
  internal val eventListeners: List<EventListener> = eventListeners.toList()

  @get:JvmName("-targetToAction")
  internal val targetToAction = mutableMapOf<Any, Action>()

  @get:JvmName("-targetToDeferredRequestCreator")
  internal val targetToDeferredRequestCreator = mutableMapOf<ImageView, DeferredRequestCreator>()

  @get:JvmName("-shutdown")
  @set:JvmName("-shutdown")
  internal var shutdown = false

  init {
    
    val builtInHandlers = 8

    requestHandlers = buildList(builtInHandlers + extraRequestHandlers.size) {
      
      
      
      add(ResourceDrawableRequestHandler.create(context))
      add(ResourceRequestHandler(context))
      addAll(extraRequestHandlers)
      add(ContactsPhotoRequestHandler(context))
      add(MediaStoreRequestHandler(context))
      add(ContentStreamRequestHandler(context))
      add(AssetRequestHandler(context))
      add(FileRequestHandler(context))
      add(NetworkRequestHandler(callFactory))
    }
  }

  @OnLifecycleEvent(ON_DESTROY)
  @JvmName("-cancelAll")
  internal fun cancelAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      cancelExistingRequest(actions[i].getTarget())
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      deferredRequestCreators[i].cancel()
    }
  }

  
  fun cancelRequest(view: ImageView) {
    
    cancelExistingRequest(view)
  }

  
  fun cancelRequest(target: BitmapTarget) {
    
    cancelExistingRequest(target)
  }

  
  fun cancelRequest(remoteViews: RemoteViews, @IdRes viewId: Int) {
    
    cancelExistingRequest(RemoteViewsTarget(remoteViews, viewId))
  }

  
  fun cancelTag(tag: Any) {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      val action = actions[i]
      if (tag == action.tag) {
        cancelExistingRequest(action.getTarget())
      }
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val deferredRequestCreator = deferredRequestCreators[i]
      if (tag == deferredRequestCreator.tag) {
        deferredRequestCreator.cancel()
      }
    }
  }

  @OnLifecycleEvent(ON_STOP)
  @JvmName("-pauseAll")
  internal fun pauseAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchPauseTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchPauseTag(tag)
      }
    }
  }

  
  fun pauseTag(tag: Any) {
    dispatcher.dispatchPauseTag(tag)
  }

  @OnLifecycleEvent(ON_START)
  @JvmName("-resumeAll")
  internal fun resumeAll() {
    checkMain()

    val actions = targetToAction.values.toList()
    for (i in actions.indices) {
      dispatcher.dispatchResumeTag(actions[i].tag)
    }

    val deferredRequestCreators = targetToDeferredRequestCreator.values.toList()
    for (i in deferredRequestCreators.indices) {
      val tag = deferredRequestCreators[i].tag
      if (tag != null) {
        dispatcher.dispatchResumeTag(tag)
      }
    }
  }

  
  fun resumeTag(tag: Any) {
    dispatcher.dispatchResumeTag(tag)
  }

  
  fun load(uri: Uri?): RequestCreator {
    return RequestCreator(this, uri, 0)
  }

  
  fun load(path: String?): RequestCreator {
    if (path == null) {
      return RequestCreator(this, null, 0)
    }
    require(path.isNotBlank()) { "Path must not be empty." }
    return load(Uri.parse(path))
  }

  
  fun load(file: File?): RequestCreator {
    return if (file == null) {
      RequestCreator(this, null, 0)
    } else {
      load(Uri.fromFile(file))
    }
  }

  
  fun load(@DrawableRes resourceId: Int): RequestCreator {
    require(resourceId != 0) { "Resource ID must not be zero." }
    return RequestCreator(this, null, resourceId)
  }

  
  fun evictAll() {
    cache.clear()
  }

  
  fun invalidate(uri: Uri?) {
    if (uri != null) {
      cache.clearKeyUri(uri.toString())
    }
  }

  
  fun invalidate(path: String?) {
    if (path != null) {
      invalidate(Uri.parse(path))
    }
  }

  
  fun invalidate(file: File) {
    invalidate(Uri.fromFile(file))
  }

  
  fun shutdown() {
    if (shutdown) {
      return
    }
    cache.clear()

    close()

    dispatcher.shutdown()
    try {
      closeableCache?.close()
    } catch (ignored: IOException) {
    }
    for (deferredRequestCreator in targetToDeferredRequestCreator.values) {
      deferredRequestCreator.cancel()
    }
    targetToDeferredRequestCreator.clear()
    shutdown = true
  }

  @JvmName("-transformRequest")
  internal fun transformRequest(request: Request): Request {
    var nextRequest = request
    for (i in requestTransformers.indices) {
      val transformer = requestTransformers[i]
      nextRequest = transformer.transformRequest(nextRequest)
    }
    return nextRequest
  }

  @JvmName("-defer")
  internal fun defer(view: ImageView, request: DeferredRequestCreator) {
    
    if (targetToDeferredRequestCreator.containsKey(view)) {
      cancelExistingRequest(view)
    }
    targetToDeferredRequestCreator[view] = request
  }

  @JvmName("-enqueueAndSubmit")
  internal fun enqueueAndSubmit(action: Action) {
    val target = action.getTarget()
    if (targetToAction[target] !== action) {
      
      cancelExistingRequest(target)
      targetToAction[target] = action
    }
    submit(action)
  }

  @JvmName("-submit")
  internal fun submit(action: Action) {
    dispatcher.dispatchSubmit(action)
  }

  @JvmName("-quickMemoryCacheCheck")
  internal fun quickMemoryCacheCheck(key: String): Bitmap? {
    val cached = cache[key]
    if (cached != null) {
      cacheHit()
    } else {
      cacheMiss()
    }
    return cached
  }

  @JvmName("-complete")
  internal fun complete(hunter: BitmapHunter) {
    val single = hunter.action
    val joined = hunter.actions

    val hasMultiple = !joined.isNullOrEmpty()
    val shouldDeliver = single != null || hasMultiple

    if (!shouldDeliver) {
      return
    }

    val exception = hunter.exception
    val result = hunter.result

    single?.let { deliverAction(result, it, exception) }

    if (joined != null) {
      for (i in joined.indices) {
        deliverAction(result, joined[i], exception)
      }
    }

    if (listener != null && exception != null) {
      listener.onImageLoadFailed(this, hunter.data.uri, exception)
    }
  }

  @JvmName("-resumeAction")
  internal fun resumeAction(action: Action) {
    val bitmap = if (shouldReadFromMemoryCache(action.request.memoryPolicy)) {
      quickMemoryCacheCheck(action.request.key)
    } else null

    if (bitmap != null) {
      
      deliverAction(Result.Bitmap(bitmap, MEMORY), action, null)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from $MEMORY"
        )
      }
    } else {
      
      enqueueAndSubmit(action)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_RESUMED,
          logId = action.request.logId()
        )
      }
    }
  }

  private fun deliverAction(result: Result?, action: Action, e: Exception?) {
    if (action.cancelled) {
      return
    }
    if (!action.willReplay) {
      targetToAction.remove(action.getTarget())
    }
    if (result != null) {
      action.complete(result)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_COMPLETED,
          logId = action.request.logId(),
          extras = "from ${result.loadedFrom}"
        )
      }
    } else if (e != null) {
      action.error(e)
      if (isLoggingEnabled) {
        log(
          owner = OWNER_MAIN,
          verb = VERB_ERRORED,
          logId = action.request.logId(),
          extras = e.message
        )
      }
    }
  }

  private fun cancelExistingRequest(target: Any) {
    checkMain()
    val action = targetToAction.remove(target)
    if (action != null) {
      action.cancel()
      dispatcher.dispatchCancel(action)
    }
    if (target is ImageView) {
      val deferredRequestCreator = targetToDeferredRequestCreator.remove(target)
      deferredRequestCreator?.cancel()
    }
  }

  fun newBuilder(): Builder = Builder(this)

  
  class Builder {
    private val context: Context
    private var callFactory: Call.Factory? = null
    private var service: ExecutorService? = null
    private var cache: PlatformLruCache? = null
    private var listener: Listener? = null
    private val requestTransformers = mutableListOf<RequestTransformer>()
    private val requestHandlers = mutableListOf<RequestHandler>()
    private val eventListeners = mutableListOf<EventListener>()
    private var defaultBitmapConfig: Config? = null
    private var indicatorsEnabled = false
    private var loggingEnabled = false

    
    constructor(context: Context) {
      this.context = context.applicationContext
    }

    internal constructor(picasso: Picasso) {
      context = picasso.context
      callFactory = picasso.callFactory
      service = picasso.dispatcher.service
      cache = picasso.cache
      listener = picasso.listener
      requestTransformers += picasso.requestTransformers
      
      val numRequestHandlers = picasso.requestHandlers.size
      requestHandlers += picasso.requestHandlers.subList(2, numRequestHandlers - 6)
      eventListeners += picasso.eventListeners

      defaultBitmapConfig = picasso.defaultBitmapConfig
      indicatorsEnabled = picasso.indicatorsEnabled
      loggingEnabled = picasso.isLoggingEnabled
    }

    
    fun defaultBitmapConfig(bitmapConfig: Config) = apply {
      defaultBitmapConfig = bitmapConfig
    }

    
    fun client(client: OkHttpClient) = apply {
      callFactory = client
    }

    
    fun callFactory(factory: Call.Factory) = apply {
      callFactory = factory
    }

    
    fun executor(executorService: ExecutorService) = apply {
      service = executorService
    }

    
    fun withCacheSize(maxByteCount: Int) = apply {
      require(maxByteCount >= 0) { "maxByteCount < 0: $maxByteCount" }
      cache = PlatformLruCache(maxByteCount)
    }

    
    fun listener(listener: Listener) = apply {
      this.listener = listener
    }

    
    fun addRequestTransformer(transformer: RequestTransformer) = apply {
      requestTransformers += transformer
    }

    
    fun addRequestHandler(requestHandler: RequestHandler) = apply {
      requestHandlers += requestHandler
    }

    
    fun addEventListener(eventListener: EventListener) = apply {
      eventListeners += eventListener
    }

    
    fun indicatorsEnabled(enabled: Boolean) = apply {
      indicatorsEnabled = enabled
    }

    
    fun loggingEnabled(enabled: Boolean) = apply {
      loggingEnabled = enabled
    }

    
    fun build(): Picasso {
      var unsharedCache: okhttp3.Cache? = null
      if (callFactory == null) {
        val cacheDir = createDefaultCacheDir(context)
        val maxSize = calculateDiskCacheSize(cacheDir)
        unsharedCache = okhttp3.Cache(cacheDir, maxSize)
        callFactory = OkHttpClient.Builder()
          .cache(unsharedCache)
          .build()
      }
      if (cache == null) {
        cache = PlatformLruCache(calculateMemoryCacheSize(context))
      }
      if (service == null) {
        service = PicassoExecutorService()
      }

      val dispatcher = Dispatcher(context, service!!, HANDLER, cache!!)

      return Picasso(
        context, dispatcher, callFactory!!, unsharedCache, cache!!, listener,
        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,
        indicatorsEnabled, loggingEnabled
      )
    }
  }

  

  @JvmName("-cacheMaxSize") 
  internal fun cacheMaxSize(maxSize: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMaxSize(maxSize)
    }
  }

  @JvmName("-cacheSize") 
  internal fun cacheSize(size: Int) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheSize(size)
    }
  }

  @JvmName("-cacheHit") 
  internal fun cacheHit() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheHit()
    }
  }

  @JvmName("-cacheMiss") 
  internal fun cacheMiss() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].cacheMiss()
    }
  }

  @JvmName("-downloadFinished") 
  internal fun downloadFinished(size: Long) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].downloadFinished(size)
    }
  }

  @JvmName("-bitmapDecoded") 
  internal fun bitmapDecoded(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapDecoded(bitmap)
    }
  }

  @JvmName("-bitmapTransformed") 
  internal fun bitmapTransformed(bitmap: Bitmap) {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].bitmapTransformed(bitmap)
    }
  }

  @JvmName("-close") 
  internal fun close() {
    val numListeners = eventListeners.size
    for (i in 0 until numListeners) {
      eventListeners[i].close()
    }
  }

  
  fun interface Listener {
    
    fun onImageLoadFailed(picasso: Picasso, uri: Uri?, exception: Exception)
  }

  
  fun interface RequestTransformer {
    
    fun transformRequest(request: Request): Request
  }

  
  enum class Priority {
    LOW,
    NORMAL,
    
    HIGH
  }

  
  enum class LoadedFrom(@get:JvmName("-debugColor") internal val debugColor: Int) {
    MEMORY(Color.GREEN),
    DISK(Color.BLUE),
    NETWORK(Color.RED);
  }

  internal companion object {
    @get:JvmName("-handler")
    internal val HANDLER: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: Message) {
        when (msg.what) {
          HUNTER_COMPLETE -> {
            val hunter = msg.obj as BitmapHunter
            hunter.picasso.complete(hunter)
          }
          REQUEST_BATCH_RESUME -> {
            val batch = msg.obj as List<Action>
            for (i in batch.indices) {
              val action = batch[i]
              action.picasso.resumeAction(action)
            }
          }
          else -> throw AssertionError("Unknown handler message received: " + msg.what)
        }
      }
    }
  }
}

const val TAG = "Picasso"

<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_NAME
import com.squareup.picasso3.TestUtils.CUSTOM_HEADER_VALUE
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.any
import com.squareup.picasso3.TestUtils.argumentCaptor
import com.squareup.picasso3.TestUtils.eq
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = argumentCaptor<Action>()
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()

    assertThat(result[0]).isNull()
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verifyNoMoreInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).defaultBitmapConfig
    verify(picasso).shutdown
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        indicatorsEnabled = false, isLoggingEnabled = false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerCrop().centerInside()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two error placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun imageViewActionWithCustomHeaders() {
    RequestCreator(picasso, URI_1, 0)
      .addHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)
      .into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.headers!![CUSTOM_HEADER_NAME])
      .isEqualTo(CUSTOM_HEADER_VALUE)
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.provider.MediaStore.Images
import android.provider.MediaStore.Video
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val URI_1: Uri = Uri.parse("http:
  val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  val URI_KEY_1: String = SIMPLE_REQUEST.key
  val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Images.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_2_URL: Uri = Video.Media.EXTERNAL_CONTENT_URI.buildUpon().appendPath("1").build()
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val MEDIA_STORE_CONTENT_KEY_2: String = Request.Builder(MEDIA_STORE_CONTENT_2_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123
  const val CUSTOM_HEADER_NAME = "Cache-Control"
  const val CUSTOM_HEADER_VALUE = "no-cache"

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null,
    headers: Map<String, String> = emptyMap(),
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    headers.forEach { (key, value) ->
      builder.addHeader(key, value)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso,
    request: Request,
    private val target: Any
  ) : Action(picasso, request) {
    var completedResult: Result? = null
    var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri?, _: Exception -> }
  val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  val NO_HANDLERS: List<RequestHandler> = emptyList()
  val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    var cacheHits = 0
    var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>,
      timeout: Long,
      unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }

  fun <T> any(type: Class<T>): T = Mockito.any(type)

  fun <T : Any> eq(value: T): T = Mockito.eq(value) ?: value

  inline fun <reified T : Any> argumentCaptor(): KArgumentCaptor<T> {
    return KArgumentCaptor(ArgumentCaptor.forClass(T::class.java))
  }

  class KArgumentCaptor<T>(
    private val captor: ArgumentCaptor<T>,
  ) {
    val value: T
      get() = captor.value

    fun capture(): T = captor.capture()
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = fail()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = fail()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}

<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import android.widget.RemoteViews
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.Listener
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FakeAction
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.defaultPicasso
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockDeferredRequestCreator
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.io.File

@RunWith(RobolectricTestRunner::class)
class PicassoTest {
  @get:Rule
  val temporaryFolder = TemporaryFolder()

  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  @Mock internal lateinit var requestHandler: RequestHandler
  @Mock internal lateinit var listener: Listener

  private val cache = PlatformLruCache(2048)
  private val eventRecorder = EventRecorder()
  private val bitmap = makeBitmap()

  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    picasso = Picasso(
      context = context,
      dispatcher = dispatcher,
      callFactory = UNUSED_CALL_FACTORY,
      closeableCache = null,
      cache = cache,
      listener = listener,
      requestTransformers = NO_TRANSFORMERS,
      extraRequestHandlers = NO_HANDLERS,
      eventListeners = listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888,
      indicatorsEnabled = false,
      isLoggingEnabled = false
    )
  }

  @Test fun submitWithTargetInvokesDispatcher() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    assertThat(picasso.targetToAction).isEmpty()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun submitWithSameActionDoesNotCancel() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    picasso.enqueueAndSubmit(action)
    verify(dispatcher).dispatchSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(picasso.targetToAction.containsValue(action)).isTrue()
    picasso.enqueueAndSubmit(action)
    assertThat(action.cancelled).isFalse()
    verify(dispatcher, never()).dispatchCancel(action)
  }

  @Test fun quickMemoryCheckReturnsBitmapIfInCache() {
    cache[URI_KEY_1] = bitmap
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isEqualTo(bitmap)
    assertThat(eventRecorder.cacheHits).isGreaterThan(0)
  }

  @Test fun quickMemoryCheckReturnsNullIfNotInCache() {
    val cached = picasso.quickMemoryCacheCheck(URI_KEY_1)
    assertThat(cached).isNull()
    assertThat(eventRecorder.cacheMisses).isGreaterThan(0)
  }

  @Test fun completeInvokesSuccessOnAllSuccessfulRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true

    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action1)
    assertThat(action2.completedResult).isNull()
  }

  @Test fun completeInvokesErrorOnAllFailedRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action1, exception)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    hunter.attach(action2)
    action2.cancelled = true
    hunter.run()
    picasso.complete(hunter)

    assertThat(action1.errorException).hasCauseThat().isEqualTo(exception)
    assertThat(action2.errorException).isNull()
    verify(listener).onImageLoadFailed(picasso, URI_1, action1.errorException!!)
  }

  @Test fun completeInvokesErrorOnFailedResourceRequests() {
    val action = mockAction(
      picasso = picasso,
      key = URI_KEY_1,
      uri = null,
      resourceId = 123,
      target = mockImageViewTarget()
    )
    val exception = mock(Exception::class.java)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action, exception)
    hunter.run()
    picasso.complete(hunter)

    assertThat(action.errorException).hasCauseThat().isEqualTo(exception)
    verify(listener).onImageLoadFailed(picasso, null, action.errorException!!)
  }

  @Test fun completeDeliversToSingle() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
  }

  @Test fun completeWithReplayDoesNotRemove() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    action.willReplay = true
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.run()
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    picasso.complete(hunter)
    assertThat(picasso.targetToAction).hasSize(1)

    verifyActionComplete(action)
  }

  @Test fun completeDeliversToSingleAndMultiple() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.attach(action2)
    hunter.run()
    picasso.complete(hunter)

    verifyActionComplete(action)
    verifyActionComplete(action2)
  }

  @Test fun completeSkipsIfNoActions() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap, MEMORY), action)
    hunter.detach(action)
    hunter.run()
    picasso.complete(hunter)

    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
  }

  @Test fun resumeActionTriggersSubmitOnPausedAction() {
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) = fail("Test execution should not call this method")
      override fun error(e: Exception) = fail("Test execution should not call this method")
      override fun getTarget(): Any = this
    }
    picasso.resumeAction(action)
    verify(dispatcher).dispatchSubmit(action)
  }

  @Test fun resumeActionImmediatelyCompletesCachedRequest() {
    cache[URI_KEY_1] = bitmap
    val request = Request.Builder(URI_1, 0, ARGB_8888).build()
    val action = object : Action(mockPicasso(RuntimeEnvironment.application), request) {
      override fun complete(result: Result) {
        assertThat(result).isInstanceOf(Bitmap::class.java)
        val bitmapResult = result as Bitmap
        assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
        assertThat(bitmapResult.loadedFrom).isEqualTo(MEMORY)
      }

      override fun error(e: Exception) =
        fail("Reading from memory cache should not throw an exception")

      override fun getTarget(): Any = this
    }

    picasso.resumeAction(action)
  }

  @Test fun cancelExistingRequestWithUnknownTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(action.cancelled).isFalse()
    verifyZeroInteractions(dispatcher)
  }

  @Test fun cancelExistingRequestWithImageViewTarget() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithDeferredImageViewTarget() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.cancelRequest(target)
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun enqueueingDeferredRequestCancelsThePreviousOne() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val firstRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)

    val secondRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, secondRequestCreator)
    verify(target).removeOnAttachStateChangeListener(firstRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).containsKey(target)
  }

  @Test fun cancelExistingRequestWithTarget() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(target)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelExistingRequestWithRemoteViewTarget() {
    val layoutId = 0
    val viewId = 1
    val remoteViews = RemoteViews("com.squareup.picasso3.test", layoutId)
    val target = RemoteViewsTarget(remoteViews, viewId)
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelRequest(remoteViews, viewId)
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
    verify(dispatcher).dispatchCancel(action)
  }

  @Test fun cancelTagAllActions() {
    val target = mockImageViewTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target, tag = "TAG")
    picasso.enqueueAndSubmit(action)
    assertThat(picasso.targetToAction).hasSize(1)
    assertThat(action.cancelled).isFalse()
    picasso.cancelTag("TAG")
    assertThat(picasso.targetToAction).isEmpty()
    assertThat(action.cancelled).isTrue()
  }

  @Test fun cancelTagAllDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso).tag("TAG")
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.defer(target, deferredRequestCreator)
    picasso.cancelTag("TAG")
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
  }

  @Test fun deferAddsToMap() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
    picasso.defer(target, deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).hasSize(1)
  }

  @Test fun shutdown() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClosesUnsharedCache() {
    val cache = okhttp3.Cache(temporaryFolder.root, 100)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, cache, this.cache, listener,
      NO_TRANSFORMERS, NO_HANDLERS, listOf(eventRecorder),
      defaultBitmapConfig = ARGB_8888, indicatorsEnabled = false, isLoggingEnabled = false
    )
    picasso.shutdown()
    assertThat(cache.isClosed).isTrue()
  }

  @Test fun shutdownTwice() {
    cache["key"] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.shutdown()
    picasso.shutdown()
    assertThat(cache.size()).isEqualTo(0)
    assertThat(eventRecorder.closed).isTrue()
    verify(dispatcher).shutdown()
    assertThat(picasso.shutdown).isTrue()
  }

  @Test fun shutdownClearsDeferredRequests() {
    val target = mockImageViewTarget()
    val creator = mockRequestCreator(picasso)
    val deferredRequestCreator = mockDeferredRequestCreator(creator, target)
    picasso.targetToDeferredRequestCreator[target] = deferredRequestCreator
    picasso.shutdown()
    verify(target).removeOnAttachStateChangeListener(deferredRequestCreator)
    assertThat(picasso.targetToDeferredRequestCreator).isEmpty()
  }

  @Test fun loadThrowsWithInvalidInput() {
    try {
      picasso.load("")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load("      ")
      fail("Empty URL should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
    try {
      picasso.load(0)
      fail("Zero resourceId should throw exception.")
    } catch (expected: IllegalArgumentException) {
    }
  }

  @Test fun builderInvalidCache() {
    try {
      Picasso.Builder(RuntimeEnvironment.application).withCacheSize(-1)
      fail()
    } catch (expected: IllegalArgumentException) {
      assertThat(expected).hasMessageThat().isEqualTo("maxByteCount < 0: -1")
    }
  }

  @Test fun builderWithoutRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).build()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).doesNotContain(requestHandler)
  }

  @Test fun builderWithRequestHandler() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application)
      .addRequestHandler(requestHandler)
      .build()
    assertThat(picasso.requestHandlers).isNotNull()
    assertThat(picasso.requestHandlers).isNotEmpty()
    assertThat(picasso.requestHandlers).contains(requestHandler)
  }

  @Test fun builderWithDebugIndicators() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    assertThat(picasso.indicatorsEnabled).isTrue()
  }

  @Test fun evictAll() {
    val picasso = Picasso.Builder(RuntimeEnvironment.application).indicatorsEnabled(true).build()
    picasso.cache["key"] = android.graphics.Bitmap.createBitmap(1, 1, ALPHA_8)
    assertThat(picasso.cache.size()).isEqualTo(1)
    picasso.evictAll()
    assertThat(picasso.cache.size()).isEqualTo(0)
  }

  @Test fun invalidateString() {
    val request = Request.Builder(Uri.parse("https:
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate("https:
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateFile() {
    val request = Request.Builder(Uri.fromFile(File("/foo/bar/baz"))).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(File("/foo/bar/baz"))
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun invalidateUri() {
    val request = Request.Builder(URI_1).build()
    cache[request.key] = makeBitmap(1, 1)
    assertThat(cache.size()).isEqualTo(1)
    picasso.invalidate(URI_1)
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun clonedRequestHandlersAreIndependent() {
    val original = defaultPicasso(RuntimeEnvironment.application, false, false)

    original.newBuilder()
      .addRequestTransformer(TestUtils.NOOP_TRANSFORMER)
      .addRequestHandler(TestUtils.NOOP_REQUEST_HANDLER)
      .build()

    assertThat(original.requestTransformers).hasSize(NUM_BUILTIN_TRANSFORMERS)
    assertThat(original.requestHandlers).hasSize(NUM_BUILTIN_HANDLERS)
  }

  @Test fun cloneSharesStatefulInstances() {
    val parent = defaultPicasso(RuntimeEnvironment.application, true, true)

    val child = parent.newBuilder().build()

    assertThat(child.context).isEqualTo(parent.context)
    assertThat(child.callFactory).isEqualTo(parent.callFactory)
    assertThat(child.dispatcher.service).isEqualTo(parent.dispatcher.service)
    assertThat(child.cache).isEqualTo(parent.cache)
    assertThat(child.listener).isEqualTo(parent.listener)
    assertThat(child.requestTransformers).isEqualTo(parent.requestTransformers)

    assertThat(child.requestHandlers).hasSize(parent.requestHandlers.size)
    child.requestHandlers.forEachIndexed { index, it ->
      assertThat(it).isInstanceOf(parent.requestHandlers[index].javaClass)
    }

    assertThat(child.defaultBitmapConfig).isEqualTo(parent.defaultBitmapConfig)
    assertThat(child.indicatorsEnabled).isEqualTo(parent.indicatorsEnabled)
    assertThat(child.isLoggingEnabled).isEqualTo(parent.isLoggingEnabled)

    assertThat(child.targetToAction).isEqualTo(parent.targetToAction)
    assertThat(child.targetToDeferredRequestCreator).isEqualTo(
      parent.targetToDeferredRequestCreator
    )
  }

  private fun verifyActionComplete(action: FakeAction) {
    val result = action.completedResult
    assertThat(result).isNotNull()
    assertThat(result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val bitmapResult = result as RequestHandler.Result.Bitmap
    assertThat(bitmapResult.bitmap).isEqualTo(bitmap)
    assertThat(bitmapResult.loadedFrom).isEqualTo(NETWORK)
  }

  companion object {
    private const val NUM_BUILTIN_HANDLERS = 8
    private const val NUM_BUILTIN_TRANSFORMERS = 0
  }
}

<code block>

package com.example.picasso

import android.app.Activity
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.RemoteViews
import android.widget.TextView
import androidx.core.app.NotificationCompat
import java.util.Random

internal class PicassoSampleAdapter(context: Context?) : BaseAdapter() {
  internal enum class Sample(
    val label: String,
    private val activityClass: Class<out Activity>?
  ) {
    GRID_VIEW("Image Grid View", SampleGridViewActivity::class.java),
    GALLERY("Load from Gallery", SampleGalleryActivity::class.java),
    CONTACTS("Contact Photos", SampleContactsActivity::class.java),
    LIST_DETAIL("List / Detail View", SampleListDetailActivity::class.java),
    SHOW_NOTIFICATION("Sample Notification", null) {
      override fun launch(activity: Activity) {
        val remoteViews = RemoteViews(activity.packageName, R.layout.notification_view)

        val intent = Intent(activity, SampleGridViewActivity::class.java)

        val notification =
          NotificationCompat.Builder(activity, CHANNEL_ID)
            .setSmallIcon(R.drawable.icon)
            .setContentIntent(PendingIntent.getActivity(activity, -1, intent, 0))
            .setContent(remoteViews)
            .setAutoCancel(true)
            .setChannelId(CHANNEL_ID)
            .build()

        val notificationManager =
          activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (VERSION.SDK_INT >= VERSION_CODES.O) {
          val channel = NotificationChannel(
            CHANNEL_ID, "Picasso Notification Channel",
            NotificationManager.IMPORTANCE_DEFAULT
          )
          notificationManager.createNotificationChannel(channel)
        }

        notificationManager.notify(NOTIFICATION_ID, notification)

        
        PicassoInitializer.get()
          .load(Data.URLS[Random().nextInt(Data.URLS.size)])
          .resizeDimen(
            R.dimen.notification_icon_width_height,
            R.dimen.notification_icon_width_height
          )
          .into(remoteViews, R.id.photo, NOTIFICATION_ID, notification)
      }
    };

    open fun launch(activity: Activity) {
      activity.startActivity(Intent(activity, activityClass))
      activity.finish()
    }
  }

  private val inflater: LayoutInflater = LayoutInflater.from(context)

  override fun getCount(): Int = Sample.values().size

  override fun getItem(position: Int): Sample = Sample.values()[position]

  override fun getItemId(position: Int): Long = position.toLong()

  override fun getView(
    position: Int,
    convertView: View?,
    parent: ViewGroup
  ): View {
    val view = if (convertView == null) {
      inflater.inflate(R.layout.picasso_sample_activity_item, parent, false) as TextView
    } else
      convertView as TextView

    view.text = getItem(position).label
    return view
  }

  companion object {
    private const val NOTIFICATION_ID = 666
    private const val CHANNEL_ID = "channel-id"
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
      update()
      callback?.onSuccess()
    }
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result.Drawable(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result.Bitmap(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    if (result is Bitmap) {
      val bitmap = result.bitmap
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {

    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3

import com.squareup.picasso3.RequestHandler.Result


interface Transformation {
  
  fun transform(source: Result.Bitmap): Result.Bitmap

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result.Bitmap(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.squareup.picasso3

import android.net.NetworkInfo
import com.squareup.picasso3.Picasso.LoadedFrom
import java.io.IOException


abstract class RequestHandler {
  
  sealed class Result constructor(
    
    @JvmField val loadedFrom: LoadedFrom,
    
    @JvmField val exifRotation: Int = 0
  ) {
    class Bitmap @JvmOverloads constructor(
      val bitmap: android.graphics.Bitmap,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)

    class Drawable @JvmOverloads constructor(
      val drawable: android.graphics.drawable.Drawable,
      loadedFrom: LoadedFrom,
      exifRotation: Int = 0
    ) : Result(loadedFrom, exifRotation)
  }

  interface Callback {
    fun onSuccess(result: Result?)
    fun onError(t: Throwable)
  }

  
  abstract fun canHandleRequest(data: Request): Boolean

  
  @Throws(IOException::class)
  abstract fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  )

  open val retryCount = 0

  open fun shouldRetry(
    airplaneMode: Boolean,
    info: NetworkInfo?
  ) = false

  open fun supportsReplay() = false
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result.Bitmap): Result.Bitmap {
    val bitmap = source.bitmap

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result.Bitmap(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.app.NotificationManager
import android.appwidget.AppWidgetManager
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal abstract class RemoteViewsAction(
  picasso: Picasso,
  data: Request,
  @DrawableRes val errorResId: Int,
  val target: RemoteViewsTarget,
  var callback: Callback?
) : Action(picasso, data) {
  override fun complete(result: Result) {
    target.remoteViews.setImageViewBitmap(target.viewId, result.bitmap)
    update()
    callback?.onSuccess()
  }

  override fun cancel() {
    super.cancel()
    callback = null
  }

  override fun error(e: Exception) {
    if (errorResId != 0) {
      setImageResource(errorResId)
    }
    callback?.onError(e)
  }

  fun setImageResource(resId: Int) {
    target.remoteViews.setImageViewResource(target.viewId, resId)
    update()
  }

  abstract fun update()

  internal class RemoteViewsTarget(
    val remoteViews: RemoteViews,
    val viewId: Int
  ) {
    override fun equals(other: Any?): Boolean {
      if (this === other) return true
      if (other == null || javaClass != other.javaClass) return false
      val remoteViewsTarget = other as RemoteViewsTarget
      return viewId == remoteViewsTarget.viewId && remoteViews ==
          remoteViewsTarget.remoteViews
    }

    override fun hashCode(): Int {
      return 31 * remoteViews.hashCode() + viewId
    }

  }

  internal class AppWidgetAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val appWidgetIds: IntArray,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = AppWidgetManager.getInstance(picasso.context)
      manager.updateAppWidget(appWidgetIds, target.remoteViews)
    }

    override fun getTarget(): Any {
      return target
    }

  }

  internal class NotificationAction(
    picasso: Picasso,
    data: Request,
    @DrawableRes errorResId: Int,
    target: RemoteViewsTarget,
    private val notificationId: Int,
    private val notification: Notification,
    private val notificationTag: String?,
    callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {
      val manager = ContextCompat.getSystemService(
          picasso.context, NotificationManager::class.java
      )
      manager?.notify(notificationTag, notificationId, notification)
    }

    override fun getTarget(): Any {
      return target
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import com.squareup.picasso3.BitmapUtils.decodeResource
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

internal class ResourceRequestHandler(private val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return if (data.resourceId != 0 && !isXmlResource(context.resources, data.resourceId)) { true }
    else data.uri != null && ContentResolver.SCHEME_ANDROID_RESOURCE == data.uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val bitmap = decodeResource(context, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.drawable.Drawable
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapUtils.isXmlResource
import com.squareup.picasso3.Picasso.LoadedFrom.DISK

class ResourceDrawableRequestHandler private constructor(
  private val context: Context,
  private val loader: DrawableLoader
) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean {
    return data.resourceId != 0 && isXmlResource(context.resources, data.resourceId)
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    val drawable = loader.load(request.resourceId)
    if (drawable == null) {
      callback.onError(
          IllegalArgumentException("invalid resId: ${Integer.toHexString(request.resourceId)}")
      )
    } else {
      callback.onSuccess(Result(drawable, DISK))
    }
  }

  companion object {
    @JvmStatic
    fun create(
      context: Context,
      loader: DrawableLoader
    ) = ResourceDrawableRequestHandler(context, loader)

    @JvmStatic
    fun create(context: Context): ResourceDrawableRequestHandler {
      return create(context, object : DrawableLoader {
        override fun load(resId: Int): Drawable? = ContextCompat.getDrawable(context, resId)
      })
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.res.AssetManager
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.source

internal class AssetRequestHandler(private val context: Context) : RequestHandler() {
  private val lock = Any()

  @Volatile
  private var assetManager: AssetManager? = null

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return (uri != null && ContentResolver.SCHEME_FILE == uri.scheme &&
        uri.pathSegments.isNotEmpty() && ANDROID_ASSET == uri.pathSegments[0])
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    initializeIfFirstTime()
    var signaledCallback = false
    try {
      assetManager!!.open(getFilePath(request))
          .source()
          .use { source ->
            val bitmap = decodeStream(source, request)
            signaledCallback = true
            callback.onSuccess(Result(bitmap, DISK))
          }
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Initializer private fun initializeIfFirstTime() {
    if (assetManager == null) {
      synchronized(lock) {
        if (assetManager == null) {
          assetManager = context.assets
        }
      }
    }
  }

  companion object {
    private const val ANDROID_ASSET = "android_asset"
    private const val ASSET_PREFIX_LENGTH =
      "${ContentResolver.SCHEME_FILE}:

    fun getFilePath(request: Request): String {
      val uri = checkNotNull(request.uri)
      return uri.toString()
          .substring(ASSET_PREFIX_LENGTH)
    }
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.content.UriMatcher
import android.net.Uri
import android.provider.ContactsContract
import android.provider.ContactsContract.Contacts
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal class ContactsPhotoRequestHandler(private val context: Context) : RequestHandler() {
  companion object {
    
    private const val ID_LOOKUP = 1
    
    private const val ID_THUMBNAIL = 2
    
    private const val ID_CONTACT = 3
    
    private const val ID_DISPLAY_PHOTO = 4

    private val matcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_LOOKUP)
      addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_THUMBNAIL)
      addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACT)
      addURI(ContactsContract.AUTHORITY, "display_photo/#", ID_DISPLAY_PHOTO)
    }
  }

  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null
        && ContentResolver.SCHEME_CONTENT == uri.scheme
        && Contacts.CONTENT_URI.host == uri.host
        && matcher.match(data.uri) != UriMatcher.NO_MATCH
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  private fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val input = when (matcher.match(uri)) {
      ID_LOOKUP -> {
        val contactUri =
          Contacts.lookupContact(contentResolver, uri) ?: throw IOException("no contact found")
        Contacts.openContactPhotoInputStream(contentResolver, contactUri, true)
      }
      ID_CONTACT -> Contacts.openContactPhotoInputStream(contentResolver, uri, true)
      ID_THUMBNAIL, ID_DISPLAY_PHOTO -> contentResolver.openInputStream(uri)
      else -> throw IllegalStateException("Invalid uri: $uri")
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")

    return input.source()
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.drawable.Drawable
import androidx.annotation.DrawableRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.RequestHandler.Result

internal class BitmapTargetAction(
  picasso: Picasso,
  val target: BitmapTarget,
  data: Request,
  val errorDrawable: Drawable?,
  @DrawableRes val errorResId: Int
) : Action(picasso, data) {
  override fun complete(result: Result) {
    val bitmap = result.bitmap
    if (bitmap != null) {
      target.onBitmapLoaded(bitmap, result.loadedFrom)
      check(!bitmap.isRecycled) { "Target callback must not recycle bitmap!" }
    }
  }

  override fun error(e: Exception) {
    val drawable = if (errorResId != 0) {
      ContextCompat.getDrawable(picasso.context, errorResId)
    } else {
      errorDrawable
    }

    target.onBitmapFailed(e, drawable)
  }

  override fun getTarget(): Any {
    return target
  }
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_NORMAL
import androidx.exifinterface.media.ExifInterface.TAG_ORIENTATION
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import okio.Source
import okio.source
import java.io.FileNotFoundException
import java.io.IOException

internal open class ContentStreamRequestHandler(@JvmField val context: Context) : RequestHandler() {
  override fun canHandleRequest(data: Request): Boolean =
    ContentResolver.SCHEME_CONTENT == data.uri?.scheme ?: false

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = BitmapUtils.decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(FileNotFoundException::class) fun getSource(uri: Uri): Source {
    val contentResolver = context.contentResolver
    val inputStream = contentResolver.openInputStream(uri)
        ?: throw FileNotFoundException("can't open input stream, uri: $uri")
    return inputStream.source()
  }

  @Throws(IOException::class)
  protected open fun getExifOrientation(uri: Uri): Int {
    val contentResolver = context.contentResolver
    contentResolver.openInputStream(uri)?.use { input ->
      return ExifInterface(input).getAttributeInt(TAG_ORIENTATION, ORIENTATION_NORMAL)
    } ?: throw FileNotFoundException("can't open input stream, uri: $uri")
  }
}
<code block>

package com.squareup.picasso3


interface Transformation {
  
  fun transform(source: RequestHandler.Result): RequestHandler.Result

  
  fun key(): String
}
<code block>

package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import androidx.exifinterface.media.ExifInterface
import com.squareup.picasso3.BitmapUtils.decodeStream
import com.squareup.picasso3.Picasso.LoadedFrom.DISK
import java.io.FileNotFoundException
import java.io.IOException

internal class FileRequestHandler(context: Context) : ContentStreamRequestHandler(context) {
  override fun canHandleRequest(data: Request): Boolean {
    val uri = data.uri
    return uri != null && ContentResolver.SCHEME_FILE == uri.scheme
  }

  override fun load(
    picasso: Picasso,
    request: Request,
    callback: Callback
  ) {
    var signaledCallback = false
    try {
      val requestUri = checkNotNull(request.uri)
      val source = getSource(requestUri)
      val bitmap = decodeStream(source, request)
      val exifRotation = getExifOrientation(requestUri)
      signaledCallback = true
      callback.onSuccess(Result(bitmap, DISK, exifRotation))
    } catch (e: Exception) {
      if (!signaledCallback) {
        callback.onError(e)
      }
    }
  }

  @Throws(IOException::class)
  override fun getExifOrientation(uri: Uri): Int {
    val path = uri.path ?: throw FileNotFoundException("path == null, uri: $uri")
    return ExifInterface(path).getAttributeInt(
        ExifInterface.TAG_ORIENTATION,
        ExifInterface.ORIENTATION_NORMAL
    )
  }
}
<code block>

package com.example.picasso

import android.graphics.Bitmap.createBitmap
import android.graphics.BitmapShader
import android.graphics.Canvas
import android.graphics.ColorMatrix
import android.graphics.ColorMatrixColorFilter
import android.graphics.Paint
import android.graphics.Paint.ANTI_ALIAS_FLAG
import android.graphics.PorterDuff.Mode.MULTIPLY
import android.graphics.PorterDuffXfermode
import android.graphics.Shader.TileMode.REPEAT
import com.squareup.picasso3.Picasso
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.Transformation
import java.io.IOException

class GrayscaleTransformation(private val picasso: Picasso) : Transformation {
  override fun transform(source: Result): Result {
    val bitmap = source.bitmap ?: return source

    val result = createBitmap(bitmap.width, bitmap.height, bitmap.config)
    val noise = try {
      picasso.load(R.drawable.noise).get()!!
    } catch (e: IOException) {
      throw RuntimeException("Failed to apply transformation! Missing resource.")
    }

    val colorMatrix = ColorMatrix().apply { setSaturation(0f) }

    val paint = Paint(ANTI_ALIAS_FLAG).apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }

    val canvas = Canvas(result)
    canvas.drawBitmap(bitmap, 0f, 0f, paint)

    paint.apply {
      colorFilter = null
      shader = BitmapShader(noise, REPEAT, REPEAT)
      xfermode = PorterDuffXfermode(MULTIPLY)
    }

    canvas.drawRect(0f, 0f, canvas.width.toFloat(), canvas.height.toFloat(), paint)

    bitmap.recycle()
    noise.recycle()

    return Result(result, source.loadedFrom, source.exifRotation)
  }

  override fun key() = "grayscaleTransformation()"
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import android.util.Log
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.TAG
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.concurrent.ExecutorService

internal class Dispatcher internal constructor(
  private val context: Context,
  @JvmField internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  private val dispatcherThread: DispatcherThread
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()
  internal val failedActions = mutableMapOf<Any, Action>()
  internal val pausedActions = mutableMapOf<Any, Action>()
  internal val pausedTags = mutableSetOf<Any>()
  private val handler: Handler
  internal val receiver: NetworkBroadcastReceiver
  private val scansNetworkChanges: Boolean

  @JvmField internal var airplaneMode = isAirplaneModeOn(context)

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    dispatcherThread.quit()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  @JvmOverloads
  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.loggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while(iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.loggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.loggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return  
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import org.robolectric.RobolectricTestRunner
import org.mockito.Mock
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    
    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = picasso,
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  private val picasso = mockPicasso(RuntimeEnvironment.application)

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator(picasso).tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val spyPicasso = spy(picasso) 
    val creator = RequestCreator(spyPicasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
    verify(spyPicasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Captor
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  @Mock private lateinit var picasso: Picasso
  @Captor private lateinit var actionCaptor: ArgumentCaptor<Action>

  private val bitmap = makeBitmap()

  @Before fun shutUp() {
    initMocks(this)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)
  }

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator().resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator().placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator().noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator().error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator().priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator().tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator().transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mock(Picasso::class.java)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mock(Picasso::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mock(Picasso::class.java)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.Captor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  @Captor
  internal lateinit var actionCaptor: ArgumentCaptor<Action>

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator().tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)

    val creator = RequestCreator(picasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import com.squareup.picasso3.TestUtils.mockPicasso
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    picasso = mockPicasso(RuntimeEnvironment.application)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val knownContentLengthSize = 10
    responses.add(responseOf(ByteArray(knownContentLengthSize).toResponseBody(null)))
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(knownContentLengthSize)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(picasso, URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        assertThat(eventRecorder.downloadSize).isEqualTo(0)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  private lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(picasso, request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.EventRecorder
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NOOP_REQUEST_HANDLER
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var picasso: Picasso

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context, NOOP_REQUEST_HANDLER)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(eventRecorder.decodedBitmap).isEqualTo(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val eventRecorder = EventRecorder()
    val picasso = picasso.newBuilder().addEventListener(eventRecorder).build()
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    assertThat(eventRecorder.decodedBitmap).isNull()
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(picasso, URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val picasso = mockPicasso(context, ContentStreamRequestHandler(context))
    val action = mockAction(picasso, CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val picasso = mockPicasso(context, MediaStoreRequestHandler(context))
    val action = mockAction(picasso, MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val picasso = mockPicasso(context, ContactsPhotoRequestHandler(context))
    val action = mockAction(picasso, CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val picasso = mockPicasso(context, ResourceRequestHandler(context))
    val action = mockAction(picasso, RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val picasso = mockPicasso(context, AssetRequestHandler(context))
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val picasso = mockPicasso(context, FileRequestHandler(context))
    val action = mockAction(picasso, "keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val picasso = mockPicasso(context, CustomRequestHandler())
    val action = mockAction(picasso, CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val handler = AssetRequestHandler(context)
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      listOf(handler), emptyList(), ARGB_8888, false, false
    )
    val action = mockAction(picasso, ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val picasso = mockPicasso(context)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val picasso = mockPicasso(context, requestHandler)
    val action1 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val hunter = forRequest(picasso, dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(request, target)
  }

  @JvmStatic fun mockAction(request: Request, target: Any = mockTarget()): FakeAction =
    FakeAction(mockPicasso(), request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = mockPicasso(),
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(requestHandler)
  }

  @JvmStatic fun mockPicasso(requestHandler: RequestHandler): Picasso {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.getRequestHandlers()).thenReturn(listOf(requestHandler))
    return picasso
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.TestUtils.PremadeCall
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import okhttp3.CacheControl
import okhttp3.MediaType
import okhttp3.Protocol.HTTP_1_1
import okhttp3.Response
import okhttp3.ResponseBody
import okhttp3.ResponseBody.Companion.toResponseBody
import okio.Buffer
import okio.BufferedSource
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyLong
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import java.util.concurrent.CountDownLatch
import java.util.concurrent.LinkedBlockingDeque
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean

@RunWith(RobolectricTestRunner::class)
class NetworkRequestHandlerTest {
  private val responses = LinkedBlockingDeque<Response>()
  private val requests = LinkedBlockingDeque<okhttp3.Request>()

  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher
  private lateinit var networkHandler: NetworkRequestHandler

  @Before fun setUp() {
    initMocks(this)
    networkHandler = NetworkRequestHandler { request ->
      requests.add(request)
      try {
        PremadeCall(request, responses.takeFirst())
      } catch (e: InterruptedException) {
        throw AssertionError(e)
      }
    }
  }

  @Test @Throws(Exception::class)
  fun doesNotForceLocalCacheOnlyWithAirplaneModeOffAndRetryCount() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        try {
          assertThat(requests.takeFirst().cacheControl.toString()).isEmpty()
          latch.countDown()
        } catch (e: InterruptedException) {
          throw AssertionError(e)
        }
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun withZeroRetryCountForcesLocalCacheOnly() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    hunter.retryCount = 0
    hunter.hunt()
    assertThat(requests.takeFirst().cacheControl.toString())
      .isEqualTo(CacheControl.FORCE_CACHE.toString())
  }

  @Test fun shouldRetryTwiceWithAirplaneModeOffAndNoNetworkInfo() {
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val cache = PlatformLruCache(0)
    val hunter = BitmapHunter(picasso, dispatcher, cache, action, networkHandler)
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(hunter.shouldRetry(airplaneMode = false, info = null)).isFalse()
  }

  @Test fun shouldRetryWithUnknownNetworkInfo() {
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = null)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = null)).isTrue()
  }

  @Test fun shouldRetryWithConnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnected).thenReturn(true)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isTrue()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isTrue()
  }

  @Test fun shouldNotRetryWithDisconnectedNetworkInfo() {
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    assertThat(networkHandler.shouldRetry(airplaneMode = false, info = info)).isFalse()
    assertThat(networkHandler.shouldRetry(airplaneMode = true, info = info)).isFalse()
  }

  @Test @Throws(Exception::class)
  fun noCacheAndKnownContentLengthDispatchToStats() {
    responses.add(responseOf(ByteArray(10).toResponseBody(null)))
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso).downloadFinished(10)
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun unknownContentLengthFromDiskThrows() {
    val closed = AtomicBoolean()
    val body = object : ResponseBody() {
      override fun contentType(): MediaType? = null
      override fun contentLength(): Long = 0
      override fun source(): BufferedSource = Buffer()
      override fun close() {
        closed.set(true)
        super.close()
      }
    }
    responses += responseOf(body)
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?): Unit = throw AssertionError()

      override fun onError(t: Throwable) {
        verify(picasso, never()).downloadFinished(anyLong())
        assertTrue(closed.get())
        latch.countDown()
      }
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test @Throws(Exception::class)
  fun cachedResponseDoesNotDispatchToStats() {
    responses += responseOf(ByteArray(10).toResponseBody(null))
      .newBuilder()
      .cacheResponse(responseOf(null))
      .build()
    val action = TestUtils.mockAction(URI_KEY_1, URI_1)
    val latch = CountDownLatch(1)
    networkHandler.load(picasso, action.request, object : RequestHandler.Callback {
      override fun onSuccess(result: Result?) {
        verify(picasso, never()).downloadFinished(anyLong())
        latch.countDown()
      }

      override fun onError(t: Throwable): Unit = throw AssertionError(t)
    })
    assertThat(latch.await(10, SECONDS)).isTrue()
  }

  @Test fun shouldHandleSchemeInsensitiveCase() {
    val schemes = arrayOf("http", "https", "HTTP", "HTTPS", "HTtP")
    for (scheme in schemes) {
      val uri = URI_1.buildUpon().scheme(scheme).build()
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue()
    }
  }

  private fun responseOf(body: ResponseBody?) =
    Response.Builder()
      .code(200)
      .protocol(HTTP_1_1)
      .request(okhttp3.Request.Builder().url("http:
      .message("OK")
      .body(body)
      .build()
}
<code block>
package com.squareup.picasso3

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.Uri
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MediaStoreRequestHandler.Companion.getPicassoKind
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.FULL
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MICRO
import com.squareup.picasso3.MediaStoreRequestHandler.PicassoKind.MINI
import com.squareup.picasso3.RequestHandler.Callback
import com.squareup.picasso3.Shadows.ShadowImageThumbnails
import com.squareup.picasso3.Shadows.ShadowVideoThumbnails
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockAction
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@Config(shadows = [ShadowVideoThumbnails::class, ShadowImageThumbnails::class])
class MediaStoreRequestHandlerTest {
  @Mock lateinit var context: Context
  @Mock lateinit var picasso: Picasso

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun decodesVideoThumbnailWithVideoMimeType() {
    val bitmap = makeBitmap()
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("video/")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun decodesImageThumbnailWithImageMimeType() {
    val bitmap = makeBitmap(20, 20)
    val request = Request.Builder(
      uri = MEDIA_STORE_CONTENT_1_URL,
      resourceId = 0,
      bitmapConfig = ARGB_8888
    )
      .stableKey(MEDIA_STORE_CONTENT_KEY_1)
      .resize(100, 100)
      .build()
    val action = mockAction(request)
    val requestHandler = create("image/png")
    requestHandler.load(picasso, action.request, object : Callback {
      override fun onSuccess(result: RequestHandler.Result?) =
        assertBitmapsEqual((result as RequestHandler.Result.Bitmap?)!!.bitmap, bitmap)

      override fun onError(t: Throwable) = fail(t.message)
    })
  }

  @Test fun getPicassoKindMicro() {
    assertThat(getPicassoKind(96, 96)).isEqualTo(MICRO)
    assertThat(getPicassoKind(95, 95)).isEqualTo(MICRO)
  }

  @Test fun getPicassoKindMini() {
    assertThat(getPicassoKind(512, 384)).isEqualTo(MINI)
    assertThat(getPicassoKind(100, 100)).isEqualTo(MINI)
  }

  @Test fun getPicassoKindFull() {
    assertThat(getPicassoKind(513, 385)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 1000)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 384)).isEqualTo(FULL)
    assertThat(getPicassoKind(1000, 96)).isEqualTo(FULL)
    assertThat(getPicassoKind(96, 1000)).isEqualTo(FULL)
  }

  private fun create(mimeType: String): MediaStoreRequestHandler {
    val contentResolver = mock(ContentResolver::class.java)
    `when`(contentResolver.getType(any(Uri::class.java))).thenReturn(mimeType)
    return create(contentResolver)
  }

  private fun create(contentResolver: ContentResolver): MediaStoreRequestHandler {
    `when`(context.contentResolver).thenReturn(contentResolver)
    return MediaStoreRequestHandler(context)
  }

  private fun assertBitmapsEqual(a: Bitmap, b: Bitmap) {
    if (a.height != b.height) fail()
    if (a.width != b.width) fail()

    if (shadowOf(a).description != shadowOf(b).description) fail()
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.graphics.Bitmap.Config.ARGB_8888
import android.net.NetworkInfo
import android.net.Uri
import android.os.Looper
import android.view.Gravity
import androidx.exifinterface.media.ExifInterface
import androidx.exifinterface.media.ExifInterface.ORIENTATION_ROTATE_90
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.BitmapHunter.Companion.applyTransformations
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MatrixTransformation.Companion.transformResult
import com.squareup.picasso3.NetworkRequestHandler.ResponseException
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.Request.Companion.KEY_SEPARATOR
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.ASSET_KEY_1
import com.squareup.picasso3.TestUtils.ASSET_URI_1
import com.squareup.picasso3.TestUtils.BITMAP_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.CONTACT_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_KEY_1
import com.squareup.picasso3.TestUtils.CONTACT_PHOTO_URI_1
import com.squareup.picasso3.TestUtils.CONTACT_URI_1
import com.squareup.picasso3.TestUtils.CONTENT_1_URL
import com.squareup.picasso3.TestUtils.CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.CUSTOM_URI
import com.squareup.picasso3.TestUtils.CUSTOM_URI_KEY
import com.squareup.picasso3.TestUtils.FILE_1_URL
import com.squareup.picasso3.TestUtils.FILE_KEY_1
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_1_URL
import com.squareup.picasso3.TestUtils.MEDIA_STORE_CONTENT_KEY_1
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_KEY_1
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI
import com.squareup.picasso3.TestUtils.RESOURCE_ID_URI_KEY
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI
import com.squareup.picasso3.TestUtils.RESOURCE_TYPE_URI_KEY
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.XML_RESOURCE_VALUE
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.makeLoaderWithDrawable
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockResources
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.Shadows.shadowOf
import java.io.File
import java.io.IOException
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class BitmapHunterTest {
  @Mock internal lateinit var context: Context
  @Mock internal lateinit var picasso: Picasso
  @Mock internal lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val bitmap = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun nullDecodeResponseIsError() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithResultDispatchComplete() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)
    hunter.run()
    verify(dispatcher).dispatchComplete(hunter)
  }

  @Test fun runWithNoResultDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun responseExceptionDispatchFailed() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(
      picasso, dispatcher, cache, action, null, ResponseException(504, 0)
    )
    hunter.run()
    verify(dispatcher).dispatchFailed(hunter)
  }

  @Test fun runWithIoExceptionDispatchRetry() {
    val action = mockAction(URI_KEY_1, URI_1)
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, null, IOException())
    hunter.run()
    verify(dispatcher).dispatchRetry(hunter)
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWhenNotInCache() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.missCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    verify(picasso).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntReturnsWhenResultInCache() {
    cache[URI_KEY_1 + KEY_SEPARATOR] = bitmap
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action, bitmap)

    val result = hunter.hunt()
    assertThat(cache.hitCount()).isEqualTo(1)
    assertThat(result).isNotNull()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
    assertThat(result.loadedFrom).isEqualTo(MEMORY)
    verify(picasso, never()).bitmapDecoded(bitmap)
  }

  @Test @Throws(Exception::class)
  fun huntUnrecognizedUri() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(picasso, dispatcher, cache, action)
    try {
      hunter.hunt()
      fail("Unrecognized URI should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test @Throws(Exception::class)
  fun huntDecodesWithRequestHandler() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    val result = hunter.hunt()
    assertThat(result!!.bitmap).isEqualTo(bitmap)
  }

  @Test fun attachSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.action).isEqualTo(action1)
    hunter.detach(action1)
    hunter.attach(action1)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isNull()
  }

  @Test fun attachMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    assertThat(hunter.actions).isNull()
    hunter.attach(action2)
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).hasSize(1)
  }

  @Test fun detachSingleRequest() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    assertThat(hunter.action).isNotNull()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun detachMultipleRequests() {
    val action = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action)
    hunter.attach(action2)
    hunter.detach(action2)
    assertThat(hunter.action).isNotNull()
    assertThat(hunter.actions).isNotNull()
    assertThat(hunter.actions).isEmpty()
    hunter.detach(action)
    assertThat(hunter.action).isNull()
  }

  @Test fun cancelSingleRequest() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  @Test fun cancelMultipleRequests() {
    val action1 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val action2 = mockAction(URI_KEY_1, URI_1, mockImageViewTarget())
    val hunter = TestableBitmapHunter(picasso, dispatcher, cache, action1)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.attach(action2)
    assertThat(hunter.isCancelled).isFalse()
    assertThat(hunter.cancel()).isFalse()
    hunter.detach(action1)
    hunter.detach(action2)
    assertThat(hunter.cancel()).isTrue()
    assertThat(hunter.isCancelled).isTrue()
  }

  

  @Test fun forContentProviderRequest() {
    val action = mockAction(CONTENT_KEY_1, CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(ContentStreamRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContentStreamRequestHandler::class.java)
  }

  @Test fun forMediaStoreRequest() {
    val action = mockAction(MEDIA_STORE_CONTENT_KEY_1, MEDIA_STORE_CONTENT_1_URL)
    val hunter = forRequest(
      mockPicasso(MediaStoreRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(MediaStoreRequestHandler::class.java)
  }

  @Test fun forContactsPhotoRequest() {
    val action = mockAction(CONTACT_KEY_1, CONTACT_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forContactsThumbnailPhotoRequest() {
    val action = mockAction(CONTACT_PHOTO_KEY_1, CONTACT_PHOTO_URI_1)
    val hunter = forRequest(
      mockPicasso(ContactsPhotoRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ContactsPhotoRequestHandler::class.java)
  }

  @Test fun forNetworkRequest() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isSameInstanceAs(requestHandler)
  }

  @Test fun forFileWithAuthorityRequest() {
    val action = mockAction(FILE_KEY_1, FILE_1_URL)
    val hunter = forRequest(
      mockPicasso(FileRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceRequest() {
    val resources = mockResources(BITMAP_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithId() {
    val action = mockAction(RESOURCE_ID_URI_KEY, RESOURCE_ID_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidBitmapResourceUriWithType() {
    val action = mockAction(RESOURCE_TYPE_URI_KEY, RESOURCE_TYPE_URI)
    val hunter = forRequest(
      mockPicasso(ResourceRequestHandler(context)), dispatcher, cache, action
    )
    assertThat(hunter.requestHandler).isInstanceOf(ResourceRequestHandler::class.java)
  }

  @Test fun forAndroidXmlResourceRequest() {
    val resources = mockResources(XML_RESOURCE_VALUE)
    `when`(context.resources).thenReturn(resources)
    val action = mockAction(key = RESOURCE_ID_KEY_1, resourceId = RESOURCE_ID_1)
    val requestHandler =
      ResourceDrawableRequestHandler.create(context, makeLoaderWithDrawable(null))
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(ResourceDrawableRequestHandler::class.java)
  }

  @Test fun forAssetRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val hunter = forRequest(mockPicasso(AssetRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(AssetRequestHandler::class.java)
  }

  @Test fun forFileWithNoPathSegments() {
    val action = mockAction("keykeykey", Uri.fromFile(File("/")))
    val hunter = forRequest(mockPicasso(FileRequestHandler(context)), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(FileRequestHandler::class.java)
  }

  @Test fun forCustomRequest() {
    val action = mockAction(CUSTOM_URI_KEY, CUSTOM_URI)
    val hunter = forRequest(mockPicasso(CustomRequestHandler()), dispatcher, cache, action)
    assertThat(hunter.requestHandler).isInstanceOf(CustomRequestHandler::class.java)
  }

  @Test fun forOverrideRequest() {
    val action = mockAction(ASSET_KEY_1, ASSET_URI_1)
    val handler = AssetRequestHandler(context)
    val handlers = listOf(handler)
    val eventListeners = emptyList<EventListener>()
    
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null, NO_TRANSFORMERS,
      handlers, eventListeners, ARGB_8888, false, false
    )
    val hunter = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter.requestHandler).isEqualTo(handler)
  }

  @Test fun sequenceIsIncremented() {
    val action = mockAction(URI_KEY_1, URI_1)
    val picasso = mockPicasso()
    val hunter1 = forRequest(picasso, dispatcher, cache, action)
    val hunter2 = forRequest(picasso, dispatcher, cache, action)
    assertThat(hunter2.sequence).isGreaterThan(hunter1.sequence)
  }

  @Test fun getPriorityWithNoRequests() {
    val action = mockAction(URI_KEY_1, URI_1)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    hunter.detach(action)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(LOW)
  }

  @Test fun getPriorityWithSingleRequest() {
    val action = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action)
    assertThat(hunter.action).isEqualTo(action)
    assertThat(hunter.actions).isNull()
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityWithMultipleRequests() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
  }

  @Test fun getPriorityAfterDetach() {
    val action1 = mockAction(key = URI_KEY_1, uri = URI_1, priority = NORMAL)
    val action2 = mockAction(key = URI_KEY_1, uri = URI_1, priority = HIGH)
    val requestHandler = NetworkRequestHandler(UNUSED_CALL_FACTORY)
    val hunter = forRequest(mockPicasso(requestHandler), dispatcher, cache, action1)
    hunter.attach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(hunter.priority).isEqualTo(HIGH)
    hunter.detach(action2)
    assertThat(hunter.action).isEqualTo(action1)
    assertThat(hunter.actions).isEmpty()
    assertThat(hunter.priority).isEqualTo(NORMAL)
  }

  @Test fun exifRotation() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifRotationSizing() {
    val data = Request.Builder(URI_1).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifRotationNoSizing() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ORIENTATION_ROTATE_90)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("rotate 90.0")
  }

  @Test fun rotation90Sizing() {
    val data = Request.Builder(URI_1).rotate(90f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun rotation180Sizing() {
    val data = Request.Builder(URI_1).rotate(180f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 0.5 1.0")
  }

  @Test fun rotation90WithPivotSizing() {
    val data = Request.Builder(URI_1).rotate(90f, 0f, 10f).resize(5, 10).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).contains("scale 1.0 0.5")
  }

  @Test fun exifVerticalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_VERTICAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 180.0")
  }

  @Test fun exifHorizontalFlip() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_FLIP_HORIZONTAL)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 180.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 90.0")
    assertThat(shadowMatrix.preOperations).doesNotContain("rotate 270.0")
  }

  @Test fun exifTranspose() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSPOSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
  }

  @Test fun exifTransverse() {
    val data = Request.Builder(URI_1).rotate(-45f).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, ExifInterface.ORIENTATION_TRANSVERSE)
    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.postOperations).containsExactly("scale -1.0 1.0")
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 270.0")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(20, 0).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun keepsAspectRationWhileResizingWhenDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(0, 10).build()
    val source = android.graphics.Bitmap.createBitmap(40, 20, ARGB_8888)

    val result = transformResult(request, source, 0)

    val shadowBitmap = shadowOf(result)
    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropResultMatchesTargetSize() {
    val request = Request.Builder(URI_1).resize(1080, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerCropResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerCrop().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredWidthIs0() {
    val request = Request.Builder(URI_1).resize(0, 642).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(642)
    assertThat(result.height).isEqualTo(642)
  }

  @Test fun centerInsideResultMatchesTargetSizeWhileDesiredHeightIs0() {
    val request = Request.Builder(URI_1).resize(1080, 0).centerInside().build()
    val source = android.graphics.Bitmap.createBitmap(640, 640, ARGB_8888)

    val result = transformResult(request, source, 0)

    assertThat(result.width).isEqualTo(1080)
    assertThat(result.height).isEqualTo(1080)
  }

  @Test fun exifRotationWithManualRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, ORIENTATION_ROTATE_90)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("rotate 90.0")
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun rotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0")
  }

  @Test fun pivotRotation() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).rotate(-45f, 10f, 10f).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.setOperations).containsEntry("rotate", "-45.0 10.0 10.0")
  }

  @Test fun resize() {
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(20, 15).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.0 1.5")
  }

  @Test fun centerCropTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(5)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 200, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(50)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerCropWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(5)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalLeft() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.LEFT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityHorizontalRight() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.RIGHT).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(10)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalTop() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.TOP).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWithGravityVerticalBottom() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 40).centerCrop(Gravity.BOTTOM).build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(0)
    assertThat(shadowBitmap.createdFromY).isEqualTo(10)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(10)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(10)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 4.0 4.0")
  }

  @Test fun centerCropWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(200, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerCrop().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)
    assertThat(shadowBitmap.createdFromX).isEqualTo(50)
    assertThat(shadowBitmap.createdFromY).isEqualTo(0)
    assertThat(shadowBitmap.createdFromWidth).isEqualTo(100)
    assertThat(shadowBitmap.createdFromHeight).isEqualTo(100)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideTallTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(20, 10, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideTallTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(100, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun centerInsideWideTooSmall() {
    val source = android.graphics.Bitmap.createBitmap(10, 20, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)
    assertThat(shadowMatrix.preOperations).containsExactly("scale 2.5 2.5")
  }

  @Test fun centerInsideWideTooLarge() {
    val source = android.graphics.Bitmap.createBitmap(50, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).centerInside().build()

    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalBigger() {
    val source = android.graphics.Bitmap.createBitmap(100, 100, ARGB_8888)
    val data = Request.Builder(URI_1).resize(50, 50).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.5 0.5")
  }

  @Test fun onlyScaleDownOriginalSmaller() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(100, 100).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
    assertThat(shadowBitmap.createdFromBitmap).isNotSameInstanceAs(source)
  }

  @Test fun onlyScaleDownOriginalSmallerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 60).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalSmallerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(60, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isNull()
  }

  @Test fun onlyScaleDownOriginalBiggerWidthIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(0, 40).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun onlyScaleDownOriginalBiggerHeightIs0() {
    val source = android.graphics.Bitmap.createBitmap(50, 50, ARGB_8888)
    val data = Request.Builder(URI_1).resize(40, 0).onlyScaleDown().build()
    val result = transformResult(data, source, 0)

    val shadowBitmap = shadowOf(result)
    assertThat(shadowBitmap.createdFromBitmap).isSameInstanceAs(source)

    val matrix = shadowBitmap.createdFromMatrix
    val shadowMatrix = shadowOf(matrix)

    assertThat(shadowMatrix.preOperations).containsExactly("scale 0.8 0.8")
  }

  @Test fun reusedBitmapIsNotRecycled() {
    val data = Request.Builder(URI_1).build()
    val source = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = transformResult(data, source, 0)
    assertThat(result).isSameInstanceAs(source)
    assertThat(result.isRecycled).isFalse()
  }

  @Test fun crashingOnTransformationThrows() {
    val badTransformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        throw NullPointerException("hello")
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} crashed with exception.")
    }
  }

  @Test fun recycledTransformationBitmapThrows() {
    val badTransformation: Transformation = object : Transformation {
      override fun transform(source: Bitmap): Bitmap {
        source.bitmap.recycle()
        return source
      }

      override fun key(): String {
        return "test"
      }
    }
    val transformations = listOf(badTransformation)
    val original = android.graphics.Bitmap.createBitmap(10, 10, ARGB_8888)
    val result = RequestHandler.Result.Bitmap(original, MEMORY, 0)
    val data = Request.Builder(URI_1).build()
    try {
      applyTransformations(picasso, data, transformations, result)
      shadowOf(Looper.getMainLooper()).idle()
      fail("Expected exception to be thrown.")
    } catch (e: RuntimeException) {
      assertThat(e)
        .hasMessageThat()
        .isEqualTo("Transformation ${badTransformation.key()} returned a recycled Bitmap.")
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  internal class TestableBitmapHunter @JvmOverloads constructor(
    picasso: Picasso,
    dispatcher: Dispatcher,
    cache: PlatformLruCache,
    action: Action,
    result: android.graphics.Bitmap? = null,
    exception: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ) : BitmapHunter(
    picasso, dispatcher, cache, action,
    TestableRequestHandler(result, exception, shouldRetry, supportsReplay)
  )

  private class TestableRequestHandler internal constructor(
    private val bitmap: android.graphics.Bitmap?,
    private val exception: Exception?,
    private val shouldRetry: Boolean,
    private val supportsReplay: Boolean
  ) : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return true
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      if (exception != null) {
        callback.onError(exception)
      } else {
        callback.onSuccess(Bitmap(bitmap!!, NETWORK))
      }
    }

    override val retryCount: Int
      get() = 1

    override fun shouldRetry(airplaneMode: Boolean, info: NetworkInfo?): Boolean {
      return shouldRetry
    }

    override fun supportsReplay(): Boolean {
      return supportsReplay
    }
  }

  private inner class CustomRequestHandler : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean {
      return CUSTOM_URI.scheme == data.uri!!.scheme
    }

    override fun load(picasso: Picasso, request: Request, callback: Callback) {
      callback.onSuccess(Result.Bitmap(bitmap, MEMORY))
    }
  }
}
<code block>

package com.squareup.picasso3

import android.Manifest.permission.ACCESS_NETWORK_STATE
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.HandlerThread
import android.os.Looper
import android.os.Message
import android.os.Process.THREAD_PRIORITY_BACKGROUND
import android.util.Log
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.NetworkPolicy.NO_CACHE
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.TAG
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.Utils.OWNER_DISPATCHER
import com.squareup.picasso3.Utils.VERB_CANCELED
import com.squareup.picasso3.Utils.VERB_DELIVERED
import com.squareup.picasso3.Utils.VERB_ENQUEUED
import com.squareup.picasso3.Utils.VERB_IGNORED
import com.squareup.picasso3.Utils.VERB_PAUSED
import com.squareup.picasso3.Utils.VERB_REPLAYING
import com.squareup.picasso3.Utils.VERB_RETRYING
import com.squareup.picasso3.Utils.flushStackLocalLeaks
import com.squareup.picasso3.Utils.getLogIdsForHunter
import com.squareup.picasso3.Utils.hasPermission
import com.squareup.picasso3.Utils.isAirplaneModeOn
import com.squareup.picasso3.Utils.log
import java.util.concurrent.ExecutorService

internal class Dispatcher internal constructor(
  private val context: Context,
  @JvmField internal val service: ExecutorService,
  private val mainThreadHandler: Handler,
  private val cache: PlatformLruCache
) {
  private val dispatcherThread: DispatcherThread
  internal val hunterMap = mutableMapOf<String, BitmapHunter>()
  internal val failedActions = mutableMapOf<Any, Action>()
  internal val pausedActions = mutableMapOf<Any, Action>()
  internal val pausedTags = mutableSetOf<Any>()
  private val handler: Handler
  internal val receiver: NetworkBroadcastReceiver
  private val scansNetworkChanges: Boolean

  @JvmField internal var airplaneMode = isAirplaneModeOn(context)

  init {
    dispatcherThread = DispatcherThread()
    dispatcherThread.start()
    val dispatcherThreadLooper = dispatcherThread.looper
    flushStackLocalLeaks(dispatcherThreadLooper)
    handler = DispatcherHandler(dispatcherThreadLooper, this)
    scansNetworkChanges = hasPermission(context, ACCESS_NETWORK_STATE)
    receiver = NetworkBroadcastReceiver(this)
    receiver.register()
  }

  fun shutdown() {
    
    (service as? PicassoExecutorService)?.shutdown()
    dispatcherThread.quit()
    
    Picasso.HANDLER.post { receiver.unregister() }
  }

  fun dispatchSubmit(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action))
  }

  fun dispatchCancel(action: Action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action))
  }

  fun dispatchPauseTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag))
  }

  fun dispatchResumeTag(tag: Any) {
    handler.sendMessage(handler.obtainMessage(TAG_RESUME, tag))
  }

  fun dispatchComplete(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter))
  }

  fun dispatchRetry(hunter: BitmapHunter) {
    handler.sendMessageDelayed(handler.obtainMessage(HUNTER_RETRY, hunter), RETRY_DELAY)
  }

  fun dispatchFailed(hunter: BitmapHunter) {
    handler.sendMessage(handler.obtainMessage(HUNTER_DECODE_FAILED, hunter))
  }

  fun dispatchNetworkStateChange(info: NetworkInfo) {
    handler.sendMessage(handler.obtainMessage(NETWORK_STATE_CHANGE, info))
  }

  fun dispatchAirplaneModeChange(airplaneMode: Boolean) {
    handler.sendMessage(
      handler.obtainMessage(
        AIRPLANE_MODE_CHANGE,
        if (airplaneMode) AIRPLANE_MODE_ON else AIRPLANE_MODE_OFF,
        0
      )
    )
  }

  @JvmOverloads
  fun performSubmit(action: Action, dismissFailed: Boolean = true) {
    if (action.tag in pausedTags) {
      pausedActions[action.getTarget()] = action
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_PAUSED,
          logId = action.request.logId(),
          extras = "because tag '${action.tag}' is paused"
        )
      }
      return
    }

    var hunter = hunterMap[action.request.key]
    if (hunter != null) {
      hunter.attach(action)
      return
    }

    if (service.isShutdown) {
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_IGNORED,
          logId = action.request.logId(),
          extras = "because shut down"
        )
      }
      return
    }

    hunter = forRequest(action.picasso, this, cache, action)
    hunter.future = service.submit(hunter)
    hunterMap[action.request.key] = hunter
    if (dismissFailed) {
      failedActions.remove(action.getTarget())
    }

    if (action.picasso.loggingEnabled) {
      log(owner = OWNER_DISPATCHER, verb = VERB_ENQUEUED, logId = action.request.logId())
    }
  }

  fun performCancel(action: Action) {
    val key = action.request.key
    val hunter = hunterMap[key]
    if (hunter != null) {
      hunter.detach(action)
      if (hunter.cancel()) {
        hunterMap.remove(key)
        if (action.picasso.loggingEnabled) {
          log(OWNER_DISPATCHER, VERB_CANCELED, action.request.logId())
        }
      }
    }

    if (action.tag in pausedTags) {
      pausedActions.remove(action.getTarget())
      if (action.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_CANCELED,
          logId = action.request.logId(),
          extras = "because paused request got canceled"
        )
      }
    }

    val remove = failedActions.remove(action.getTarget())
    if (remove != null && remove.picasso.loggingEnabled) {
      log(OWNER_DISPATCHER, VERB_CANCELED, remove.request.logId(), "from replaying")
    }
  }

  fun performPauseTag(tag: Any) {
    
    if (!pausedTags.add(tag)) {
      return
    }

    
    
    val iterator = hunterMap.values.iterator()
    while(iterator.hasNext()) {
      val hunter = iterator.next()
      val loggingEnabled = hunter.picasso.loggingEnabled

      val single = hunter.action
      val joined = hunter.actions
      val hasMultiple = !joined.isNullOrEmpty()

      
      if (single == null && !hasMultiple) {
        continue
      }

      if (single != null && single.tag == tag) {
        hunter.detach(single)
        pausedActions[single.getTarget()] = single
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_PAUSED,
            logId = single.request.logId(),
            extras = "because tag '$tag' was paused"
          )
        }
      }

      if (joined != null) {
        for (i in joined.indices.reversed()) {
          val action = joined[i]
          if (action.tag != tag) {
            continue
          }
          hunter.detach(action)
          pausedActions[action.getTarget()] = action
          if (loggingEnabled) {
            log(
              owner = OWNER_DISPATCHER,
              verb = VERB_PAUSED,
              logId = action.request.logId(),
              extras = "because tag '$tag' was paused"
            )
          }
        }
      }

      
      
      if (hunter.cancel()) {
        iterator.remove()
        if (loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_CANCELED,
            logId = getLogIdsForHunter(hunter),
            extras = "all actions paused"
          )
        }
      }
    }
  }

  fun performResumeTag(tag: Any) {
    
    if (!pausedTags.remove(tag)) {
      return
    }

    val batch = mutableListOf<Action>()
    val iterator = pausedActions.values.iterator()
    while (iterator.hasNext()) {
      val action = iterator.next()
      if (action.tag == tag) {
        batch += action
        iterator.remove()
      }
    }

    if (batch.isNotEmpty()) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch))
    }
  }

  @SuppressLint("MissingPermission")
  fun performRetry(hunter: BitmapHunter) {
    if (hunter.isCancelled) return

    if (service.isShutdown) {
      performError(hunter)
      return
    }

    var networkInfo: NetworkInfo? = null
    if (scansNetworkChanges) {
      val connectivityManager =
        ContextCompat.getSystemService(context, ConnectivityManager::class.java)
      if (connectivityManager != null) {
        networkInfo = connectivityManager.activeNetworkInfo
      }
    }

    if (hunter.shouldRetry(airplaneMode, networkInfo)) {
      if (hunter.picasso.loggingEnabled) {
        log(
          owner = OWNER_DISPATCHER,
          verb = VERB_RETRYING,
          logId = getLogIdsForHunter(hunter)
        )
      }
      if (hunter.exception is ContentLengthException) {
        hunter.data = hunter.data.newBuilder().networkPolicy(NO_CACHE).build()
      }
      hunter.future = service.submit(hunter)
    } else {
      performError(hunter)
      
      if (scansNetworkChanges && hunter.supportsReplay()) {
        markForReplay(hunter)
      }
    }
  }

  fun performComplete(hunter: BitmapHunter) {
    if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
      val result = hunter.result
      if (result != null) {
        if (result is Bitmap) {
          val bitmap = result.bitmap
          cache[hunter.key] = bitmap
        }
      }
    }
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performError(hunter: BitmapHunter) {
    hunterMap.remove(hunter.key)
    deliver(hunter)
  }

  fun performAirplaneModeChange(airplaneMode: Boolean) {
    this.airplaneMode = airplaneMode
  }

  fun performNetworkStateChange(info: NetworkInfo?) {
    
    if (info != null && info.isConnected) {
      flushFailedActions()
    }
  }

  private fun flushFailedActions() {
    if (failedActions.isNotEmpty()) {
      val iterator = failedActions.values.iterator()
      while (iterator.hasNext()) {
        val action = iterator.next()
        iterator.remove()
        if (action.picasso.loggingEnabled) {
          log(
            owner = OWNER_DISPATCHER,
            verb = VERB_REPLAYING,
            logId = action.request.logId()
          )
        }
        performSubmit(action, false)
      }
    }
  }

  private fun markForReplay(hunter: BitmapHunter) {
    val action = hunter.action
    action?.let { markForReplay(it) }
    val joined = hunter.actions
    if (joined != null) {
      for (i in joined.indices) {
        markForReplay(joined[i])
      }
    }
  }

  private fun markForReplay(action: Action) {
    val target = action.getTarget()
    action.willReplay = true
    failedActions[target] = action
  }

  private fun deliver(hunter: BitmapHunter) {
    if (hunter.isCancelled) {
      return
    }
    val result = hunter.result
    if (result != null) {
      if (result is Bitmap) {
        val bitmap = result.bitmap
        bitmap.prepareToDraw()
      }
    }

    val message = mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter)
    if (hunter.priority == HIGH) {
      mainThreadHandler.sendMessageAtFrontOfQueue(message)
    } else {
      mainThreadHandler.sendMessage(message)
    }
    logDelivery(hunter)
  }

  private fun logDelivery(bitmapHunter: BitmapHunter) {
    val picasso = bitmapHunter.picasso
    if (picasso.loggingEnabled) {
      log(
        owner = OWNER_DISPATCHER,
        verb = VERB_DELIVERED,
        logId = getLogIdsForHunter(bitmapHunter)
      )
    }
  }

  private class DispatcherHandler(
    looper: Looper,
    private val dispatcher: Dispatcher
  ) : Handler(looper) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        REQUEST_SUBMIT -> {
          val action = msg.obj as Action
          dispatcher.performSubmit(action)
        }
        REQUEST_CANCEL -> {
          val action = msg.obj as Action
          dispatcher.performCancel(action)
        }
        TAG_PAUSE -> {
          val tag = msg.obj
          dispatcher.performPauseTag(tag)
        }
        TAG_RESUME -> {
          val tag = msg.obj
          dispatcher.performResumeTag(tag)
        }
        HUNTER_COMPLETE -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performComplete(hunter)
        }
        HUNTER_RETRY -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performRetry(hunter)
        }
        HUNTER_DECODE_FAILED -> {
          val hunter = msg.obj as BitmapHunter
          dispatcher.performError(hunter)
        }
        NETWORK_STATE_CHANGE -> {
          val info = msg.obj as NetworkInfo
          dispatcher.performNetworkStateChange(info)
        }
        AIRPLANE_MODE_CHANGE -> {
          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON)
        }
        else -> {
          Picasso.HANDLER.post {
            throw AssertionError("Unknown handler message received: ${msg.what}")
          }
        }
      }
    }
  }

  internal class DispatcherThread : HandlerThread(
    Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME,
    THREAD_PRIORITY_BACKGROUND
  )

  internal class NetworkBroadcastReceiver(
    private val dispatcher: Dispatcher
  ) : BroadcastReceiver() {
    fun register() {
      val filter = IntentFilter()
      filter.addAction(ACTION_AIRPLANE_MODE_CHANGED)
      if (dispatcher.scansNetworkChanges) {
        filter.addAction(CONNECTIVITY_ACTION)
      }
      dispatcher.context.registerReceiver(this, filter)
    }

    fun unregister() {
      dispatcher.context.unregisterReceiver(this)
    }

    @SuppressLint("MissingPermission")
    override fun onReceive(context: Context, intent: Intent?) {
      
      
      if (intent == null) {
        return
      }
      when (intent.action) {
        ACTION_AIRPLANE_MODE_CHANGED -> {
          if (!intent.hasExtra(EXTRA_AIRPLANE_STATE)) {
            return  
          }
          dispatcher.dispatchAirplaneModeChange(intent.getBooleanExtra(EXTRA_AIRPLANE_STATE, false))
        }
        CONNECTIVITY_ACTION -> {
          val connectivityManager =
            ContextCompat.getSystemService(context, ConnectivityManager::class.java)
          val networkInfo = try {
            connectivityManager!!.activeNetworkInfo
          } catch (re: RuntimeException) {
            Log.w(TAG, "System UI crashed, ignoring attempt to change network state.")
            return
          }
          if (networkInfo == null) {
            Log.w(
              TAG,
              "No default network is currently active, ignoring attempt to change network state."
            )
            return
          }
          dispatcher.dispatchNetworkStateChange(networkInfo)
        }
      }
    }

    internal companion object {
      const val EXTRA_AIRPLANE_STATE = "state"
    }
  }

  internal companion object {
    private const val RETRY_DELAY = 500L
    private const val AIRPLANE_MODE_ON = 1
    private const val AIRPLANE_MODE_OFF = 0
    private const val REQUEST_SUBMIT = 1
    private const val REQUEST_CANCEL = 2
    const val HUNTER_COMPLETE = 4
    private const val HUNTER_RETRY = 5
    private const val HUNTER_DECODE_FAILED = 6
    const val NETWORK_STATE_CHANGE = 9
    private const val AIRPLANE_MODE_CHANGE = 10
    private const val TAG_PAUSE = 11
    private const val TAG_RESUME = 12
    const val REQUEST_BATCH_RESUME = 13
    private const val DISPATCHER_THREAD_NAME = "Dispatcher"
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.Intent
import android.content.Intent.ACTION_AIRPLANE_MODE_CHANGED
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.ConnectivityManager
import android.net.ConnectivityManager.CONNECTIVITY_ACTION
import android.net.NetworkInfo
import android.os.Handler
import android.os.Looper.getMainLooper
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockAction
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockTarget
import com.squareup.picasso3.TestUtils.mockHunter
import com.squareup.picasso3.TestUtils.mockNetworkInfo
import org.robolectric.RobolectricTestRunner
import org.mockito.Mock
import com.squareup.picasso3.TestUtils.TestDelegatingService
import com.squareup.picasso3.NetworkRequestHandler.ContentLengthException
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver
import com.squareup.picasso3.Dispatcher.NetworkBroadcastReceiver.Companion.EXTRA_AIRPLANE_STATE
import com.squareup.picasso3.MemoryPolicy.NO_STORE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_2
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.URI_KEY_2
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.anyString
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.Shadows.shadowOf
import java.lang.AssertionError
import java.lang.Exception
import java.util.concurrent.ExecutorService
import java.util.concurrent.FutureTask

@RunWith(RobolectricTestRunner::class)
class DispatcherTest {
  @Mock lateinit var context: Context
  @Mock lateinit var connectivityManager: ConnectivityManager
  @Mock lateinit var serviceMock: ExecutorService

  private lateinit var picasso: Picasso
  private lateinit var dispatcher: Dispatcher

  private val cache = PlatformLruCache(2048)
  private val service = TestDelegatingService(PicassoExecutorService())
  private val bitmap1 = makeBitmap()

  @Before fun setUp() {
    initMocks(this)
    `when`(context.applicationContext).thenReturn(context)
    picasso = mockPicasso(context)
    dispatcher = createDispatcher(service)
  }

  @Test fun shutdownStopsService() {
    val service = PicassoExecutorService()
    dispatcher = createDispatcher(service)
    dispatcher.shutdown()
    assertThat(service.isShutdown).isEqualTo(true)
  }

  @Test fun shutdownUnregistersReceiver() {
    dispatcher.shutdown()
    shadowOf(getMainLooper()).idle()
    verify(context).unregisterReceiver(dispatcher.receiver)
  }

  @Test fun performSubmitWithNewRequestQueuesHunter() {
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithTwoDifferentRequestsQueuesHunters() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.performSubmit(action1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(2)
    assertThat(service.submissions).isEqualTo(2)
  }

  @Test fun performSubmitWithExistingRequestAttachesToHunter() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action1)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
    dispatcher.performSubmit(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performSubmitWithShutdownServiceIgnoresRequest() {
    service.shutdown()
    val action = mockAction(picasso, URI_KEY_1, URI_1)
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performSubmitWithFetchAction() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    
    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    val fetchAction2 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), null)
    dispatcher.performSubmit(fetchAction1)
    dispatcher.performSubmit(fetchAction2)

    assertThat(dispatcher.pausedActions).hasSize(2)
  }

  @Test fun performCancelWithFetchActionWithCallback() {
    val pausedTag = "pausedTag"
    dispatcher.pausedTags.add(pausedTag)
    assertThat(dispatcher.pausedActions).isEmpty()
    val callback = mockCallback()

    val fetchAction1 = FetchAction(picasso, Request.Builder(URI_1).tag(pausedTag).build(), callback)
    dispatcher.performCancel(fetchAction1)
    fetchAction1.cancel()
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCancelDetachesRequestAndCleansUp() {
    val target = mockTarget()
    val action = mockAction(picasso, URI_KEY_1, URI_1, target)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.failedActions[target] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performCancelMultipleRequestsDetachesOnly() {
    val action1 = mockAction(picasso, URI_KEY_1, URI_1)
    val action2 = mockAction(picasso, URI_KEY_1, URI_1)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.performCancel(action1)
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
    assertThat(dispatcher.hunterMap).hasSize(1)
  }

  @Test fun performCancelUnqueuesAndDetachesPausedRequest() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1 + Request.KEY_SEPARATOR] = hunter
    dispatcher.pausedTags.add("tag")
    dispatcher.pausedActions[action.getTarget()] = action
    dispatcher.performCancel(action)
    assertThat(hunter.action).isNull()
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    assertThat(dispatcher.pausedActions).isEmpty()
  }

  @Test fun performCompleteSetsResultInCache() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(hunter.result).isInstanceOf(RequestHandler.Result.Bitmap::class.java)
    val result = hunter.result as RequestHandler.Result.Bitmap
    assertThat(result.bitmap).isEqualTo(bitmap1)
    assertThat(result.loadedFrom).isEqualTo(NETWORK)
    assertThat(cache[hunter.key]).isSameInstanceAs(bitmap1)
  }

  @Test fun performCompleteWithNoStoreMemoryPolicy() {
    val data = Request.Builder(URI_1).memoryPolicy(NO_STORE).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    assertThat(cache.size()).isEqualTo(0)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(cache.size()).isEqualTo(0)
  }

  @Test fun performCompleteCleansUpAndPostsToMain() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performCompleteCleansUpAndDoesNotPostToMainIfCancelled() {
    val data = Request.Builder(URI_1).build()
    val action = noopAction(data)
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.run()
    hunter.future = FutureTask<Any>(mock(Runnable::class.java), null)
    hunter.future!!.cancel(false)

    dispatcher.performComplete(hunter)

    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndPostsToMain() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performErrorCleansUpAndDoesNotPostToMainIfCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.hunterMap[hunter.key] = hunter
    dispatcher.performError(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    
  }

  @Test fun performRetrySkipsIfHunterIsCancelled() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    hunter.future!!.cancel(false)
    dispatcher.performRetry(hunter)
    assertThat(hunter.isCancelled).isTrue()
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performRetryForContentLengthResetsNetworkPolicy() {
    val networkInfo = mockNetworkInfo(true)
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    val action = mockAction(picasso, URI_KEY_2, URI_2)
    val e = ContentLengthException("304 error")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action, e, true)
    hunter.run()
    dispatcher.performRetry(hunter)
    assertThat(NetworkPolicy.shouldReadFromDiskCache(hunter.data.networkPolicy)).isFalse()
  }

  @Test fun performRetryDoesNotMarkForReplayIfNotSupported() {
    val networkInfo = mockNetworkInfo(true)
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1)
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryDoesNotMarkForReplayIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = false, supportsReplay = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryMarksForReplayIfSupportedScansNetworkChangesAndShouldNotRetry() {
    val networkInfo = mockNetworkInfo(true)
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfNoNetworkScanning() {
    val hunter = mockHunter(
      picasso,
      RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      mockAction(picasso, URI_KEY_1, URI_1),
      e = null, shouldRetry = true
    )
    val dispatcher = createDispatcher(false)
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetryMarksForReplayIfSupportsReplayAndShouldNotRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = false, supportsReplay = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).hasSize(1)
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performRetryRetriesIfShouldRetry() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(
      picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action,
      e = null, shouldRetry = true
    )
    dispatcher.performRetry(hunter)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performRetrySkipIfServiceShutdown() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget())
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    service.shutdown()
    dispatcher.performRetry(hunter)
    assertThat(service.submissions).isEqualTo(0)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performAirplaneModeChange() {
    assertThat(dispatcher.airplaneMode).isFalse()
    dispatcher.performAirplaneModeChange(true)
    assertThat(dispatcher.airplaneMode).isTrue()
    dispatcher.performAirplaneModeChange(false)
    assertThat(dispatcher.airplaneMode).isFalse()
  }

  @Test fun performNetworkStateChangeWithNullInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    dispatcher.performNetworkStateChange(null)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithDisconnectedInfoIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo()
    `when`(info.isConnectedOrConnecting).thenReturn(false)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performNetworkStateChangeWithConnectedInfoDifferentInstanceIgnores() {
    val dispatcher = createDispatcher(serviceMock)
    val info = mockNetworkInfo(true)
    dispatcher.performNetworkStateChange(info)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun performPauseAndResumeUpdatesListOfPausedTags() {
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedTags).containsExactly("tag")
    dispatcher.performResumeTag("tag")
    assertThat(dispatcher.pausedTags).isEmpty()
  }

  @Test fun performPauseTagIsIdempotent() {
    val action = mockAction(picasso, URI_KEY_1, URI_1, mockTarget(), tag = "tag")
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    assertThat(dispatcher.pausedActions).isEmpty()
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.pausedActions).containsEntry(action.getTarget(), action)
  }

  @Test fun performPauseTagQueuesNewRequestDoesNotSubmit() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(service.submissions).isEqualTo(0)
  }

  @Test fun performPauseTagDoesNotQueueUnrelatedRequest() {
    dispatcher.performPauseTag("tag")
    val action = mockAction(picasso, URI_KEY_1, URI_1, "anothertag")
    dispatcher.performSubmit(action)
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.pausedActions).isEmpty()
    assertThat(service.submissions).isEqualTo(1)
  }

  @Test fun performPauseDetachesRequestAndCancelsHunter() {
    val action = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, tag = "tag"
    )
    val hunter = mockHunter(
      picasso = picasso,
      result = RequestHandler.Result.Bitmap(bitmap1, MEMORY),
      action = action,
      dispatcher = dispatcher
    )
    hunter.future = FutureTask(mock(Runnable::class.java), mock(Any::class.java))
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag")
    assertThat(dispatcher.hunterMap).isEmpty()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action)).isTrue()
    assertThat(hunter.action).isNull()
  }

  @Test fun performPauseOnlyDetachesPausedRequest() {
    val action1 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag1"
    )
    val action2 = mockAction(
      picasso = picasso, key = URI_KEY_1, uri = URI_1, target = mockTarget(), tag = "tag2"
    )
    val hunter = mockHunter(picasso, RequestHandler.Result.Bitmap(bitmap1, MEMORY), action1)
    hunter.attach(action2)
    dispatcher.hunterMap[URI_KEY_1] = hunter
    dispatcher.performPauseTag("tag1")
    assertThat(dispatcher.hunterMap).hasSize(1)
    assertThat(dispatcher.hunterMap.containsValue(hunter)).isTrue()
    assertThat(dispatcher.pausedActions).hasSize(1)
    assertThat(dispatcher.pausedActions.containsValue(action1)).isTrue()
    assertThat(hunter.action).isNull()
    assertThat(hunter.actions).containsExactly(action2)
  }

  @Test fun performResumeTagIsIdempotent() {
    dispatcher.performResumeTag("tag")
    
  }

  @Test fun performNetworkStateChangeFlushesFailedHunters() {
    val info = mockNetworkInfo(true)
    val failedAction1 = mockAction(picasso, URI_KEY_1, URI_1)
    val failedAction2 = mockAction(picasso, URI_KEY_2, URI_2)
    dispatcher.failedActions[URI_KEY_1] = failedAction1
    dispatcher.failedActions[URI_KEY_2] = failedAction2
    dispatcher.performNetworkStateChange(info)
    assertThat(service.submissions).isEqualTo(2)
    assertThat(dispatcher.failedActions).isEmpty()
  }

  @Test fun nullIntentOnReceiveDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, null)
    verifyZeroInteractions(dispatcher)
  }

  @Test fun nullExtrasOnReceiveConnectivityAreOk() {
    val connectivityManager = mock(ConnectivityManager::class.java)
    val networkInfo = mockNetworkInfo()
    `when`(connectivityManager.activeNetworkInfo).thenReturn(networkInfo)
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(CONNECTIVITY_ACTION))
    verify(dispatcher).dispatchNetworkStateChange(networkInfo)
  }

  @Test fun nullExtrasOnReceiveAirplaneDoesNothing() {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    receiver.onReceive(context, Intent(ACTION_AIRPLANE_MODE_CHANGED))
    verifyZeroInteractions(dispatcher)
  }

  @Test fun correctExtrasOnReceiveAirplaneDispatches() {
    setAndVerifyAirplaneMode(false)
    setAndVerifyAirplaneMode(true)
  }

  private fun setAndVerifyAirplaneMode(airplaneOn: Boolean) {
    val dispatcher = mock(Dispatcher::class.java)
    val receiver = NetworkBroadcastReceiver(dispatcher)
    val intent = Intent(ACTION_AIRPLANE_MODE_CHANGED)
    intent.putExtra(EXTRA_AIRPLANE_STATE, airplaneOn)
    receiver.onReceive(context, intent)
    verify(dispatcher).dispatchAirplaneModeChange(airplaneOn)
  }

  private fun createDispatcher(scansNetworkChanges: Boolean): Dispatcher {
    return createDispatcher(service, scansNetworkChanges)
  }

  private fun createDispatcher(
    service: ExecutorService,
    scansNetworkChanges: Boolean = true
  ): Dispatcher {
    `when`(connectivityManager.activeNetworkInfo).thenReturn(
      if (scansNetworkChanges) mock(NetworkInfo::class.java) else null
    )
    `when`(context.getSystemService(CONNECTIVITY_SERVICE)).thenReturn(connectivityManager)
    `when`(context.checkCallingOrSelfPermission(anyString())).thenReturn(
      if (scansNetworkChanges) PERMISSION_GRANTED else PERMISSION_DENIED
    )
    return Dispatcher(context, service, Handler(getMainLooper()), cache)
  }

  private fun noopAction(data: Request): Action {
    return object : Action(picasso, data) {
      override fun complete(result: RequestHandler.Result) = Unit
      override fun error(e: Exception) = Unit
      override fun getTarget(): Any = throw AssertionError()
    }
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false,
    dispatcher: Dispatcher = mock(Dispatcher::class.java),
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = dispatcher,
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable?): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.app.Notification
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.net.Uri
import android.view.Gravity
import android.widget.ImageView
import android.widget.RemoteViews
import androidx.annotation.DimenRes
import androidx.annotation.DrawableRes
import androidx.annotation.IdRes
import androidx.core.content.ContextCompat
import com.squareup.picasso3.BitmapHunter.Companion.forRequest
import com.squareup.picasso3.MemoryPolicy.Companion.shouldReadFromMemoryCache
import com.squareup.picasso3.MemoryPolicy.Companion.shouldWriteToMemoryCache
import com.squareup.picasso3.Picasso.LoadedFrom
import com.squareup.picasso3.PicassoDrawable.Companion.setPlaceholder
import com.squareup.picasso3.PicassoDrawable.Companion.setResult
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.Utils.OWNER_MAIN
import com.squareup.picasso3.Utils.VERB_COMPLETED
import com.squareup.picasso3.Utils.checkMain
import com.squareup.picasso3.Utils.checkNotMain
import com.squareup.picasso3.Utils.log
import java.io.IOException
import java.util.concurrent.atomic.AtomicInteger


class RequestCreator internal constructor(
  private val picasso: Picasso,
  uri: Uri?,
  resourceId: Int
) {
  private val data = Request.Builder(uri, resourceId, picasso.defaultBitmapConfig)

  private var noFade = false
  private var deferred = false
  private var setPlaceholder = true
  @DrawableRes private var placeholderResId = 0
  @DrawableRes private var errorResId = 0
  private var placeholderDrawable: Drawable? = null
  private var errorDrawable: Drawable? = null

  
  @get:JvmName("-tag")
  internal val tag: Any?
    get() = data.tag

  init {
    check(!picasso.shutdown) { "Picasso instance already shut down. Cannot submit new requests." }
  }

  
  fun noPlaceholder(): RequestCreator {
    check(placeholderResId == 0) { "Placeholder resource already set." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    setPlaceholder = false
    return this
  }

  
  fun placeholder(@DrawableRes placeholderResId: Int): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    require(placeholderResId != 0) { "Placeholder image resource invalid." }
    check(placeholderDrawable == null) { "Placeholder image already set." }
    this.placeholderResId = placeholderResId
    return this
  }

  
  fun placeholder(placeholderDrawable: Drawable): RequestCreator {
    check(setPlaceholder) { "Already explicitly declared as no placeholder." }
    check(placeholderResId == 0) { "Placeholder image already set." }
    this.placeholderDrawable = placeholderDrawable
    return this
  }

  
  fun error(@DrawableRes errorResId: Int): RequestCreator {
    require(errorResId != 0) { "Error image resource invalid." }
    check(errorDrawable == null) { "Error image already set." }
    this.errorResId = errorResId
    return this
  }

  
  fun error(errorDrawable: Drawable): RequestCreator {
    check(errorResId == 0) { "Error image already set." }
    this.errorDrawable = errorDrawable
    return this
  }

  
  fun tag(tag: Any): RequestCreator {
    data.tag(tag)
    return this
  }

  
  fun fit(): RequestCreator {
    deferred = true
    return this
  }

  
  @JvmName("-unfit")
  internal fun unfit(): RequestCreator {
    deferred = false
    return this
  }

  
  @JvmName("-clearTag")
  internal fun clearTag(): RequestCreator {
    data.clearTag()
    return this
  }

  
  fun resizeDimen(
    @DimenRes targetWidthResId: Int,
    @DimenRes targetHeightResId: Int,
  ): RequestCreator {
    val resources = picasso.context.resources
    val targetWidth = resources.getDimensionPixelSize(targetWidthResId)
    val targetHeight = resources.getDimensionPixelSize(targetHeightResId)
    return resize(targetWidth, targetHeight)
  }

  
  fun resize(targetWidth: Int, targetHeight: Int): RequestCreator {
    data.resize(targetWidth, targetHeight)
    return this
  }

  
  fun centerCrop(): RequestCreator {
    data.centerCrop(Gravity.CENTER)
    return this
  }

  
  fun centerCrop(alignGravity: Int): RequestCreator {
    data.centerCrop(alignGravity)
    return this
  }

  
  fun centerInside(): RequestCreator {
    data.centerInside()
    return this
  }

  
  fun onlyScaleDown(): RequestCreator {
    data.onlyScaleDown()
    return this
  }

  
  fun rotate(degrees: Float): RequestCreator {
    data.rotate(degrees)
    return this
  }

  
  fun rotate(degrees: Float, pivotX: Float, pivotY: Float): RequestCreator {
    data.rotate(degrees, pivotX, pivotY)
    return this
  }

  
  fun config(config: Bitmap.Config): RequestCreator {
    data.config(config)
    return this
  }

  
  fun stableKey(stableKey: String): RequestCreator {
    data.stableKey(stableKey)
    return this
  }

  
  fun priority(priority: Picasso.Priority): RequestCreator {
    data.priority(priority)
    return this
  }

  
  
  fun transform(transformation: Transformation): RequestCreator {
    data.transform(transformation)
    return this
  }

  
  fun transform(transformations: List<Transformation>): RequestCreator {
    data.transform(transformations)
    return this
  }

  
  fun memoryPolicy(
    policy: MemoryPolicy,
    vararg additional: MemoryPolicy,
  ): RequestCreator {
    data.memoryPolicy(policy, *additional)
    return this
  }

  
  fun networkPolicy(
    policy: NetworkPolicy,
    vararg additional: NetworkPolicy,
  ): RequestCreator {
    data.networkPolicy(policy, *additional)
    return this
  }

  
  fun addHeader(key: String, value: String): RequestCreator {
    data.addHeader(key, value)
    return this
  }

  
  fun noFade(): RequestCreator {
    noFade = true
    return this
  }

  
  @Throws(IOException::class) 
  fun get(): Bitmap? {
    val started = System.nanoTime()
    checkNotMain()
    check(!deferred) { "Fit cannot be used with get." }
    if (!data.hasImage()) {
      return null
    }

    val request = createRequest(started)
    val action = GetAction(picasso, request)
    val result =
      forRequest(picasso, picasso.dispatcher, picasso.cache, action).hunt() ?: return null

    val bitmap = result.bitmap
    if (shouldWriteToMemoryCache(request.memoryPolicy)) {
      picasso.cache[request.key] = bitmap
    }

    return bitmap
  }
  
  @JvmOverloads fun fetch(callback: Callback? = null) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with fetch." }

    if (data.hasImage()) {
      
      if (!data.hasPriority()) {
        data.priority(Picasso.Priority.LOW)
      }

      val request = createRequest(started)
      if (shouldReadFromMemoryCache(request.memoryPolicy)) {
        val bitmap = picasso.quickMemoryCacheCheck(request.key)
        if (bitmap != null) {
          if (picasso.isLoggingEnabled) {
            log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
          }
          callback?.onSuccess()
          return
        }
      }

      val action = FetchAction(picasso, request, callback)
      picasso.submit(action)
    }
  }

  
  fun into(target: BitmapTarget) {
    val started = System.nanoTime()
    checkMain()
    check(!deferred) { "Fit cannot be used with a Target." }

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
      return
    }

    val request = createRequest(started)
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        target.onBitmapLoaded(bitmap, LoadedFrom.MEMORY)
        return
      }
    }

    target.onPrepareLoad(if (setPlaceholder) getPlaceholderDrawable() else null)
    val action = BitmapTargetAction(picasso, target, request, errorDrawable, errorResId)
    picasso.enqueueAndSubmit(action)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    notificationId: Int,
    notification: Notification,
    notificationTag: String? = null,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with RemoteViews." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = NotificationAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      notificationId,
      notification,
      notificationTag,
      callback
    )
    performRemoteViewInto(request, action)
  }

  
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetId: Int,
    callback: Callback? = null,
  ) {
    into(remoteViews, viewId, intArrayOf(appWidgetId), callback)
  }

  
  @JvmOverloads
  fun into(
    remoteViews: RemoteViews,
    @IdRes viewId: Int,
    appWidgetIds: IntArray,
    callback: Callback? = null,
  ) {
    val started = System.nanoTime()
    check(!deferred) { "Fit cannot be used with remote views." }
    require(!(placeholderDrawable != null || errorDrawable != null)) {
      "Cannot use placeholder or error drawables with remote views."
    }

    val request = createRequest(started)
    val action = AppWidgetAction(
      picasso,
      request,
      errorResId,
      RemoteViewsTarget(remoteViews, viewId),
      appWidgetIds,
      callback
    )

    performRemoteViewInto(request, action)
  }

  
  @JvmOverloads fun into(target: ImageView, callback: Callback? = null) {
    val started = System.nanoTime()
    checkMain()

    if (!data.hasImage()) {
      picasso.cancelRequest(target)
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable())
      }
      return
    }

    if (deferred) {
      check(!data.hasSize()) { "Fit cannot be used with resize." }
      val width = target.width
      val height = target.height
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable())
        }
        picasso.defer(target, DeferredRequestCreator(this, target, callback))
        return
      }
      data.resize(width, height)
    }

    val request = createRequest(started)

    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(request.key)
      if (bitmap != null) {
        picasso.cancelRequest(target)
        val result: RequestHandler.Result = RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY)
        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)
        if (picasso.isLoggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + LoadedFrom.MEMORY)
        }
        callback?.onSuccess()
        return
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable())
    }

    val action = ImageViewAction(
      picasso,
      target,
      request,
      errorDrawable,
      errorResId,
      noFade,
      callback
    )

    picasso.enqueueAndSubmit(action)
  }

  private fun getPlaceholderDrawable(): Drawable? {
    return if (placeholderResId == 0) {
      placeholderDrawable
    } else {
      ContextCompat.getDrawable(picasso.context, placeholderResId)
    }
  }

  
  private fun createRequest(started: Long): Request {
    val id = nextId.getAndIncrement()
    val request = data.build()
    request.id = id
    request.started = started

    val loggingEnabled = picasso.isLoggingEnabled
    if (loggingEnabled) {
      log(OWNER_MAIN, Utils.VERB_CREATED, request.plainId(), request.toString())
    }

    val transformed = picasso.transformRequest(request)
    if (transformed != request) {
      
      transformed.id = id
      transformed.started = started
      if (loggingEnabled) {
        log(OWNER_MAIN, Utils.VERB_CHANGED, transformed.logId(), "into $transformed")
      }
    }

    return transformed
  }

  private fun performRemoteViewInto(request: Request, action: RemoteViewsAction) {
    if (shouldReadFromMemoryCache(request.memoryPolicy)) {
      val bitmap = picasso.quickMemoryCacheCheck(action.request.key)
      if (bitmap != null) {
        action.complete(RequestHandler.Result.Bitmap(bitmap, LoadedFrom.MEMORY))
        return
      }
    }

    if (placeholderResId != 0) {
      action.setImageResource(placeholderResId)
    }

    picasso.enqueueAndSubmit(action)
  }

  private companion object {
    private val nextId = AtomicInteger()
  }
}

<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = picasso,
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  private val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
  private val picasso = spy(mockPicasso(RuntimeEnvironment.application))
  private val bitmap = makeBitmap()

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator(picasso).resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator(picasso).resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator(picasso).placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator(picasso).error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator(picasso).error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator(picasso).error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator(picasso).priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator(picasso).tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator(picasso).transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(picasso: Picasso) = RequestCreator(picasso, null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mockPicasso(RuntimeEnvironment.application),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mockPicasso(RuntimeEnvironment.application)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockPicasso
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  private val picasso = mockPicasso(RuntimeEnvironment.application)

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(picasso), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator(picasso).tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator(picasso)
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val spyPicasso = spy(picasso) 
    val creator = RequestCreator(spyPicasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    val actionCaptor = ArgumentCaptor.forClass(Action::class.java)
    verify(spyPicasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.widget.RemoteViews
import androidx.annotation.DrawableRes
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.NETWORK
import com.squareup.picasso3.RemoteViewsAction.RemoteViewsTarget
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyZeroInteractions
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class RemoteViewsActionTest {
  private lateinit var picasso: Picasso
  private lateinit var remoteViews: RemoteViews

  @Before fun setUp() {
    picasso = Picasso(
      RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY, null,
      PlatformLruCache(0), null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
      false, false
    )
    remoteViews = mock(RemoteViews::class.java)
    `when`(remoteViews.layoutId).thenReturn(android.R.layout.list_content)
  }

  @Test fun completeSetsBitmapOnRemoteViews() {
    val callback = mockCallback()
    val bitmap = makeBitmap()
    val action = createAction(callback)
    action.complete(RequestHandler.Result.Bitmap(bitmap, NETWORK))
    verify(remoteViews).setImageViewBitmap(1, bitmap)
    verify(callback).onSuccess()
  }

  @Test fun errorWithNoResourceIsNoop() {
    val callback = mockCallback()
    val action = createAction(callback)
    val e = RuntimeException()
    action.error(e)
    verifyZeroInteractions(remoteViews)
    verify(callback).onError(e)
  }

  @Test fun errorWithResourceSetsResource() {
    val callback = mockCallback()
    val action = createAction(callback, 1)
    val e = RuntimeException()
    action.error(e)
    verify(remoteViews).setImageViewResource(1, 1)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = mockImageViewTarget(),
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = mockCallback()
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  private fun createAction(callback: Callback, errorResId: Int = 0): TestableRemoteViewsAction {
    return TestableRemoteViewsAction(
      picasso = picasso,
      data = SIMPLE_REQUEST,
      errorResId = errorResId,
      target = RemoteViewsTarget(remoteViews, 1),
      callback = callback
    )
  }

  private class TestableRemoteViewsAction(
    picasso: Picasso, data: Request, @DrawableRes errorResId: Int,
    target: RemoteViewsTarget, callback: Callback?
  ) : RemoteViewsAction(picasso, data, errorResId, target, callback) {
    override fun update() {}
    override fun getTarget(): Any = target
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.MemoryPolicy.NO_CACHE
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority.HIGH
import com.squareup.picasso3.Picasso.Priority.LOW
import com.squareup.picasso3.Picasso.Priority.NORMAL
import com.squareup.picasso3.RemoteViewsAction.AppWidgetAction
import com.squareup.picasso3.RemoteViewsAction.NotificationAction
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.STABLE_1
import com.squareup.picasso3.TestUtils.STABLE_URI_KEY_1
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.URI_1
import com.squareup.picasso3.TestUtils.URI_KEY_1
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import com.squareup.picasso3.TestUtils.mockNotification
import com.squareup.picasso3.TestUtils.mockRemoteViews
import com.squareup.picasso3.TestUtils.mockRequestCreator
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyString
import org.mockito.ArgumentMatchers.eq
import org.mockito.Captor
import org.mockito.Mock
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doCallRealMethod
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.spy
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.Mockito.verifyZeroInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment
import org.robolectric.Shadows.shadowOf
import java.io.IOException
import java.util.concurrent.CountDownLatch

@RunWith(RobolectricTestRunner::class)
class RequestCreatorTest {
  @Mock private lateinit var picasso: Picasso
  @Captor private lateinit var actionCaptor: ArgumentCaptor<Action>

  private val bitmap = makeBitmap()

  @Before fun shutUp() {
    initMocks(this)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)
  }

  @Throws(IOException::class)
  @Test fun getOnMainCrashes() {
    try {
      RequestCreator(picasso, URI_1, 0).get()
      fail("Calling get() on main thread should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun loadWithShutdownCrashes() {
    picasso.shutdown = true
    try {
      RequestCreator(picasso, URI_1, 0).fetch()
      fail("Should have crashed with a shutdown picasso.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Throws(InterruptedException::class)
  @Test fun getReturnsNullIfNullUriAndResourceId() {
    val latch = CountDownLatch(1)
    val result = arrayOfNulls<Bitmap>(1)
    Thread {
      try {
        result[0] = RequestCreator(picasso, null, 0).get()
      } catch (e: IOException) {
        fail(e.message)
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
    
    assertThat(result[0]).isNull()
    verifyZeroInteractions(picasso)
  }

  @Test fun fetchSubmitsFetchRequest() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(FetchAction::class.java)
  }

  @Test fun fetchWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().fetch()
      fail("Calling fetch() with fit() should throw an exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun fetchWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(LOW)
  }

  @Test fun fetchWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).fetch()
    verify(picasso).submit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun fetchWithCache() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun fetchWithMemoryPolicyNoCache() {
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).fetch()
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
    verify(picasso).submit(actionCaptor.capture())
  }

  @Test fun intoTargetWithFitThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).fit().into(mockTarget())
      fail("Calling into() target with fit() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoPlaceholderCallsWithNull() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verify(target).onPrepareLoad(null)
  }

  @Test fun intoTargetWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, null, 0).placeholder(placeHolderDrawable).into(target)
    verify(picasso).cancelRequest(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verifyNoMoreInteractions(picasso)
  }

  @Test fun intoTargetWithQuickMemoryCacheCheckDoesNotSubmit() {
    `when`(picasso.quickMemoryCacheCheck(URI_KEY_1)).thenReturn(bitmap)
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(target).onBitmapLoaded(bitmap, MEMORY)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoTargetWithSkipMemoryPolicy() {
    val target = mockTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoTargetAndNotInCacheSubmitsTargetRequest() {
    val target = mockTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).onPrepareLoad(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(BitmapTargetAction::class.java)
  }

  @Test fun targetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun targetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun targetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun targetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoImageViewWithNullUriAndResourceIdSkipsAndCancels() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, null, 0).into(target)
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).quickMemoryCacheCheck(anyString())
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewWithQuickMemoryCacheCheckDoesNotSubmit() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    doReturn(bitmap).`when`(picasso).quickMemoryCacheCheck(URI_KEY_1)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    RequestCreator(picasso, URI_1, 0).into(target, callback)
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
    verify(picasso).cancelRequest(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
  }

  @Test fun intoImageViewSetsPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    val placeHolderDrawable = mock(Drawable::class.java)
    RequestCreator(picasso, URI_1, 0).placeholder(placeHolderDrawable).into(target)
    verify(target).setImageDrawable(placeHolderDrawable)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewNoPlaceholderDrawable() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).noPlaceholder().into(target)
    verifyNoMoreInteractions(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewSetsPlaceholderWithResourceId() {
    val cache = PlatformLruCache(0)
    val picasso = spy(
      Picasso(
        RuntimeEnvironment.application, mock(Dispatcher::class.java), UNUSED_CALL_FACTORY,
        null, cache, null, NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888,
        false, false
      )
    )
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).placeholder(android.R.drawable.picture_frame).into(target)
    val drawableCaptor = ArgumentCaptor.forClass(Drawable::class.java)
    verify(target).setImageDrawable(drawableCaptor.capture())
    assertThat(shadowOf(drawableCaptor.value).createdFromResId)
      .isEqualTo(android.R.drawable.picture_frame)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Throws(InterruptedException::class)
  @Test fun cancelNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).cancelRequest(any(BitmapTarget::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, null, 0).into(mockTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Throws(InterruptedException::class)
  @Test fun intoNotOnMainThreadCrashes() {
    doCallRealMethod().`when`(picasso).enqueueAndSubmit(any(Action::class.java))
    val latch = CountDownLatch(1)
    Thread {
      try {
        RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
        fail("Should have thrown IllegalStateException")
      } catch (ignored: IllegalStateException) {
      } finally {
        latch.countDown()
      }
    }.start()
    latch.await()
  }

  @Test fun intoImageViewAndNotInCacheSubmitsImageViewRequest() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithFitAndNoDimensionsQueuesDeferredImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso, never()).enqueueAndSubmit(any(Action::class.java))
    verify(picasso).defer(eq(target), any(DeferredRequestCreator::class.java))
  }

  @Test fun intoImageViewWithFitAndDimensionsQueuesImageViewRequest() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)
    RequestCreator(picasso, URI_1, 0).fit().into(target)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(ImageViewAction::class.java)
  }

  @Test fun intoImageViewWithSkipMemoryCachePolicy() {
    val target = mockImageViewTarget()
    RequestCreator(picasso, URI_1, 0).memoryPolicy(NO_CACHE).into(target)
    verify(picasso, never()).quickMemoryCacheCheck(URI_KEY_1)
  }

  @Test fun intoImageViewWithFitAndResizeThrows() {
    try {
      val target = mockImageViewTarget()
      RequestCreator(picasso, URI_1, 0).fit().resize(10, 10).into(target)
      fail("Calling into() ImageView with fit() and resize() should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun imageViewActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun imageViewActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun imageViewActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun imageViewActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag").into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun intoRemoteViewsWidgetQueuesAppWidgetAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(AppWidgetAction::class.java)
  }

  @Test fun intoRemoteViewsNotificationQueuesNotificationAction() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value).isInstanceOf(NotificationAction::class.java)
  }

  @Test fun intoRemoteViewsWidgetWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with placeholder drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithPlaceholderDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).placeholder(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithErrorDrawableThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).error(ColorDrawable(0))
        .into(mockRemoteViews(), 0, 0, mockNotification())
      fail("Calling into() with error drawable should throw exception")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun intoRemoteViewsWidgetWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, intArrayOf(1, 2, 3))
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoRemoteViewsNotificationWithFitThrows() {
    try {
      val remoteViews = mockRemoteViews()
      RequestCreator(picasso, URI_1, 0).fit().into(remoteViews, 1, 1, mockNotification())
      fail("Calling fit() into remote views should throw exception")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun intoTargetNoResizeWithCenterInsideOrCenterCropThrows() {
    try {
      RequestCreator(picasso, URI_1, 0).centerInside().into(mockTarget())
      fail("Center inside with unknown width should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      RequestCreator(picasso, URI_1, 0).centerCrop().into(mockTarget())
      fail("Center inside with unknown height should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun appWidgetActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun appWidgetActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun notificationActionWithDefaultPriority() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(NORMAL)
  }

  @Test fun notificationActionWithCustomPriority() {
    RequestCreator(picasso, URI_1, 0).priority(HIGH)
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.priority).isEqualTo(HIGH)
  }

  @Test fun appWidgetActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0).into(mockRemoteViews(), 0, intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun appWidgetActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(remoteViews = mockRemoteViews(), viewId = 0, appWidgetIds = intArrayOf(1, 2, 3))
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun notificationActionWithDefaultTag() {
    RequestCreator(picasso, URI_1, 0)
      .into(
        remoteViews = mockRemoteViews(),
        viewId = 0,
        notificationId = 0,
        notification = mockNotification()
      )
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo(actionCaptor.value)
  }

  @Test fun notificationActionWithCustomTag() {
    RequestCreator(picasso, URI_1, 0).tag("tag")
      .into(mockRemoteViews(), 0, 0, mockNotification())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.tag).isEqualTo("tag")
  }

  @Test fun invalidResize() {
    try {
      mockRequestCreator().resize(-1, 10)
      fail("Negative width should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(10, -1)
      fail("Negative height should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().resize(0, 0)
      fail("Zero dimensions should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
  }

  @Test fun invalidCenterCrop() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center crop after center inside should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidCenterInside() {
    try {
      mockRequestCreator().resize(10, 10).centerInside().centerCrop()
      fail("Calling center inside after center crop should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPlaceholderImage() {
    try {
      mockRequestCreator().placeholder(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().placeholder(1).placeholder(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).placeholder(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidNoPlaceholder() {
    try {
      mockRequestCreator().noPlaceholder().placeholder(ColorDrawable(0))
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().noPlaceholder().placeholder(1)
      fail("Placeholder after no placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(1).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().placeholder(ColorDrawable(0)).noPlaceholder()
      fail("No placeholder after placeholder should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidErrorImage() {
    try {
      mockRequestCreator().error(0)
      fail("Resource ID of zero should throw exception.")
    } catch (ignored: IllegalArgumentException) {
    }
    try {
      mockRequestCreator().error(1).error(ColorDrawable(0))
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
    try {
      mockRequestCreator().error(ColorDrawable(0)).error(1)
      fail("Two placeholders should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun invalidPriority() {
    try {
      mockRequestCreator().priority(LOW).priority(HIGH)
      fail("Two priorities should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun alreadySetTagThrows() {
    try {
      mockRequestCreator().tag("tag1").tag("tag2")
      fail("Two tags should throw exception.")
    } catch (ignored: IllegalStateException) {
    }
  }

  @Test fun transformationListImplementationValid() {
    val transformations = listOf(TestTransformation("test"))
    mockRequestCreator().transform(transformations)
    
  }

  @Test fun imageViewActionWithStableKey() {
    RequestCreator(picasso, URI_1, 0).stableKey(STABLE_1).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.key).isEqualTo(STABLE_URI_KEY_1)
  }

  @Test fun notPurgeable() {
    RequestCreator(picasso, URI_1, 0).into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isFalse()
  }

  @Test fun purgeable() {
    RequestCreator(picasso, URI_1, 0).purgeable().into(mockImageViewTarget())
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())
    assertThat(actionCaptor.value.request.purgeable).isTrue()
  }
}
<code block>

package com.squareup.picasso3

import android.app.Notification
import android.content.ContentResolver
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.PackageManager.NameNotFoundException
import android.content.res.Resources
import android.graphics.Bitmap.Config.ALPHA_8
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import android.net.NetworkInfo
import android.net.Uri
import android.os.IBinder
import android.provider.ContactsContract.Contacts.CONTENT_URI
import android.provider.ContactsContract.Contacts.Photo
import android.util.TypedValue
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.RemoteViews
import com.squareup.picasso3.BitmapHunterTest.TestableBitmapHunter
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.Picasso.Priority
import com.squareup.picasso3.Picasso.RequestTransformer
import com.squareup.picasso3.RequestHandler.Result
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import okhttp3.Call
import okhttp3.Response
import okio.Timeout
import org.mockito.ArgumentMatchers.any
import org.mockito.ArgumentMatchers.anyBoolean
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.`when`
import org.mockito.Mockito.doAnswer
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.mock
import org.mockito.invocation.InvocationOnMock
import org.mockito.stubbing.Answer
import java.io.File
import java.io.IOException
import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit

internal object TestUtils {
  val TRANSFORM_REQUEST_ANSWER = Answer { invocation: InvocationOnMock -> invocation.arguments[0] }
  @JvmField val URI_1: Uri = Uri.parse("http:
  @JvmField val URI_2: Uri = Uri.parse("http:
  const val STABLE_1 = "stableExampleKey1"
  val SIMPLE_REQUEST: Request = Request.Builder(URI_1).build()
  @JvmField val URI_KEY_1: String = SIMPLE_REQUEST.key
  @JvmField val URI_KEY_2: String = Request.Builder(URI_2).build().key
  val STABLE_URI_KEY_1: String = Request.Builder(URI_1).stableKey(STABLE_1).build().key
  private val FILE_1 = File("C:\\windows\\system32\\logo.exe")
  val FILE_KEY_1: String = Request.Builder(Uri.fromFile(FILE_1)).build().key
  val FILE_1_URL: Uri = Uri.parse("file:
  val FILE_1_URL_NO_AUTHORITY: Uri = Uri.parse("file:/" + FILE_1.parent)
  val MEDIA_STORE_CONTENT_1_URL: Uri = Uri.parse("content:
  val MEDIA_STORE_CONTENT_KEY_1: String = Request.Builder(MEDIA_STORE_CONTENT_1_URL).build().key
  val CONTENT_1_URL: Uri = Uri.parse("content:
  val CONTENT_KEY_1: String = Request.Builder(CONTENT_1_URL).build().key
  val CONTACT_URI_1: Uri = CONTENT_URI.buildUpon().appendPath("1234").build()
  val CONTACT_KEY_1: String = Request.Builder(CONTACT_URI_1).build().key
  val CONTACT_PHOTO_URI_1: Uri =
    CONTENT_URI.buildUpon().appendPath("1234").appendPath(Photo.CONTENT_DIRECTORY).build()
  val CONTACT_PHOTO_KEY_1: String = Request.Builder(CONTACT_PHOTO_URI_1).build().key
  const val RESOURCE_ID_1 = 1
  val RESOURCE_ID_KEY_1: String = Request.Builder(RESOURCE_ID_1).build().key
  val ASSET_URI_1: Uri = Uri.parse("file:
  val ASSET_KEY_1: String = Request.Builder(ASSET_URI_1).build().key
  private const val RESOURCE_PACKAGE = "com.squareup.picasso3"
  private const val RESOURCE_TYPE = "drawable"
  private const val RESOURCE_NAME = "foo"
  val RESOURCE_ID_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_ID_1.toString())
    .build()
  val RESOURCE_ID_URI_KEY: String = Request.Builder(RESOURCE_ID_URI).build().key
  val RESOURCE_TYPE_URI: Uri = Uri.Builder()
    .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
    .authority(RESOURCE_PACKAGE)
    .appendPath(RESOURCE_TYPE)
    .appendPath(RESOURCE_NAME)
    .build()
  val RESOURCE_TYPE_URI_KEY: String = Request.Builder(RESOURCE_TYPE_URI).build().key
  val CUSTOM_URI: Uri = Uri.parse("foo:
  val CUSTOM_URI_KEY: String = Request.Builder(CUSTOM_URI).build().key
  const val BITMAP_RESOURCE_VALUE = "foo.png"
  const val XML_RESOURCE_VALUE = "foo.xml"
  private val DEFAULT_CONFIG = ARGB_8888
  private const val DEFAULT_CACHE_SIZE = 123

  fun mockPackageResourceContext(): Context {
    val context = mock(Context::class.java)
    val pm = mock(PackageManager::class.java)
    val res = mock(Resources::class.java)

    doReturn(pm).`when`(context).packageManager
    try {
      doReturn(res).`when`(pm).getResourcesForApplication(RESOURCE_PACKAGE)
    } catch (e: NameNotFoundException) {
      throw RuntimeException(e)
    }
    doReturn(RESOURCE_ID_1).`when`(res)
      .getIdentifier(RESOURCE_NAME, RESOURCE_TYPE, RESOURCE_PACKAGE)
    return context
  }

  fun mockResources(resValueString: String): Resources {
    val resources = mock(Resources::class.java)
    doAnswer { invocation: InvocationOnMock ->
      val args = invocation.arguments
      (args[1] as TypedValue).string = resValueString
      null
    }.`when`(resources).getValue(anyInt(), any(TypedValue::class.java), anyBoolean())

    return resources
  }

  @JvmStatic fun mockRequest(uri: Uri): Request = Request.Builder(uri).build()

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    tag: String
  ): FakeAction = mockAction(picasso, key, uri, target, 0, null, tag)

  @JvmStatic @JvmOverloads fun mockAction(
    picasso: Picasso,
    key: String,
    uri: Uri? = null,
    target: Any = mockTarget(),
    resourceId: Int = 0,
    priority: Priority? = null,
    tag: String? = null
  ): FakeAction {
    val builder = Request.Builder(uri, resourceId, DEFAULT_CONFIG).stableKey(key)
    if (priority != null) {
      builder.priority(priority)
    }
    if (tag != null) {
      builder.tag(tag)
    }
    val request = builder.build()
    return mockAction(picasso, request, target)
  }

  @JvmStatic fun mockAction(picasso: Picasso, request: Request, target: Any = mockTarget()) =
    FakeAction(picasso, request, target)

  @JvmStatic fun mockImageViewTarget(): ImageView = mock(ImageView::class.java)

  fun mockRemoteViews(): RemoteViews = mock(RemoteViews::class.java)

  fun mockNotification(): Notification = mock(Notification::class.java)

  fun mockFitImageViewTarget(alive: Boolean): ImageView {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(observer.isAlive).thenReturn(alive)
    val mock = mock(ImageView::class.java)
    `when`(mock.windowToken).thenReturn(mock(IBinder::class.java))
    `when`(mock.viewTreeObserver).thenReturn(observer)
    return mock
  }

  @JvmStatic fun mockTarget(): BitmapTarget = mock(BitmapTarget::class.java)

  @JvmStatic fun mockCallback(): Callback = mock(Callback::class.java)

  @JvmStatic fun mockDeferredRequestCreator(
    creator: RequestCreator?,
    target: ImageView
  ): DeferredRequestCreator {
    val observer = mock(ViewTreeObserver::class.java)
    `when`(target.viewTreeObserver).thenReturn(observer)
    return DeferredRequestCreator(creator!!, target, null)
  }

  @JvmStatic fun mockRequestCreator(): RequestCreator =
    RequestCreator(mock(Picasso::class.java), null, 0)

  @JvmStatic @JvmOverloads fun mockNetworkInfo(isConnected: Boolean = false): NetworkInfo {
    val mock = mock(NetworkInfo::class.java)
    `when`(mock.isConnected).thenReturn(isConnected)
    `when`(mock.isConnectedOrConnecting).thenReturn(isConnected)
    return mock
  }

  @JvmStatic @JvmOverloads fun mockHunter(
    picasso: Picasso,
    result: Result,
    action: Action,
    e: Exception? = null,
    shouldRetry: Boolean = false,
    supportsReplay: Boolean = false
  ): BitmapHunter =
    TestableBitmapHunter(
      picasso = picasso,
      dispatcher = mock(Dispatcher::class.java),
      cache = PlatformLruCache(0),
      action = action,
      result = (result as Bitmap).bitmap,
      exception = e,
      shouldRetry = shouldRetry,
      supportsReplay = supportsReplay
    )

  @JvmStatic fun mockPicasso(context: Context): Picasso {
    
    val requestHandler: RequestHandler = object : RequestHandler() {
      override fun canHandleRequest(data: Request): Boolean {
        return true
      }

      override fun load(picasso: Picasso, request: Request, callback: Callback) {
        val defaultResult = makeBitmap()
        val result = RequestHandler.Result.Bitmap(defaultResult, MEMORY)
        callback.onSuccess(result)
      }
    }

    return mockPicasso(context, requestHandler)
  }

  @JvmStatic fun mockPicasso(context: Context, requestHandler: RequestHandler): Picasso {
    return Picasso.Builder(context)
      .callFactory(UNUSED_CALL_FACTORY)
      .withCacheSize(0)
      .addRequestHandler(requestHandler)
      .build()
  }

  @JvmStatic @JvmOverloads
  fun makeBitmap(
    width: Int = 10,
    height: Int = 10
  ): android.graphics.Bitmap = android.graphics.Bitmap.createBitmap(width, height, ALPHA_8)

  fun makeLoaderWithDrawable(drawable: Drawable?): DrawableLoader = DrawableLoader { drawable }

  internal class FakeAction(
    picasso: Picasso, request: Request, private val target: Any
  ) : Action(picasso, request) {
    @JvmField var completedResult: Result? = null
    @JvmField var errorException: Exception? = null

    override fun complete(result: Result) {
      completedResult = result
    }

    override fun error(e: Exception) {
      errorException = e
    }

    override fun getTarget(): Any = target
  }

  @JvmField val UNUSED_CALL_FACTORY = Call.Factory { throw AssertionError() }
  @JvmField val NOOP_REQUEST_HANDLER: RequestHandler = object : RequestHandler() {
    override fun canHandleRequest(data: Request): Boolean = false
    override fun load(picasso: Picasso, request: Request, callback: Callback) = Unit
  }
  @JvmField val NOOP_TRANSFORMER = RequestTransformer { Request.Builder(0).build() }
  private val NOOP_LISTENER = Picasso.Listener { _: Picasso, _: Uri, _: Exception -> }
  @JvmField val NO_TRANSFORMERS: List<RequestTransformer> = emptyList()
  @JvmField val NO_HANDLERS: List<RequestHandler> = emptyList()
  @JvmField val NO_EVENT_LISTENERS: List<EventListener> = emptyList()

  @JvmStatic fun defaultPicasso(
    context: Context,
    hasRequestHandlers: Boolean,
    hasTransformers: Boolean
  ): Picasso {
    val builder = Picasso.Builder(context)

    if (hasRequestHandlers) {
      builder.addRequestHandler(NOOP_REQUEST_HANDLER)
    }
    if (hasTransformers) {
      builder.addRequestTransformer(NOOP_TRANSFORMER)
    }
    return builder
      .callFactory(UNUSED_CALL_FACTORY)
      .defaultBitmapConfig(DEFAULT_CONFIG)
      .executor(PicassoExecutorService())
      .indicatorsEnabled(true)
      .listener(NOOP_LISTENER)
      .loggingEnabled(true)
      .withCacheSize(DEFAULT_CACHE_SIZE)
      .build()
  }

  internal class EventRecorder : EventListener {
    var maxCacheSize = 0
    var cacheSize = 0
    @JvmField var cacheHits = 0
    @JvmField var cacheMisses = 0
    var downloadSize: Long = 0
    var decodedBitmap: android.graphics.Bitmap? = null
    var transformedBitmap: android.graphics.Bitmap? = null
    @JvmField var closed = false

    override fun cacheMaxSize(maxSize: Int) {
      maxCacheSize = maxSize
    }

    override fun cacheSize(size: Int) {
      cacheSize = size
    }

    override fun cacheHit() {
      cacheHits++
    }

    override fun cacheMiss() {
      cacheMisses++
    }

    override fun downloadFinished(size: Long) {
      downloadSize = size
    }

    override fun bitmapDecoded(bitmap: android.graphics.Bitmap) {
      decodedBitmap = bitmap
    }

    override fun bitmapTransformed(bitmap: android.graphics.Bitmap) {
      transformedBitmap = bitmap
    }

    override fun close() {
      closed = true
    }
  }

  internal class PremadeCall(
    private val request: okhttp3.Request,
    private val response: Response
  ) : Call {
    override fun request(): okhttp3.Request = request
    override fun execute(): Response = response
    override fun enqueue(responseCallback: okhttp3.Callback) {
      try {
        responseCallback.onResponse(this, response)
      } catch (e: IOException) {
        throw AssertionError(e)
      }
    }
    override fun cancel(): Unit = throw AssertionError()
    override fun isExecuted(): Boolean = throw AssertionError()
    override fun isCanceled(): Boolean = throw AssertionError()
    override fun clone(): Call = throw AssertionError()
    override fun timeout(): Timeout = throw AssertionError()
  }

  internal class TestDelegatingService(private val delegate: ExecutorService) : ExecutorService {
    @JvmField var submissions = 0

    override fun shutdown() = delegate.shutdown()
    override fun shutdownNow(): List<Runnable> = throw AssertionError("Not implemented.")
    override fun isShutdown(): Boolean = delegate.isShutdown
    override fun isTerminated(): Boolean = throw AssertionError("Not implemented.")

    @Throws(InterruptedException::class)
    override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean =
      delegate.awaitTermination(timeout, unit)

    override fun <T> submit(task: Callable<T>): Future<T> =
      throw AssertionError("Not implemented.")

    override fun <T> submit(task: Runnable, result: T): Future<T> =
      throw AssertionError("Not implemented.")

    override fun submit(task: Runnable): Future<*> {
      submissions++
      return delegate.submit(task)
    }

    override fun <T> invokeAll(tasks: Collection<Callable<T>?>): List<Future<T>> =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAll(
      tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit
    ): List<Future<T>> = throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>): T =
      throw AssertionError("Not implemented.")

    override fun <T> invokeAny(tasks: Collection<Callable<T>?>, timeout: Long, unit: TimeUnit): T =
      throw AssertionError("Not implemented.")

    override fun execute(command: Runnable) = delegate.execute(command)
  }
}
<code block>

package com.squareup.picasso3

import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.Drawable
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockTarget
import org.junit.Assert.fail
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class BitmapTargetActionTest {

  @Test fun invokesSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    request.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
    verify(target).onBitmapLoaded(bitmap, MEMORY)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val request = BitmapTargetAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun invokesOnBitmapFailedIfTargetIsNotNullWithErrorResourceId() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockTarget()
    val context = mock(Context::class.java)
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      context, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val res = mock(Resources::class.java)
    val request = BitmapTargetAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1
    )

    `when`(context.resources).thenReturn(res)
    `when`(res.getDrawable(RESOURCE_ID_1)).thenReturn(errorDrawable)
    val e = RuntimeException()

    request.error(e)
    verify(target).onBitmapFailed(e, errorDrawable)
  }

  @Test fun recyclingInSuccessThrowsException() {
    val picasso = mock(Picasso::class.java)
    val bitmap = makeBitmap()
    val tr = BitmapTargetAction(
      picasso = picasso,
      target = object : BitmapTarget {
        override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) = bitmap.recycle()
        override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) = throw AssertionError()
        override fun onPrepareLoad(placeHolderDrawable: Drawable?) = throw AssertionError()
      },
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0
    )
    try {
      tr.complete(RequestHandler.Result.Bitmap(bitmap, MEMORY))
      fail()
    } catch (ignored: IllegalStateException) {
    }
  }
}
<code block>

package com.squareup.picasso3

import android.graphics.Bitmap.Config.ARGB_8888
import android.graphics.drawable.AnimationDrawable
import android.graphics.drawable.Drawable
import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.Picasso.LoadedFrom.MEMORY
import com.squareup.picasso3.RequestHandler.Result.Bitmap
import com.squareup.picasso3.TestUtils.NO_EVENT_LISTENERS
import com.squareup.picasso3.TestUtils.NO_HANDLERS
import com.squareup.picasso3.TestUtils.NO_TRANSFORMERS
import com.squareup.picasso3.TestUtils.RESOURCE_ID_1
import com.squareup.picasso3.TestUtils.SIMPLE_REQUEST
import com.squareup.picasso3.TestUtils.UNUSED_CALL_FACTORY
import com.squareup.picasso3.TestUtils.makeBitmap
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockImageViewTarget
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.RobolectricTestRunner
import org.robolectric.RuntimeEnvironment

@RunWith(RobolectricTestRunner::class)
class ImageViewActionTest {

  @Test
  fun invokesTargetAndCallbackSuccessIfTargetIsNotNull() {
    val bitmap = makeBitmap()
    val dispatcher = mock(Dispatcher::class.java)
    val cache = PlatformLruCache(0)
    val picasso = Picasso(
      RuntimeEnvironment.application, dispatcher, UNUSED_CALL_FACTORY, null, cache, null,
      NO_TRANSFORMERS, NO_HANDLERS, NO_EVENT_LISTENERS, ARGB_8888, false, false
    )
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.complete(Bitmap(bitmap, MEMORY))
    verify(target).setImageDrawable(any(PicassoDrawable::class.java))
    verify(callback).onSuccess()
  }

  @Test
  fun invokesTargetAndCallbackErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorResourceId() {
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = RESOURCE_ID_1,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)
    verify(target).setImageResource(RESOURCE_ID_1)
    verify(callback).onError(e)
  }

  @Test fun invokesErrorIfTargetIsNotNullWithErrorDrawable() {
    val errorDrawable = mock(Drawable::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = mock(Picasso::class.java),
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = errorDrawable,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    val e = RuntimeException()

    request.error(e)

    verify(target).setImageDrawable(errorDrawable)
    verify(callback).onError(e)
  }

  @Test fun clearsCallbackOnCancel() {
    val picasso = mock(Picasso::class.java)
    val target = mockImageViewTarget()
    val callback = mockCallback()
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = callback
    )
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun stopPlaceholderAnimationOnError() {
    val picasso = mock(Picasso::class.java)
    val placeholder = mock(AnimationDrawable::class.java)
    val target = mockImageViewTarget()
    `when`(target.drawable).thenReturn(placeholder)
    val request = ImageViewAction(
      picasso = picasso,
      target = target,
      data = SIMPLE_REQUEST,
      errorDrawable = null,
      errorResId = 0,
      noFade = false,
      callback = null
    )
    request.error(RuntimeException())
    verify(placeholder).stop()
  }
}
<code block>

package com.squareup.picasso3

import com.google.common.truth.Truth.assertThat
import com.squareup.picasso3.TestUtils.TRANSFORM_REQUEST_ANSWER
import com.squareup.picasso3.TestUtils.mockCallback
import com.squareup.picasso3.TestUtils.mockFitImageViewTarget
import com.squareup.picasso3.TestUtils.mockRequestCreator
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.ArgumentCaptor
import org.mockito.ArgumentMatchers.any
import org.mockito.Captor
import org.mockito.Mockito.`when`
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import org.mockito.Mockito.verifyNoMoreInteractions
import org.mockito.MockitoAnnotations.initMocks
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class DeferredRequestCreatorTest {
  @Captor
  internal lateinit var actionCaptor: ArgumentCaptor<Action>

  @Before fun setUp() {
    initMocks(this)
  }

  @Test fun initWhileAttachedAddsAttachAndPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(observer).addOnPreDrawListener(request)
  }

  @Test fun initWhileDetachedAddsAttachListenerWhichDefersPreDrawListener() {
    val target = mockFitImageViewTarget(true)
    `when`(target.windowToken).thenReturn(null)
    val observer = target.viewTreeObserver
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    verifyNoMoreInteractions(observer)

    
    request.onViewAttachedToWindow(target)
    verify(observer).addOnPreDrawListener(request)

    
    request.onViewDetachedFromWindow(target)
    verify(observer).removeOnPreDrawListener(request)
  }

  @Test fun cancelWhileAttachedRemovesAttachListener() {
    val target = mockFitImageViewTarget(true)
    val request = DeferredRequestCreator(mockRequestCreator(), target, null)
    verify(target).addOnAttachStateChangeListener(request)
    request.cancel()
    verify(target).removeOnAttachStateChangeListener(request)
  }

  @Test fun cancelClearsCallback() {
    val target = mockFitImageViewTarget(true)
    val callback = mockCallback()
    val request = DeferredRequestCreator(mockRequestCreator(), target, callback)
    assertThat(request.callback).isNotNull()
    request.cancel()
    assertThat(request.callback).isNull()
  }

  @Test fun cancelClearsTag() {
    val target = mockFitImageViewTarget(true)
    val creator = mockRequestCreator().tag("TAG")
    val request = DeferredRequestCreator(creator, target, null)

    assertThat(creator.tag).isNotNull()
    request.cancel()
    assertThat(creator.tag).isNull()
  }

  @Test fun onLayoutSkipsIfViewIsAttachedAndViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    val viewTreeObserver = target.viewTreeObserver
    request.onPreDraw()
    verify(viewTreeObserver).addOnPreDrawListener(request)
    verify(viewTreeObserver).isAlive
    verifyNoMoreInteractions(viewTreeObserver)
  }

  @Test fun waitsForAnotherLayoutIfWidthOrHeightIsZero() {
    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(0)
    `when`(target.height).thenReturn(0)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun cancelSkipsIfViewTreeObserverIsDead() {
    val target = mockFitImageViewTarget(false)
    val creator = mockRequestCreator()
    val request = DeferredRequestCreator(creator, target, null)
    request.cancel()
    verify(target.viewTreeObserver, never()).removeOnPreDrawListener(request)
  }

  @Test fun preDrawSubmitsRequestAndCleansUp() {
    val picasso = mock(Picasso::class.java)
    `when`(picasso.transformRequest(any(Request::class.java))).thenAnswer(TRANSFORM_REQUEST_ANSWER)

    val creator = RequestCreator(picasso, TestUtils.URI_1, 0)

    val target = mockFitImageViewTarget(true)
    `when`(target.width).thenReturn(100)
    `when`(target.height).thenReturn(100)

    val observer = target.viewTreeObserver

    val request = DeferredRequestCreator(creator, target, null)
    request.onPreDraw()

    verify(observer).removeOnPreDrawListener(request)
    verify(picasso).enqueueAndSubmit(actionCaptor.capture())

    val value = actionCaptor.value
    assertThat(value).isInstanceOf(ImageViewAction::class.java)
    assertThat(value.request.targetWidth).isEqualTo(100)
    assertThat(value.request.targetHeight).isEqualTo(100)
  }
}
<code block>


package com.example.android.architecture.blueprints.todoapp.data

import kotlinx.coroutines.flow.Flow


interface TaskRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refresh()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun createTask(title: String, description: String): String

    suspend fun updateTask(taskId: String, title: String, description: String)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.TaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.di.ApplicationScope
import com.example.android.architecture.blueprints.todoapp.di.DefaultDispatcher
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


@Singleton
class DefaultTaskRepository @Inject constructor(
    private val networkDataSource: NetworkDataSource,
    private val localDataSource: TaskDao,
    @DefaultDispatcher private val dispatcher: CoroutineDispatcher,
    @ApplicationScope private val scope: CoroutineScope,
) : TaskRepository {

    override suspend fun createTask(title: String, description: String): String {
        
        
        val taskId = withContext(dispatcher) {
            UUID.randomUUID().toString()
        }
        val task = Task(
            title = title,
            description = description,
            id = taskId,
        )
        localDataSource.upsert(task.toLocal())
        saveTasksToNetwork()
        return taskId
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val task = getTask(taskId)?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        localDataSource.upsert(task.toLocal())
        saveTasksToNetwork()
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            refresh()
        }
        return withContext(dispatcher) {
            localDataSource.getAll().toExternal()
        }
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return localDataSource.observeAll().map { tasks ->
            withContext(dispatcher) {
                tasks.toExternal()
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        refresh()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return localDataSource.observeById(taskId).map { it.toExternal() }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            refresh()
        }
        return localDataSource.getById(taskId)?.toExternal()
    }

    override suspend fun completeTask(taskId: String) {
        localDataSource.updateCompleted(taskId = taskId, completed = true)
        saveTasksToNetwork()
    }

    override suspend fun activateTask(taskId: String) {
        localDataSource.updateCompleted(taskId = taskId, completed = false)
        saveTasksToNetwork()
    }

    override suspend fun clearCompletedTasks() {
        localDataSource.deleteCompleted()
        saveTasksToNetwork()
    }

    override suspend fun deleteAllTasks() {
        localDataSource.deleteAll()
        saveTasksToNetwork()
    }

    override suspend fun deleteTask(taskId: String) {
        localDataSource.deleteById(taskId)
        saveTasksToNetwork()
    }

    

    
    override suspend fun refresh() {
        withContext(dispatcher) {
            val remoteTasks = networkDataSource.loadTasks()
            localDataSource.deleteAll()
            localDataSource.upsertAll(remoteTasks.toLocal())
        }
    }

    
    private fun saveTasksToNetwork() {
        scope.launch {
            try {
                val localTasks = localDataSource.getAll()
                networkDataSource.saveTasks(localTasks.toNetwork())
            } catch (e: Exception) {
                
                
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network

import javax.inject.Inject
import kotlinx.coroutines.delay


class TaskNetworkDataSource @Inject constructor() : NetworkDataSource {

    private val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASK_SERVICE_DATA = LinkedHashMap<String, NetworkTask>(2)

    init {
        addTask(
            id = "PISA",
            title = "Build tower in Pisa",
            shortDescription = "Ground looks good, no foundation work required."
        )
        addTask(
            id = "TACOMA",
            title = "Finish bridge in Tacoma",
            shortDescription = "Found awesome girders at half the cost!"
        )
    }

    override suspend fun loadTasks(): List<NetworkTask> {
        
        val tasks = TASK_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun saveTasks(tasks: List<NetworkTask>) {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        TASK_SERVICE_DATA.clear()
        TASK_SERVICE_DATA.putAll(tasks.associateBy(NetworkTask::id))
    }

    private fun addTask(id: String, title: String, shortDescription: String) {
        val newTask = NetworkTask(id = id, title = title, shortDescription = shortDescription)
        TASK_SERVICE_DATA[newTask.id] = newTask
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.DefaultTaskRepository
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.network.TaskNetworkDataSource
import dagger.Binds
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Singleton
    @Binds
    abstract fun bindTaskRepository(repository: DefaultTaskRepository): TaskRepository
}

@Module
@InstallIn(SingletonComponent::class)
abstract class DataSourceModule {

    @Singleton
    @Binds
    abstract fun bindNetworkDataSource(dataSource: TaskNetworkDataSource): NetworkDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }

    @Provides
    fun provideTaskDao(database: ToDoDatabase): TaskDao = database.taskDao()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class IoDispatcher

@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class DefaultDispatcher

@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class ApplicationScope

@Module
@InstallIn(SingletonComponent::class)
object CoroutinesModule {

    @Provides
    @IoDispatcher
    fun providesIODispatcher(): CoroutineDispatcher = Dispatchers.IO

    @Provides
    @DefaultDispatcher
    fun providesDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default

    @Provides
    @Singleton
    @ApplicationScope
    fun providesCoroutineScope(
        @DefaultDispatcher dispatcher: CoroutineDispatcher
    ): CoroutineScope = CoroutineScope(SupervisorJob() + dispatcher)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val taskRepository: TaskRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        taskRepository.getTasksStream()
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            taskRepository.refresh()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<List<Task>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Error -> {
                
                StatisticsUiState(isEmpty = true, isLoading = false)
            }
            is Async.Success -> {
                val stats = getActiveAndCompletedStats(taskLoad.data)
                StatisticsUiState(
                    isEmpty = taskLoad.data.isEmpty(),
                    activeTasksPercent = stats.activeTasksPercent,
                    completedTasksPercent = stats.completedTasksPercent,
                    isLoading = false
                )
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val taskRepository: TaskRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(taskRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            taskRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            taskRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            taskRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            taskRepository.refresh()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.source.local.FakeTaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.FakeNetworkDataSource
import com.google.common.truth.Truth.assertThat
import junit.framework.TestCase.assertEquals
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTaskRepositoryTest {

    private val task1 = Task(id = "1", title = "Title1", description = "Description1")
    private val task2 = Task(id = "2", title = "Title2", description = "Description2")
    private val task3 = Task(id = "3", title = "Title3", description = "Description3")

    private val newTaskTitle = "Title new"
    private val newTaskDescription = "Description new"
    private val newTask = Task(id = "new", title = newTaskTitle, description = newTaskDescription)
    private val newTasks = listOf(newTask)

    private val networkTasks = listOf(task1, task2).toNetwork()
    private val localTasks = listOf(task3.toLocal())

    private lateinit var networkDataSource: FakeNetworkDataSource
    private lateinit var localDataSource: FakeTaskDao

    
    private lateinit var tasksRepository: DefaultTaskRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        networkDataSource = FakeNetworkDataSource(networkTasks.toMutableList())
        localDataSource = FakeTaskDao(localTasks)
        
        tasksRepository = DefaultTaskRepository(
            networkDataSource = networkDataSource,
            localDataSource = localDataSource,
            dispatcher = StandardTestDispatcher(),
            scope = TestScope()
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        networkDataSource.tasks?.clear()
        localDataSource.deleteAll()

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(networkTasks.toExternal())
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        advanceUntilIdle()

        
        assertThat(networkDataSource.tasks?.map { it.id }?.contains(newTaskId))
        assertThat(localDataSource.tasks?.map { it.id }?.contains(newTaskId))
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        networkDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            networkDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks.toExternal())
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        networkDataSource.tasks = null
        localDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        
        val expectedTasks = networkTasks.toExternal()

        val newTasks = tasksRepository.getTasks(true)

        assertEquals(expectedTasks, newTasks)
        assertEquals(expectedTasks, localDataSource.tasks?.toExternal())
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        localDataSource = FakeTaskDao(mutableListOf(task1.toLocal()))
        val initial = tasksRepository.getTask(task1.id)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        networkDataSource.tasks = mutableListOf(task1.toNetwork())
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        networkDataSource.tasks = mutableListOf(task2.toNetwork())

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        localDataSource.tasks = listOf(completedTask.toLocal(), task2.toLocal())
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.annotation.VisibleForTesting
import java.util.UUID
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeTaskRepository : TaskRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refresh() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refresh()
    }

    override suspend fun createTask(title: String, description: String): String {
        val taskId = generateTaskId()
        Task(title = title, description = description, id = taskId).also {
            saveTask(it)
        }
        return taskId
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val updatedTask = _savedTasks.value[taskId]?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        saveTask(updatedTask)
    }

    private fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    private fun generateTaskId() = UUID.randomUUID().toString()

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import kotlinx.coroutines.flow.Flow


interface TaskRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun createTask(title: String, description: String): String

    suspend fun updateTask(taskId: String, title: String, description: String)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.TaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import java.util.UUID
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext


class DefaultTaskRepository(
    private val tasksNetworkDataSource: NetworkDataSource,
    private val taskDao: TaskDao,
    private val coroutineDispatcher: CoroutineDispatcher = Dispatchers.Default
) : TaskRepository {

    override suspend fun createTask(title: String, description: String): String {
        
        
        val taskId = withContext(coroutineDispatcher) {
            UUID.randomUUID().toString()
        }
        val task = Task(
            title = title,
            description = description,
            id = taskId,
        )
        taskDao.upsert(task.toLocal())
        saveTasksToNetwork()
        return taskId
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val task = getTask(taskId)?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        taskDao.upsert(task.toLocal())
        saveTasksToNetwork()
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            loadTasksFromNetwork()
        }
        return withContext(coroutineDispatcher) {
            taskDao.getAll().toExternal()
        }
    }

    override suspend fun refreshTasks() {
        loadTasksFromNetwork()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return taskDao.observeAll().map { tasks ->
            withContext(coroutineDispatcher) {
                tasks.toExternal()
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        loadTasksFromNetwork()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return taskDao.observeById(taskId).map { it.toExternal() }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            loadTasksFromNetwork()
        }
        return taskDao.getById(taskId)?.toExternal()
    }

    override suspend fun completeTask(taskId: String) {
        taskDao.updateCompleted(taskId = taskId, completed = true)
        saveTasksToNetwork()
    }

    override suspend fun activateTask(taskId: String) {
        taskDao.updateCompleted(taskId = taskId, completed = false)
        saveTasksToNetwork()
    }

    override suspend fun clearCompletedTasks() {
        taskDao.deleteCompleted()
        saveTasksToNetwork()
    }

    override suspend fun deleteAllTasks() {
        taskDao.deleteAll()
        saveTasksToNetwork()
    }

    override suspend fun deleteTask(taskId: String) {
        taskDao.deleteById(taskId)
        saveTasksToNetwork()
    }

    
    private suspend fun loadTasksFromNetwork() {
        withContext(coroutineDispatcher) {
            val remoteTasks = tasksNetworkDataSource.loadTasks()
            taskDao.deleteAll()
            taskDao.upsertAll(remoteTasks.toLocal())
        }
    }

    private suspend fun saveTasksToNetwork() {
        withContext(coroutineDispatcher) {
            val localTasks = taskDao.getAll()
            tasksNetworkDataSource.saveTasks(localTasks.toNetwork())
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network

import kotlinx.coroutines.delay


object TaskNetworkDataSource : NetworkDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASK_SERVICE_DATA = LinkedHashMap<String, NetworkTask>(2)

    init {
        addTask(
            id = "PISA",
            title = "Build tower in Pisa",
            shortDescription = "Ground looks good, no foundation work required."
        )
        addTask(
            id = "TACOMA",
            title = "Finish bridge in Tacoma",
            shortDescription = "Found awesome girders at half the cost!"
        )
    }

    override suspend fun loadTasks(): List<NetworkTask> {
        
        val tasks = TASK_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun saveTasks(tasks: List<NetworkTask>) {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        TASK_SERVICE_DATA.clear()
        TASK_SERVICE_DATA.putAll(tasks.associateBy(NetworkTask::id))
    }

    private fun addTask(id: String, title: String, shortDescription: String) {
        val newTask = NetworkTask(id = id, title = title, shortDescription = shortDescription)
        TASK_SERVICE_DATA[newTask.id] = newTask
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.DefaultTaskRepository
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.network.TaskNetworkDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class NetworkTaskDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTaskRepository(
        @NetworkTaskDataSource remoteDataSource: NetworkDataSource,
        database: ToDoDatabase,
    ): TaskRepository {
        return DefaultTaskRepository(remoteDataSource, database.taskDao())
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @NetworkTaskDataSource
    @Provides
    fun provideTaskRemoteDataSource(): NetworkDataSource = TaskNetworkDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class IoDispatcher

@Module
@InstallIn(SingletonComponent::class)
object CoroutinesModule {

    @Provides
    @IoDispatcher
    fun providesIODispatcher(): CoroutineDispatcher = Dispatchers.IO
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val taskRepository: TaskRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        taskRepository.getTasksStream()
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            taskRepository.refreshTasks()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<List<Task>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Error -> {
                
                StatisticsUiState(isEmpty = true, isLoading = false)
            }
            is Async.Success -> {
                val stats = getActiveAndCompletedStats(taskLoad.data)
                StatisticsUiState(
                    isEmpty = taskLoad.data.isEmpty(),
                    activeTasksPercent = stats.activeTasksPercent,
                    completedTasksPercent = stats.completedTasksPercent,
                    isLoading = false
                )
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val taskRepository: TaskRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(taskRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            taskRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            taskRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            taskRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            taskRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.source.local.FakeTaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.FakeNetworkDataSource
import com.google.common.truth.Truth.assertThat
import junit.framework.TestCase.assertEquals
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTaskRepositoryTest {

    private val task1 = Task(id = "1", title = "Title1", description = "Description1")
    private val task2 = Task(id = "2", title = "Title2", description = "Description2")
    private val task3 = Task(id = "3", title = "Title3", description = "Description3")

    private val newTaskTitle = "Title new"
    private val newTaskDescription = "Description new"
    private val newTask = Task(id = "new", title = newTaskTitle, description = newTaskDescription)
    private val newTasks = listOf(newTask)

    private val networkTasks = listOf(task1, task2).toNetwork()
    private val localTasks = listOf(task3.toLocal())

    private lateinit var networkDataSource: FakeNetworkDataSource
    private lateinit var localDataSource: FakeTaskDao

    
    private lateinit var tasksRepository: DefaultTaskRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        networkDataSource = FakeNetworkDataSource(networkTasks.toMutableList())
        localDataSource = FakeTaskDao(localTasks)
        
        tasksRepository = DefaultTaskRepository(
            networkDataSource, localDataSource
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptyRemoteSource = FakeNetworkDataSource()
        val emptyLocalSource = FakeTaskDao()

        val tasksRepository = DefaultTaskRepository(
            emptyRemoteSource, emptyLocalSource
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(networkTasks.toExternal())
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(networkDataSource.tasks?.map { it.id }?.contains(newTaskId))
        assertThat(localDataSource.tasks?.map { it.id }?.contains(newTaskId))
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        networkDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            networkDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks.toExternal())
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        networkDataSource.tasks = null
        localDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        
        val expectedTasks = networkTasks.toExternal()

        val newTasks = tasksRepository.getTasks(true)

        assertEquals(expectedTasks, newTasks)
        assertEquals(expectedTasks, localDataSource.tasks?.toExternal())
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        localDataSource = FakeTaskDao(mutableListOf(task1.toLocal()))
        val initial = tasksRepository.getTask(task1.id)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        networkDataSource.tasks = mutableListOf(task1.toNetwork())
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        networkDataSource.tasks = mutableListOf(task2.toNetwork())

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        localDataSource.tasks = listOf(completedTask.toLocal(), task2.toLocal())
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.annotation.VisibleForTesting
import java.util.UUID
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeTaskRepository : TaskRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override suspend fun createTask(title: String, description: String): String {
        val taskId = generateTaskId()
        Task(title = title, description = description, id = taskId).also {
            saveTask(it)
        }
        return taskId
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val updatedTask = _savedTasks.value[taskId]?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        saveTask(updatedTask)
    }

    private fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    private fun generateTaskId() = UUID.randomUUID().toString()

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.Observer


open class Event<out T>(private val content: T) {

    var hasBeenHandled = false
        private set 

    
    fun getContentIfNotHandled(): T? {
        return if (hasBeenHandled) {
            null
        } else {
            hasBeenHandled = true
            content
        }
    }

    
    fun peekContent(): T = content
}


class EventObserver<T>(private val onEventUnhandledContent: (T) -> Unit) : Observer<Event<T>> {
    override fun onChanged(event: Event<T>?) {
        event?.getContentIfNotHandled()?.let { value ->
            onEventUnhandledContent(value)
        }
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.util



import android.app.Activity
import android.content.pm.ActivityInfo
import android.content.res.Configuration
import androidx.annotation.IdRes
import androidx.appcompat.app.ActionBar
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentTransaction
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProviders
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.ViewModelFactory


const val ADD_EDIT_RESULT_OK = Activity.RESULT_FIRST_USER + 1
const val DELETE_RESULT_OK = Activity.RESULT_FIRST_USER + 2
const val EDIT_RESULT_OK = Activity.RESULT_FIRST_USER + 3

fun AppCompatActivity.setupActionBar(@IdRes toolbarId: Int, action: ActionBar.() -> Unit) {
    setSupportActionBar(findViewById(toolbarId))
    supportActionBar?.run {
        action()
    }
}

fun <T : ViewModel> Fragment.obtainViewModel(viewModelClass: Class<T>): T {
    val repository = (requireContext().applicationContext as TodoApplication).taskRepository
    return ViewModelProviders.of(this, ViewModelFactory(repository)).get(viewModelClass)
}

private fun AppCompatActivity.rotateToLandscape() {
    requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
}

private fun AppCompatActivity.rotateToPortrait() {
    requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
}

fun AppCompatActivity.rotateOrientation() {
    when (resources.configuration.orientation) {
        Configuration.ORIENTATION_LANDSCAPE -> rotateToPortrait()
        Configuration.ORIENTATION_PORTRAIT -> rotateToLandscape()
        else -> rotateToLandscape()
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private lateinit var statisticsViewModel: StatisticsViewModel

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.statistics_frag, container,
                false)
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        statisticsViewModel = obtainViewModel(StatisticsViewModel::class.java)
        viewDataBinding.stats = statisticsViewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
    }

    override fun onResume() {
        super.onResume()
        statisticsViewModel.start()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> =_dataLoading

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdated = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdated

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        _dataLoading.value?.let { isLoading ->
            
            if (isLoading) return
        }
        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }
        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription ?: "").isEmpty) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, currentTaskId)
                .apply { isCompleted = taskCompleted }
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) {
        viewModelScope.launch {
            tasksRepository.saveTask(newTask)
            _taskUpdated.value = Event(Unit)
        }
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdated.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import androidx.navigation.fragment.findNavController
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    private lateinit var viewModel: AddEditTaskViewModel

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewModel = obtainViewModel(AddEditTaskViewModel::class.java)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            this.viewmodel = viewModel
        }
        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupSnackbar()
        setupActionBar()
        setupNavigation()
        loadData()
    }

    private fun setupSnackbar() {
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_LONG)
        }
    }

    private fun setupNavigation() {
        viewModel.taskUpdatedEvent.observe(this, EventObserver {
            val action = AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
            findNavController().navigate(action)
        })
    }

    private fun loadData() {
        
        viewDataBinding.viewmodel?.start(getTaskId())
    }


    private fun setupActionBar() {
        (activity as? AppCompatActivity)?.supportActionBar?.setTitle(
            if (getTaskId() != null)
                R.string.edit_task
            else
                R.string.add_task
        )
    }

    private fun getTaskId(): String? {
        return arguments?.let {
            AddEditTaskFragmentArgs.fromBundle(it).TASKID
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.MenuItem
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.GravityCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.NavOptions
import androidx.navigation.findNavController
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.util.setupActionBar
import com.google.android.material.navigation.NavigationView


class TasksActivity : AppCompatActivity() {

    private lateinit var drawerLayout: DrawerLayout

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.tasks_act)

        setupActionBar(R.id.toolbar) {
            setHomeAsUpIndicator(R.drawable.ic_menu)
            setDisplayHomeAsUpEnabled(true)
        }

        setupNavigationDrawer()
    }


    private fun setupNavigationDrawer() {
        drawerLayout = (findViewById<DrawerLayout>(R.id.drawer_layout))
            .apply {
                setStatusBarBackground(R.color.colorPrimaryDark)
            }
        setupDrawerContent(findViewById(R.id.nav_view))
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            android.R.id.home -> {
                
                drawerLayout.openDrawer(GravityCompat.START)
                true
            }
            else -> super.onOptionsItemSelected(item)
        }

    private fun setupDrawerContent(navigationView: NavigationView) {
        navigationView.setNavigationItemSelectedListener { menuItem ->
            when (menuItem.itemId) {
                R.id.list_navigation_menu_item -> {
                    val navOpts = NavOptions.Builder().setPopUpTo(R.id.tasksFragment, true).build()
                    findNavController(R.id.nav_host_fragment).navigate(R.id.tasksFragment, null, navOpts)
                }
                R.id.statistics_navigation_menu_item -> {
                    val navOpts = NavOptions.Builder().setPopUpTo(R.id.statisticsFragment, true).build()
                    findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment, null, navOpts)
                }
            }
            
            menuItem.isChecked = true
            drawerLayout.closeDrawers()
            true
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.navigation.fragment.findNavController
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber
import java.util.ArrayList


class TasksFragment : Fragment() {

    private lateinit var viewDataBinding: TasksFragBinding
    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = obtainViewModel(TasksViewModel::class.java)
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewDataBinding.viewmodel?.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewDataBinding.viewmodel?.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout()
        setupNavigation()
        setupFab()
        viewDataBinding.viewmodel?.loadTasks(true)
    }

    private fun setupNavigation() {
        viewDataBinding.viewmodel?.openTaskEvent?.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewDataBinding.viewmodel?.newTaskEvent?.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_LONG)
        }
        arguments?.let {
            val message = TasksFragmentArgs.fromBundle(it).userMessage
            viewDataBinding.viewmodel?.showEditResultMessage(message)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewDataBinding.viewmodel?.run {
                    setFiltering(
                            when (it.itemId) {
                                R.id.active -> TasksFilterType.ACTIVE_TASKS
                                R.id.completed -> TasksFilterType.COMPLETED_TASKS
                                else -> TasksFilterType.ALL_TASKS
                            }
                    )
                    loadTasks(false)
                }
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(null)
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(ArrayList(0), viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }

    private fun setupRefreshLayout() {
        viewDataBinding.refreshLayout.run {
            setColorSchemeColors(
                    ContextCompat.getColor(requireActivity(), R.color.colorPrimary),
                    ContextCompat.getColor(requireActivity(), R.color.colorAccent),
                    ContextCompat.getColor(requireActivity(), R.color.colorPrimaryDark)
            )
            
            scrollUpChild = viewDataBinding.tasksList
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.ic_assignment_turned_in_24dp, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_24dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_24dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) {
        
        viewModelScope.launch {
            if (completed) {
                tasksRepository.completeTask(task)
                showSnackbarMessage(R.string.task_marked_complete)
            } else {
                tasksRepository.activateTask(task)
                showSnackbarMessage(R.string.task_marked_active)
            }
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_saved_task_message)
            )
            ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_added_task_message)
            )
            DELETE_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_deleted_task_message)
            )
        }

    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) = viewModelScope.launch {

        _dataLoading.value = true
        val tasksResult = tasksRepository.getTasks(forceUpdate)

        if (tasksResult is Success) {
            val tasks = tasksResult.data

            val tasksToShow = ArrayList<Task>()
            
            for (task in tasks) {
                when (_currentFiltering) {
                    TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                    TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                        tasksToShow.add(task)
                    }
                    TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                        tasksToShow.add(task)
                    }
                }
            }
            _dataLoading.value = false
            isDataLoadingError.value = false

            val itemsValue = ArrayList(tasksToShow)
            _items.value = itemsValue
        } else {
            _dataLoading.value = false
            isDataLoadingError.value = false
            _items.value = emptyList()
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import androidx.fragment.app.Fragment
import androidx.navigation.fragment.findNavController
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {
    private lateinit var viewDataBinding: TaskdetailFragBinding

    private lateinit var viewModel: TaskDetailViewModel

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_LONG)
        }

        setupNavigation()
    }

    private fun setupNavigation() {
        viewModel.deleteTaskCommand.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToTasksFragment(DELETE_RESULT_OK)
            findNavController().navigate(action)
        })
        viewModel.editTaskCommand.observe(this, EventObserver {
            val taskId = TaskDetailFragmentArgs.fromBundle(arguments!!).TASKID
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToAddEditTaskFragment(taskId)
            findNavController().navigate(action)
        })
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.fab_edit_task)?.setOnClickListener {
            viewDataBinding.viewmodel?.editTask()
        }
    }

    override fun onResume() {
        super.onResume()
        val taskId = arguments?.let {
            TaskDetailFragmentArgs.fromBundle(it).TASKID
        }
        viewDataBinding.viewmodel?.start(taskId)
    }

    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewModel = obtainViewModel(TaskDetailViewModel::class.java)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = viewModel
            listener = object : TaskDetailUserActionsListener {
                override fun onCompleteChanged(v: View) {
                    viewmodel?.setCompleted((v as CheckBox).isChecked)
                }
            }
        }
        viewDataBinding.setLifecycleOwner(this.viewLifecycleOwner)
        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewDataBinding.viewmodel?.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class StatisticsScreenTest {

    @Before
    fun setup() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            runBlocking {
                saveTask(Task("Title1").apply { isCompleted = false })
                saveTask(Task("Title2").apply { isCompleted = true })
            }
        }
    }

    @Test
    fun tasks_showsNonEmptyMessage() {
        val scenario = launchFragmentInContainer<StatisticsFragment>(Bundle(), R.style.Theme_AppCompat)
        val expectedActiveTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_active_tasks, 1)
        val expectedCompletedTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_completed_tasks, 1)
        scenario.onFragment {
            
            onView(withId(R.id.stats_active_text)).check(matches(isDisplayed()))
            onView(withId(R.id.stats_active_text)).check(matches(withText(expectedActiveTaskText)))
            onView(withId(R.id.stats_completed_text)).check(matches(isDisplayed()))
            onView(withId(R.id.stats_completed_text)).check(matches(withText(expectedCompletedTaskText)))
        }
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class AddEditTaskScreenTest {

    @Test
    @Ignore("hangs in robolectric, see issue #4724")
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs().toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import org.hamcrest.core.IsNot.not
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class TaskDetailScreenTest {

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        
        val activeTask = Task("Active Task", "AndroidX Rocks").apply {
            isCompleted = false
        }
        FakeTasksRemoteDataSource.addTasks(activeTask)

        
        val bundle = TaskDetailFragmentArgs(activeTask.id).toBundle();
        val scenario = launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.Theme_AppCompat)

        
        scenario.onFragment {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText("Active Task")))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
        }
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        
        val completedTask = Task("Completed Task", "AndroidX Rocks").apply {
            isCompleted = true
        }
        FakeTasksRemoteDataSource.addTasks(completedTask)

        
        val bundle = TaskDetailFragmentArgs(completedTask.id).toBundle();
        val scenario = launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.Theme_AppCompat)

        
        scenario.onFragment {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText("Completed Task")))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.test.core.app.ActivityScenario
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.filters.LargeTest
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.custom.action.NavigationViewActions.navigateTo
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }

    @Test
    fun clickOnStatisticsNavigationItem_ShowsStatisticsScreen() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view)).perform(navigateTo(R.id.statistics_navigation_menu_item))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))
    }


















    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }























}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.filters.SdkSuppress

import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.currentActivity
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksScreenTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    
    @UiThreadTest
    @Before
    fun resetState() = runBlocking {
        (getApplicationContext() as TodoApplication).taskRepository.deleteAllTasks()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_opensAddTaskUi() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun addTaskToTasksList() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsComplete() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE3, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        FakeTasksRemoteDataSource.addTasks(Task(TITLE3, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun orientationChange_FilterActivePersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()

        
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun orientationChange_FilterCompletedPersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(string.label_completed)).check(matches(isDisplayed()))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_ChangePersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 

        
        currentActivity.rotateOrientation()

        
        onView(withId(R.id.add_task_title)).check(matches(withText(TITLE2)))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_NoDuplicate() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(DESCRIPTION),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewAllTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewCompletedTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewActiveTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp


open class Event<out T>(private val content: T) {

    var hasBeenHandled = false
        private set 

    
    fun getContentIfNotHandled(): T? {
        return if (hasBeenHandled) {
            null
        } else {
            hasBeenHandled = true
            content
        }
    }

    
    fun peekContent(): T = content
}

<code block>

package com.example.android.architecture.blueprints.todoapp.util



import android.app.Activity
import android.content.pm.ActivityInfo
import android.content.res.Configuration
import androidx.annotation.IdRes
import androidx.appcompat.app.ActionBar
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentTransaction
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProviders
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.ViewModelFactory


const val ADD_EDIT_RESULT_OK = Activity.RESULT_FIRST_USER + 1
const val DELETE_RESULT_OK = Activity.RESULT_FIRST_USER + 2
const val EDIT_RESULT_OK = Activity.RESULT_FIRST_USER + 3


fun AppCompatActivity.replaceFragmentInActivity(fragment: Fragment, frameId: Int) {
    supportFragmentManager.transact {
        replace(frameId, fragment)
    }
}


fun AppCompatActivity.addFragmentToActivity(fragment: Fragment, tag: String) {
    supportFragmentManager.transact {
        add(fragment, tag)
    }
}

fun AppCompatActivity.setupActionBar(@IdRes toolbarId: Int, action: ActionBar.() -> Unit) {
    setSupportActionBar(findViewById(toolbarId))
    supportActionBar?.run {
        action()
    }
}

fun <T : ViewModel> AppCompatActivity.obtainViewModel(viewModelClass: Class<T>): T {
    val repository = (application as TodoApplication).taskRepository
    return ViewModelProviders.of(this, ViewModelFactory(repository)).get(viewModelClass)
}


private inline fun FragmentManager.transact(action: FragmentTransaction.() -> Unit) {
    beginTransaction().apply {
        action()
    }.commit()
}

private fun AppCompatActivity.rotateToLandscape() {
    requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
}

private fun AppCompatActivity.rotateToPortrait() {
    requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
}

fun AppCompatActivity.rotateOrientation() {
    when (resources.configuration.orientation) {
        Configuration.ORIENTATION_LANDSCAPE -> rotateToPortrait()
        Configuration.ORIENTATION_PORTRAIT -> rotateToLandscape()
        else -> rotateToLandscape()
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private lateinit var statisticsViewModel: StatisticsViewModel

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.statistics_frag, container,
                false)
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        statisticsViewModel = (activity as StatisticsActivity).obtainViewModel()
        viewDataBinding.stats = statisticsViewModel
        viewDataBinding.setLifecycleOwner(this.viewLifecycleOwner)
    }

    override fun onResume() {
        super.onResume()
        statisticsViewModel.start()
    }

    companion object {
        fun newInstance() = StatisticsFragment()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.content.Intent
import android.os.Bundle
import android.view.MenuItem
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.GravityCompat
import androidx.drawerlayout.widget.DrawerLayout
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.tasks.TasksActivity
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.replaceFragmentInActivity
import com.example.android.architecture.blueprints.todoapp.util.setupActionBar
import com.google.android.material.navigation.NavigationView


class StatisticsActivity : AppCompatActivity() {

    private lateinit var drawerLayout: DrawerLayout

    override fun onOptionsItemSelected(item: MenuItem) =
            when (item.itemId) {
                android.R.id.home -> {
                    drawerLayout.openDrawer(GravityCompat.START)
                    true
                }
                else -> super.onOptionsItemSelected(item)
            }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.statistics_act)

        setupActionBar(R.id.toolbar) {
            setTitle(R.string.statistics_title)
            setHomeAsUpIndicator(R.drawable.ic_menu)
            setDisplayHomeAsUpEnabled(true)
        }

        setupNavigationDrawer()

        findOrCreateViewFragment()
    }

    private fun findOrCreateViewFragment() =
            supportFragmentManager.findFragmentById(R.id.contentFrame) ?:
                    StatisticsFragment.newInstance().also {
                        replaceFragmentInActivity(it, R.id.contentFrame)
                    }

    private fun setupNavigationDrawer() {
        drawerLayout = (findViewById<DrawerLayout>(R.id.drawer_layout)).apply {
            setStatusBarBackground(R.color.colorPrimaryDark)
        }
        setupDrawerContent(findViewById(R.id.nav_view))
    }

    private fun setupDrawerContent(navigationView: NavigationView) {
        navigationView.setNavigationItemSelectedListener { menuItem ->
            when (menuItem.itemId) {
                R.id.list_navigation_menu_item -> {
                    val intent = Intent(this@StatisticsActivity, TasksActivity::class.java)
                    startActivity(intent)
                }
                R.id.statistics_navigation_menu_item -> {
                    
                }
            }
            
            menuItem.isChecked = true
            drawerLayout.closeDrawers()
            true
        }
    }

    fun obtainViewModel(): StatisticsViewModel = obtainViewModel(StatisticsViewModel::class.java)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> =_dataLoading


    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdated = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdated

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        _dataLoading.value?.let { isLoading ->
            
            if (isLoading) return
        }
        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }
        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    internal fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription ?: "").isEmpty) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, currentTaskId)
                .apply { isCompleted = taskCompleted }
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) {
        viewModelScope.launch {
            tasksRepository.saveTask(newTask)
            _taskUpdated.value = Event(Unit)
        }
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdated.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.Observer
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.replaceFragmentInActivity
import com.example.android.architecture.blueprints.todoapp.util.setupActionBar


class AddEditTaskActivity : AppCompatActivity(), AddEditTaskNavigator {

    override fun onSupportNavigateUp(): Boolean {
        onBackPressed()
        return true
    }

    override fun onTaskSaved() {
        setResult(ADD_EDIT_RESULT_OK)
        finish()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.addtask_act)

        setupActionBar(R.id.toolbar) {
            setDisplayHomeAsUpEnabled(true)
            setDisplayShowHomeEnabled(true)
        }

        replaceFragmentInActivity(obtainViewFragment(), R.id.contentFrame)

        subscribeToNavigationChanges()
    }

    private fun subscribeToNavigationChanges() {
        
        obtainViewModel().taskUpdatedEvent.observe(this, Observer {
            this@AddEditTaskActivity.onTaskSaved()
        })
    }

    private fun obtainViewFragment() = supportFragmentManager.findFragmentById(R.id.contentFrame) ?:
            AddEditTaskFragment.newInstance().apply {
                arguments = Bundle().apply {
                    putString(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID,
                            intent.getStringExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID))
                }
            }

    fun obtainViewModel(): AddEditTaskViewModel = obtainViewModel(AddEditTaskViewModel::class.java)

    companion object {
        const val REQUEST_CODE = 1
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_LONG)
        }
        setupActionBar()
        loadData()
    }

    private fun loadData() {
        
        viewDataBinding.viewmodel?.start(arguments?.getString(ARGUMENT_EDIT_TASK_ID))
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            viewmodel = (activity as AddEditTaskActivity).obtainViewModel()
        }
        viewDataBinding.setLifecycleOwner(this.viewLifecycleOwner)
        setHasOptionsMenu(true)
        retainInstance = false
        return viewDataBinding.root
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_edit_task_done)?.let {
            it.setImageResource(R.drawable.ic_done)
            it.setOnClickListener { viewDataBinding.viewmodel?.saveTask() }
        }
    }

    private fun setupActionBar() {
        (activity as AppCompatActivity).supportActionBar?.setTitle(
                if (arguments != null && arguments?.get(ARGUMENT_EDIT_TASK_ID) != null)
                    R.string.edit_task
                else
                    R.string.add_task
        )
    }

    companion object {
        const val ARGUMENT_EDIT_TASK_ID = "EDIT_TASK_ID"

        fun newInstance() = AddEditTaskFragment()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Intent
import android.os.Bundle
import android.view.MenuItem
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.GravityCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.lifecycle.Observer
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskActivity
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsActivity
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailActivity
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.replaceFragmentInActivity
import com.example.android.architecture.blueprints.todoapp.util.setupActionBar
import com.google.android.material.navigation.NavigationView


class TasksActivity : AppCompatActivity(), TaskItemNavigator, TasksNavigator {

    private lateinit var drawerLayout: DrawerLayout

    private lateinit var viewModel: TasksViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.tasks_act)

        setupActionBar(R.id.toolbar) {
            setHomeAsUpIndicator(R.drawable.ic_menu)
            setDisplayHomeAsUpEnabled(true)
        }

        setupNavigationDrawer()

        setupViewFragment()

        viewModel = obtainViewModel().apply {
            openTaskEvent.observe(this@TasksActivity, Observer<Event<String>> { event ->
                event.getContentIfNotHandled()?.let {
                    openTaskDetails(it)

                }
            })
            
            newTaskEvent.observe(this@TasksActivity, Observer<Event<Unit>> { event ->
                event.getContentIfNotHandled()?.let {
                    this@TasksActivity.addNewTask()
                }
            })
        }
        viewModel.loadTasks(true)
    }

    private fun setupViewFragment() {
        supportFragmentManager.findFragmentById(R.id.contentFrame)
            ?: replaceFragmentInActivity(TasksFragment.newInstance(), R.id.contentFrame)
    }

    private fun setupNavigationDrawer() {
        drawerLayout = (findViewById<DrawerLayout>(R.id.drawer_layout))
            .apply {
                setStatusBarBackground(R.color.colorPrimaryDark)
            }
        setupDrawerContent(findViewById(R.id.nav_view))
    }

    override fun onOptionsItemSelected(item: MenuItem) =
            when (item.itemId) {
                android.R.id.home -> {
                    
                    drawerLayout.openDrawer(GravityCompat.START)
                    true
                }
                else -> super.onOptionsItemSelected(item)
            }

    private fun setupDrawerContent(navigationView: NavigationView) {
        navigationView.setNavigationItemSelectedListener { menuItem ->
            when (menuItem.itemId) {
                R.id.list_navigation_menu_item -> {
                    
                }
                R.id.statistics_navigation_menu_item -> {
                    val intent = Intent(this@TasksActivity, StatisticsActivity::class.java).apply {
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
                    }
                    startActivity(intent)
                }
            }
            
            menuItem.isChecked = true
            drawerLayout.closeDrawers()
            true
        }
    }

    public override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        viewModel.handleActivityResult(requestCode, resultCode)
    }

    override fun openTaskDetails(taskId: String) {
        val intent = Intent(this, TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, taskId)
        }
        startActivityForResult(intent, AddEditTaskActivity.REQUEST_CODE)

    }

    override fun addNewTask() {
        val intent = Intent(this, AddEditTaskActivity::class.java)
        startActivityForResult(intent, AddEditTaskActivity.REQUEST_CODE)
    }

    fun obtainViewModel(): TasksViewModel = obtainViewModel(TasksViewModel::class.java)
}
<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber
import java.util.ArrayList


class TasksFragment : Fragment() {

    private lateinit var viewDataBinding: TasksFragBinding
    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = (activity as TasksActivity).obtainViewModel()
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onResume() {
        super.onResume()
        viewDataBinding.viewmodel?.start()
    }

    override fun onOptionsItemSelected(item: MenuItem) =
            when (item.itemId) {
                R.id.menu_clear -> {
                    viewDataBinding.viewmodel?.clearCompletedTasks()
                    true
                }
                R.id.menu_filter -> {
                    showFilteringPopUpMenu()
                    true
                }
                R.id.menu_refresh -> {
                    viewDataBinding.viewmodel?.loadTasks(true)
                    true
                }
                else -> false
            }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_LONG)
        }
        viewDataBinding.setLifecycleOwner(this.viewLifecycleOwner)
        setupFab()
        setupListAdapter()
        setupRefreshLayout()
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewDataBinding.viewmodel?.run {
                    setFiltering(
                            when (it.itemId) {
                                R.id.active -> TasksFilterType.ACTIVE_TASKS
                                R.id.completed -> TasksFilterType.COMPLETED_TASKS
                                else -> TasksFilterType.ALL_TASKS
                            }
                    )
                    loadTasks(false)
                }
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setImageResource(R.drawable.ic_add)
            it.setOnClickListener {
                viewDataBinding.viewmodel?.addNewTask()
            }
        }
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(ArrayList(0), viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }

    private fun setupRefreshLayout() {
        viewDataBinding.refreshLayout.run {
            setColorSchemeColors(
                    ContextCompat.getColor(requireActivity(), R.color.colorPrimary),
                    ContextCompat.getColor(requireActivity(), R.color.colorAccent),
                    ContextCompat.getColor(requireActivity(), R.color.colorPrimaryDark)
            )
            
            scrollUpChild = viewDataBinding.tasksList
        }
    }

    companion object {
        fun newInstance() = TasksFragment()
        private const val TAG = "TasksFragment"

    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskActivity
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
    }

    fun start() {
        loadTasks(false)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.ic_assignment_turned_in_24dp, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_24dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_24dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) {
        
        viewModelScope.launch {
            if (completed) {
                tasksRepository.completeTask(task)
                showSnackbarMessage(R.string.task_marked_complete)
            } else {
                tasksRepository.activateTask(task)
                showSnackbarMessage(R.string.task_marked_active)
            }
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun handleActivityResult(requestCode: Int, resultCode: Int) {
        if (AddEditTaskActivity.REQUEST_CODE == requestCode) {
            when (resultCode) {
                EDIT_RESULT_OK -> _snackbarText.setValue(
                    Event(R.string.successfully_saved_task_message)
                )
                ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                    Event(R.string.successfully_added_task_message)
                )
                DELETE_RESULT_OK -> _snackbarText.setValue(
                    Event(R.string.successfully_deleted_task_message)
                )
            }
        }
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) = viewModelScope.launch {

        _dataLoading.value = true
        val tasksResult = tasksRepository.getTasks(forceUpdate)

        if (tasksResult is Success) {
            val tasks = tasksResult.data

            val tasksToShow = ArrayList<Task>()
            
            for (task in tasks) {
                when (_currentFiltering) {
                    TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                    TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                        tasksToShow.add(task)
                    }
                    TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                        tasksToShow.add(task)
                    }
                }
            }
            _dataLoading.value = false
            isDataLoadingError.value = false

            val itemsValue = ArrayList(tasksToShow)
            _items.value = itemsValue
        } else {
            _dataLoading.value = false
            isDataLoadingError.value = false
            _items.value = emptyList()
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import androidx.fragment.app.Fragment
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {

    private lateinit var viewDataBinding: TaskdetailFragBinding

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_LONG)
        }
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.fab_edit_task)?.setOnClickListener {
            viewDataBinding.viewmodel?.editTask()
        }
    }

    override fun onResume() {
        super.onResume()
        viewDataBinding.viewmodel?.start(arguments?.getString(ARGUMENT_TASK_ID))
    }

    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = (activity as TaskDetailActivity).obtainViewModel()
            listener = object : TaskDetailUserActionsListener {
                override fun onCompleteChanged(v: View) {
                    viewmodel?.setCompleted((v as CheckBox).isChecked)
                }
            }
        }
        viewDataBinding.setLifecycleOwner(this.viewLifecycleOwner)
        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewDataBinding.viewmodel?.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }

    companion object {

        const val ARGUMENT_TASK_ID = "TASK_ID"
        const val REQUEST_EDIT_TASK = 1

        fun newInstance(taskId: String) = TaskDetailFragment().apply {
            arguments = Bundle().apply {
                putString(ARGUMENT_TASK_ID, taskId)
            }
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.Observer
import android.content.Intent
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskActivity
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskFragment
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailFragment.Companion.REQUEST_EDIT_TASK
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.replaceFragmentInActivity
import com.example.android.architecture.blueprints.todoapp.util.setupActionBar


class TaskDetailActivity : AppCompatActivity(), TaskDetailNavigator {

    private lateinit var taskViewModel: TaskDetailViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.taskdetail_act)

        setupActionBar(R.id.toolbar) {
            setDisplayHomeAsUpEnabled(true)
            setDisplayShowHomeEnabled(true)
        }

        replaceFragmentInActivity(findOrCreateViewFragment(), R.id.contentFrame)

        taskViewModel = obtainViewModel()

        subscribeToNavigationChanges(taskViewModel)
    }

    private fun findOrCreateViewFragment() =
            supportFragmentManager.findFragmentById(R.id.contentFrame) ?:
                    TaskDetailFragment.newInstance(intent.getStringExtra(EXTRA_TASK_ID))

    private fun subscribeToNavigationChanges(viewModel: TaskDetailViewModel) {
        
        val activity = this@TaskDetailActivity
        viewModel.run {
            editTaskCommand.observe(activity,
                    Observer { activity.onStartEditTask() })
            deleteTaskCommand.observe(activity,
                    Observer { activity.onTaskDeleted() })
        }
    }

    public override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        if (requestCode == REQUEST_EDIT_TASK) {
            
            if (resultCode == ADD_EDIT_RESULT_OK) {
                
                setResult(EDIT_RESULT_OK)
                finish()
            }
        }
    }

    override fun onSupportNavigateUp(): Boolean {
        onBackPressed()
        return true
    }

    override fun onTaskDeleted() {
        setResult(DELETE_RESULT_OK)
        
        finish()
    }

    override fun onStartEditTask() {
        val taskId = intent.getStringExtra(EXTRA_TASK_ID)
        val intent = Intent(this, AddEditTaskActivity::class.java).apply {
            putExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID, taskId)
        }
        startActivityForResult(intent, REQUEST_EDIT_TASK)
    }

    fun obtainViewModel(): TaskDetailViewModel = obtainViewModel(TaskDetailViewModel::class.java)

    companion object {

        const val EXTRA_TASK_ID = "TASK_ID"

    }

}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.content.Context
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class StatisticsScreenTest {

    @Before
    fun setup() {
        
        val tasksRepository =
            ServiceLocator.provideTasksRepository(getApplicationContext())
        tasksRepository.run {
            runBlocking {
                deleteAllTasks()
                saveTask(Task("Title1").apply { isCompleted = false })
                saveTask(Task("Title2").apply { isCompleted = true })
            }
        }
    }

    @Test
    fun tasks_showsNonEmptyMessage() {
        val activityScenario = ActivityScenario.launch(StatisticsActivity::class.java)
        val expectedActiveTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_active_tasks, 1)
        val expectedCompletedTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_completed_tasks, 1)
        activityScenario.onActivity {
            
            onView(withId(R.id.stats_active_text)).check(matches(isDisplayed()))
            onView(withId(R.id.stats_active_text)).check(matches(withText(expectedActiveTaskText)))
            onView(withId(R.id.stats_completed_text)).check(matches(isDisplayed()))
            onView(withId(R.id.stats_completed_text)).check(matches(withText(expectedCompletedTaskText)))
        }
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Intent
import android.content.res.Resources
import android.view.View
import androidx.appcompat.widget.Toolbar
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.BoundedMatcher
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class AddEditTaskScreenTest {

    @Test
    @Ignore("hangs in robolectric, see issue #4724")
    fun emptyTask_isNotSaved() {
        val activityScenario = ActivityScenario.launch(AddEditTaskActivity::class.java)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        
        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun toolbarTitle_newTask_persistsRotation() {
        val activityScenario = ActivityScenario.launch(AddEditTaskActivity::class.java)

        
        onView(withId(R.id.toolbar)).check(matches(withToolbarTitle(R.string.add_task)))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withId(R.id.toolbar)).check(matches(withToolbarTitle(R.string.add_task)))
    }

    @Test
    fun toolbarTitle_editTask_persistsRotation() {
        val TASK_ID = "1"

        DefaultTasksRepository.destroyInstance()
        FakeTasksRemoteDataSource.addTasks(
                Task("title", "description", TASK_ID).apply { isCompleted = false }
        )

        val intent = Intent(getApplicationContext(),
                AddEditTaskActivity::class.java)
                .apply { putExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID, TASK_ID) }
        val activityScenario = ActivityScenario.launch<AddEditTaskActivity>(intent)

        
        onView(withId(R.id.toolbar)).check(matches(withToolbarTitle(R.string.edit_task)))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withId(R.id.toolbar)).check(matches(withToolbarTitle(R.string.edit_task)))
    }

    
    private fun withToolbarTitle(resourceId: Int): Matcher<View> =
            object : BoundedMatcher<View, Toolbar>(Toolbar::class.java) {

                override fun describeTo(description: Description) {
                    description.appendText("with toolbar title from resource id: ")
                    description.appendValue(resourceId)
                }

                override fun matchesSafely(toolbar: Toolbar): Boolean {
                    var expectedText = ""
                    try {
                        expectedText = toolbar.resources.getString(resourceId)
                    } catch (ignored: Resources.NotFoundException) {
                        
                    }
                    val actualText = toolbar.title
                    return expectedText == actualText
                }
            }

}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.content.Intent
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class TaskDetailScreenTest {

    private lateinit var activityScenario : ActivityScenario<TaskDetailActivity>

    @Before
    fun clearTaskRepository() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            runBlocking {
                deleteAllTasks()
            }
        }
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        FakeTasksRemoteDataSource.addTasks(ACTIVE_TASK)

        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, ACTIVE_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
        }
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        FakeTasksRemoteDataSource.addTasks(COMPLETED_TASK)

        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, COMPLETED_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
        }
    }

    @Test
    fun orientationChange_menuAndTaskPersist() {
        FakeTasksRemoteDataSource.addTasks(ACTIVE_TASK)

        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, ACTIVE_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.menu_delete)).check(matches(isDisplayed()))

            it.rotateOrientation()

            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
            
            onView(withId(R.id.menu_delete)).check(matches(isDisplayed()))
        }
    }

    companion object {

        private val TASK_TITLE = "AndroidX Test"

        private val TASK_DESCRIPTION = "Rocks"

        
        private val ACTIVE_TASK = Task(TASK_TITLE, TASK_DESCRIPTION).apply {
            isCompleted = false
        }

        
        private val COMPLETED_TASK = Task(TASK_TITLE, TASK_DESCRIPTION).apply {
            isCompleted = true
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.test.core.app.ActivityScenario
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.filters.LargeTest
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.custom.action.NavigationViewActions.navigateTo
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsActivity
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }

    @Test
    fun clickOnStatisticsNavigationItem_ShowsStatisticsScreen() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view)).perform(navigateTo(R.id.statistics_navigation_menu_item))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))
    }

    @Test
    fun clickOnListNavigationItem_ShowsListScreen() {
        
        val activityScenario = ActivityScenario.launch(StatisticsActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.list_navigation_menu_item))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(StatisticsActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.appcompat.widget.Toolbar
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.filters.SdkSuppress

import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.currentActivity
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksScreenTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    
    @UiThreadTest
    @Before
    fun resetState() = runBlocking {
        (getApplicationContext() as TodoApplication).taskRepository.deleteAllTasks()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    private fun ActivityScenario<TasksActivity>.getToolbarNavigationContentDescription() : String {
        var description = ""
        onActivity {
            description = it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_opensAddTaskUi() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun addTaskToTasksList() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsComplete() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE3, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        FakeTasksRemoteDataSource.addTasks(Task(TITLE3, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription())).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription())).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription()))
            .perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription())).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun orientationChange_FilterActivePersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()

        
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun orientationChange_FilterCompletedPersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(string.label_completed)).check(matches(isDisplayed()))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_ChangePersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 

        
        currentActivity.rotateOrientation()

        
        onView(withId(R.id.add_task_title)).check(matches(withText(TITLE2)))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_NoDuplicate() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(DESCRIPTION),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewAllTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewCompletedTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewActiveTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}
<code block>


package com.example.android.architecture.blueprints.todoapp.util


sealed class Async<out T> {
    object Loading : Async<Nothing>()

    data class Error(val errorMessage: Int) : Async<Nothing>()

    data class Success<out T>(val data: T) : Async<T>()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(task: Task)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksDataSource {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(task: Task)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksRepository {

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            updateTasksFromRemoteDataSource()
        }
        return tasksLocalDataSource.getTasks()
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return tasksLocalDataSource.getTasksStream()
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksRemoteDataSource.getTasks()

        
        tasksLocalDataSource.deleteAllTasks()
        remoteTasks.forEach { task ->
            tasksLocalDataSource.saveTask(task)
        }
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return tasksLocalDataSource.getTaskStream(taskId)
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksRemoteDataSource.getTask(taskId)

        if (remoteTask == null) {
            tasksLocalDataSource.deleteTask(taskId)
        } else {
            tasksLocalDataSource.saveTask(remoteTask)
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksLocalDataSource.getTask(taskId)
    }

    override suspend fun saveTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.saveTask(task) }
            launch { tasksLocalDataSource.saveTask(task) }
        }
    }

    override suspend fun completeTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.completeTask(task) }
            launch { tasksLocalDataSource.completeTask(task) }
        }
    }

    override suspend fun completeTask(taskId: String) {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let { completeTask(it) }
        }
    }

    override suspend fun activateTask(task: Task) = withContext<Unit>(ioDispatcher) {
        coroutineScope {
            launch { tasksRemoteDataSource.activateTask(task) }
            launch { tasksLocalDataSource.activateTask(task) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let { activateTask(it) }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        withContext(ioDispatcher) {
            coroutineScope {
                launch { tasksRemoteDataSource.deleteAllTasks() }
                launch { tasksLocalDataSource.deleteAllTasks() }
            }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }
    }

    private suspend fun getTaskWithId(id: String): Task? {
        return tasksLocalDataSource.getTask(id)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext


class TasksLocalDataSource internal constructor(
    private val tasksDao: TasksDao,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksDataSource {

    override fun getTasksStream() = tasksDao.observeTasks()

    override fun getTaskStream(taskId: String) = tasksDao.observeTaskById(taskId)

    override suspend fun refreshTask(taskId: String) {
        
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun getTasks(): List<Task> = withContext(ioDispatcher) {
        return@withContext tasksDao.getTasks()
    }

    override suspend fun getTask(taskId: String): Task? = withContext(ioDispatcher) {
        return@withContext tasksDao.getTaskById(taskId)
    }

    override suspend fun saveTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.insertTask(task)
    }

    override suspend fun completeTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.updateCompleted(task.id, true)
    }

    override suspend fun completeTask(taskId: String) {
        tasksDao.updateCompleted(taskId, true)
    }

    override suspend fun activateTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.updateCompleted(task.id, false)
    }

    override suspend fun activateTask(taskId: String) {
        tasksDao.updateCompleted(taskId, false)
    }

    override suspend fun clearCompletedTasks() = withContext<Unit>(ioDispatcher) {
        tasksDao.deleteCompletedTasks()
    }

    override suspend fun deleteAllTasks() = withContext(ioDispatcher) {
        tasksDao.deleteTasks()
    }

    override suspend fun deleteTask(taskId: String) = withContext<Unit>(ioDispatcher) {
        tasksDao.deleteTaskById(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking


object TasksRemoteDataSource : TasksDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, Task>(2)

    init {
        addTask("Build tower in Pisa", "Ground looks good, no foundation work required.")
        addTask("Finish bridge in Tacoma", "Found awesome girders at half the cost!")
    }

    private val observableTasks = MutableStateFlow(runBlocking { getTasks() })

    override suspend fun refreshTasks() {
        observableTasks.value = getTasks()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return observableTasks
    }

    override suspend fun getTasks(): List<Task> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun getTask(taskId: String): Task? {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        return TASKS_SERVICE_DATA[taskId]
    }

    private fun addTask(title: String, description: String) {
        val newTask = Task(title, description)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        TASKS_SERVICE_DATA[task.id] = completedTask
    }

    override suspend fun completeTask(taskId: String) {
        
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        TASKS_SERVICE_DATA[task.id] = activeTask
    }

    override suspend fun activateTask(taskId: String) {
        
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import com.example.android.architecture.blueprints.todoapp.data.Task


internal fun getActiveAndCompletedStats(tasks: List<Task>): StatsResult {

    return if (tasks.isEmpty()) {
        StatsResult(0f, 0f)
    } else {
        val totalTasks = tasks.size
        val numberOfActiveTasks = tasks.count { it.isActive }
        StatsResult(
            activeTasksPercent = 100f * numberOfActiveTasks / tasks.size,
            completedTasksPercent = 100f * (totalTasks - numberOfActiveTasks) / tasks.size
        )
    }
}

data class StatsResult(val activeTasksPercent: Float, val completedTasksPercent: Float)

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        tasksRepository.getTasksStream()
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            tasksRepository.refreshTasks()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<List<Task>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Error -> {
                
                StatisticsUiState(isEmpty = true, isLoading = false)
            }
            is Async.Success -> {
                val stats = getActiveAndCompletedStats(taskLoad.data)
                StatisticsUiState(
                    isEmpty = taskLoad.data.isEmpty(),
                    activeTasksPercent = stats.activeTasksPercent,
                    completedTasksPercent = stats.completedTasksPercent,
                    isLoading = false
                )
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch


data class AddEditTaskUiState(
    val title: String = "",
    val description: String = "",
    val isTaskCompleted: Boolean = false,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskSaved: Boolean = false
)


@HiltViewModel
class AddEditTaskViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val taskId: String? = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]

    
    
    
    private val _uiState = MutableStateFlow(AddEditTaskUiState())
    val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

    init {
        if (taskId != null) {
            loadTask(taskId)
        }
    }

    
    fun saveTask() {
        if (uiState.value.title.isEmpty() || uiState.value.description.isEmpty()) {
            _uiState.update {
                it.copy(userMessage = R.string.empty_task_message)
            }
            return
        }

        if (taskId == null) {
            createNewTask()
        } else {
            updateTask()
        }
    }

    fun snackbarMessageShown() {
        _uiState.update {
            it.copy(userMessage = null)
        }
    }

    fun updateTitle(newTitle: String) {
        _uiState.update {
            it.copy(title = newTitle)
        }
    }

    fun updateDescription(newDescription: String) {
        _uiState.update {
            it.copy(description = newDescription)
        }
    }

    private fun createNewTask() = viewModelScope.launch {
        val newTask = Task(uiState.value.title, uiState.value.description)
        tasksRepository.saveTask(newTask)
        _uiState.update {
            it.copy(isTaskSaved = true)
        }
    }

    private fun updateTask() {
        if (taskId == null) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            val updatedTask = Task(
                title = uiState.value.title,
                description = uiState.value.description,
                isCompleted = uiState.value.isTaskCompleted,
                id = taskId
            )
            tasksRepository.saveTask(updatedTask)
            _uiState.update {
                it.copy(isTaskSaved = true)
            }
        }
    }

    private fun loadTask(taskId: String) {
        _uiState.update {
            it.copy(isLoading = true)
        }
        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { task ->
                if (task != null) {
                    _uiState.update {
                        it.copy(
                            title = task.title,
                            description = task.description,
                            isTaskCompleted = task.isCompleted,
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(isLoading = false)
                    }
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(tasksRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TaskDetailUiState(
    val task: Task? = null,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskDeleted: Boolean = false
)


@HiltViewModel
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    val taskId: String = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]!!

    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _isTaskDeleted = MutableStateFlow(false)
    private val _taskAsync = tasksRepository.getTaskStream(taskId)
        .map { handleTask(it) }
        .catch { emit(Async.Error(R.string.loading_task_error)) }

    val uiState: StateFlow<TaskDetailUiState> = combine(
        _userMessage, _isLoading, _isTaskDeleted, _taskAsync
    ) { userMessage, isLoading, isTaskDeleted, taskAsync ->
        when (taskAsync) {
            Async.Loading -> {
                TaskDetailUiState(isLoading = true)
            }
            is Async.Error -> {
                TaskDetailUiState(
                    userMessage = taskAsync.errorMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
            is Async.Success -> {
                TaskDetailUiState(
                    task = taskAsync.data,
                    isLoading = isLoading,
                    userMessage = userMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TaskDetailUiState(isLoading = true)
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted.value = true
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = uiState.value.task ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTask(taskId)
            _isLoading.value = false
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    private fun handleTask(task: Task?): Async<Task?> {
        if (task == null) {
            return Async.Error(R.string.task_not_found)
        }
        return Async.Success(task)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

object FakeFailingTasksRemoteDataSource : TasksDataSource {
    override suspend fun getTasks(): List<Task> {
        throw Exception("Test")
    }

    override suspend fun getTask(taskId: String): Task? {
        throw Exception("Test")
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return flow { emit(getTasks()) }
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return flow { emit(getTask(taskId)) }
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun saveTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun activateTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun activateTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun clearCompletedTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteAllTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task("Title1", "Description1")
    private val task2 = Task("Title2", "Description2")
    private val task3 = Task("Title3", "Description3")
    private val newTask = Task("Title new", "Description new")
    private val remoteTasks = listOf(task1, task2).sortedBy { it.id }
    private val localTasks = listOf(task3).sortedBy { it.id }
    private val newTasks = listOf(newTask).sortedBy { it.id }
    private lateinit var tasksRemoteDataSource: FakeDataSource
    private lateinit var tasksLocalDataSource: FakeDataSource

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksRemoteDataSource = FakeDataSource(remoteTasks.toMutableList())
        tasksLocalDataSource = FakeDataSource(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksRemoteDataSource, tasksLocalDataSource, Dispatchers.Main
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptySource = FakeDataSource()
        val tasksRepository = DefaultTasksRepository(
            emptySource, emptySource, Dispatchers.Main
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(remoteTasks)
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksRemoteDataSource.tasks).doesNotContain(newTask)
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask)

        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRemoteDataSource.tasks).contains(newTask)
        assertThat(tasksLocalDataSource.tasks).contains(newTask)
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        tasksRemoteDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksRemoteDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks)
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        tasksRemoteDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = tasksRepository.getTasks(true)

        assertThat(newTasks).isEqualTo(remoteTasks)
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks)
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksLocalDataSource.tasks = mutableListOf(task1)
        val initial = tasksRepository.getTask(task1.id)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksRemoteDataSource.tasks = mutableListOf(task1)
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        tasksRemoteDataSource.tasks = mutableListOf(task2)

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy().apply { isCompleted = true }
        tasksRemoteDataSource.tasks = mutableListOf(completedTask, task2)
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow

class FakeDataSource(var tasks: MutableList<Task>? = mutableListOf()) : TasksDataSource {
    override suspend fun getTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTask(taskId: String) = tasks?.firstOrNull { it.id == taskId }

    override suspend fun saveTask(task: Task) {
        tasks?.add(task)
    }

    override suspend fun completeTask(task: Task) {
        tasks?.firstOrNull { it.id == task.id }?.let { it.isCompleted = true }
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = true }
    }

    override suspend fun activateTask(task: Task) {
        tasks?.firstOrNull { it.id == task.id }?.let { it.isCompleted = false }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = false }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.isCompleted }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }

    override fun getTasksStream(): Flow<List<Task>> {
        TODO("not implemented")
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task> {
        TODO("not implemented")
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import com.example.android.architecture.blueprints.todoapp.data.Task
import org.hamcrest.core.Is.`is`
import org.junit.Assert.assertThat
import org.junit.Test


class StatisticsUtilsTest {

    @Test
    fun getActiveAndCompletedStats_noCompleted() {
        val tasks = listOf(
            Task("title", "desc", isCompleted = false)
        )
        
        val result = getActiveAndCompletedStats(tasks)

        
        assertThat(result.activeTasksPercent, `is`(100f))
        assertThat(result.completedTasksPercent, `is`(0f))
    }

    @Test
    fun getActiveAndCompletedStats_noActive() {
        val tasks = listOf(
            Task("title", "desc", isCompleted = true)
        )
        
        val result = getActiveAndCompletedStats(tasks)

        
        assertThat(result.activeTasksPercent, `is`(0f))
        assertThat(result.completedTasksPercent, `is`(100f))
    }

    @Test
    fun getActiveAndCompletedStats_both() {
        
        val tasks = listOf(
            Task("title", "desc", isCompleted = true),
            Task("title", "desc", isCompleted = true),
            Task("title", "desc", isCompleted = true),
            Task("title", "desc", isCompleted = false),
            Task("title", "desc", isCompleted = false)
        )
        
        val result = getActiveAndCompletedStats(tasks)

        
        assertThat(result.activeTasksPercent, `is`(40f))
        assertThat(result.completedTasksPercent, `is`(60f))
    }

    @Test
    fun getActiveAndCompletedStats_empty() {
        
        val result = getActiveAndCompletedStats(emptyList())

        
        assertThat(result.activeTasksPercent, `is`(0f))
        assertThat(result.completedTasksPercent, `is`(0f))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository, SavedStateHandle())
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(2)
    }

    @Test
    fun loadTasks_error() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).isEmpty()
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_tasks_error)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = runTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.refresh()

        
        val allTasks = tasksViewModel.uiState.first().items
        val completedTasks = allTasks?.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.completed_tasks_cleared)
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_saved_task_message)
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_added_task_message)
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isActive).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() = runTest {
        val uiState = taskDetailViewModel.uiState.first()
        
        assertThat(uiState.task?.title).isEqualTo(task.title)
        assertThat(uiState.task?.description).isEqualTo(task.description)
    }

    @Test
    fun completeTask() = runTest {
        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isFalse()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask() = runTest {
        task.isCompleted = true

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(false)

        
        val newTask = tasksRepository.getTask(task.id)
        assertTrue((newTask?.isActive) ?: false)
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }

    @Test
    fun taskDetailViewModel_repositoryError() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_task_error)
    }

    @Test
    fun taskDetailViewModel_taskNotFound() = runTest {
        
        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "nonexistent_id"))
        )

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_not_found)
    }

    @Test
    fun deleteTask() = runTest {
        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isTrue()

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            taskDetailViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeRepository : TasksRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = completedTask
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        
        throw NotImplementedError()
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = activeTask
            newTasks
        }
    }

    override suspend fun activateTask(taskId: String) {
        throw NotImplementedError()
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.nullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@MediumTest
class TasksLocalDataSourceTest {

    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            ToDoDatabase::class.java
        )
            .allowMainThreadQueries()
            .build()

        localDataSource = TasksLocalDataSource(database.taskDao(), Dispatchers.Main)
    }

    @After
    fun cleanUp() {
        database.close()
    }

    @Test
    fun saveTask_retrievesTask() = runTest {
        
        val newTask = Task("title", "description", true)
        localDataSource.saveTask(newTask)

        
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`("title"))
        assertThat(task?.description, `is`("description"))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun completeTask_retrievedTaskIsComplete() = runTest {
        
        val newTask = Task("title")
        localDataSource.saveTask(newTask)

        
        localDataSource.completeTask(newTask)
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`(newTask.title))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun activateTask_retrievedTaskIsActive() = runTest {
        
        val newTask = Task("Some title", "Some description", true)
        localDataSource.saveTask(newTask)

        localDataSource.activateTask(newTask)

        
        val task = localDataSource.getTask(newTask.id)

        assertThat(task?.title, `is`("Some title"))
        assertThat(task?.isCompleted, `is`(false))
    }

    @Test
    fun clearCompletedTask_taskNotRetrievable() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title2")
        val newTask3 = Task("title3")
        localDataSource.saveTask(newTask1)
        localDataSource.completeTask(newTask1)
        localDataSource.saveTask(newTask2)
        localDataSource.completeTask(newTask2)
        localDataSource.saveTask(newTask3)
        
        localDataSource.clearCompletedTasks()

        
        assertThat(localDataSource.getTask(newTask1.id), `is`(nullValue()))
        assertThat(localDataSource.getTask(newTask2.id), `is`(nullValue()))

        val result3 = localDataSource.getTask(newTask3.id)
        assertThat(result3, `is`(newTask3))
    }

    @Test
    fun deleteAllTasks_emptyListOfRetrievedTask() = runTest {
        
        val newTask = Task("title")

        localDataSource.saveTask(newTask)

        
        localDataSource.deleteAllTasks()

        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun getTasks_retrieveSavedTasks() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title")

        localDataSource.saveTask(newTask1)
        localDataSource.saveTask(newTask2)
        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.size, `is`(2))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@HiltAndroidTest
class AddEditTaskScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()

        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository, SavedStateHandle()),
                        topBarTitle = R.string.add_task,
                        onTaskUpdate = { },
                        onBack = { },
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = repository.getTasksBlocking(true)
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.util


sealed class Async<out T> {
    object Loading : Async<Nothing>()
    data class Success<out T>(val data: T) : Async<T>()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.Result.Success


sealed class Result<out R> {

    data class Success<out T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()

    override fun toString(): String {
        return when (this) {
            is Success<*> -> "Success[data=$data]"
            is Error -> "Error[exception=$exception]"
        }
    }
}


val Result<*>.succeeded
    get() = this is Success && data != null

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<Result<List<Task>>>

    suspend fun getTasks(forceUpdate: Boolean = false): Result<List<Task>>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Result<Task>>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Result<Task>

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(task: Task)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksDataSource {

    fun getTasksStream(): Flow<Result<List<Task>>>

    suspend fun getTasks(): Result<List<Task>>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Result<Task>>

    suspend fun getTask(taskId: String): Result<Task>

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(task: Task)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksRepository {

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        if (forceUpdate) {
            try {
                updateTasksFromRemoteDataSource()
            } catch (ex: Exception) {
                return Result.Error(ex)
            }
        }
        return tasksLocalDataSource.getTasks()
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<Result<List<Task>>> {
        return tasksLocalDataSource.getTasksStream()
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksRemoteDataSource.getTasks()

        if (remoteTasks is Success) {
            
            tasksLocalDataSource.deleteAllTasks()
            remoteTasks.data.forEach { task ->
                tasksLocalDataSource.saveTask(task)
            }
        } else if (remoteTasks is Result.Error) {
            throw remoteTasks.exception
        }
    }

    override fun getTaskStream(taskId: String): Flow<Result<Task>> {
        return tasksLocalDataSource.getTaskStream(taskId)
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksRemoteDataSource.getTask(taskId)

        if (remoteTask is Success) {
            tasksLocalDataSource.saveTask(remoteTask.data)
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksLocalDataSource.getTask(taskId)
    }

    override suspend fun saveTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.saveTask(task) }
            launch { tasksLocalDataSource.saveTask(task) }
        }
    }

    override suspend fun completeTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.completeTask(task) }
            launch { tasksLocalDataSource.completeTask(task) }
        }
    }

    override suspend fun completeTask(taskId: String) {
        withContext(ioDispatcher) {
            (getTaskWithId(taskId) as? Success)?.let { it ->
                completeTask(it.data)
            }
        }
    }

    override suspend fun activateTask(task: Task) = withContext<Unit>(ioDispatcher) {
        coroutineScope {
            launch { tasksRemoteDataSource.activateTask(task) }
            launch { tasksLocalDataSource.activateTask(task) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        withContext(ioDispatcher) {
            (getTaskWithId(taskId) as? Success)?.let { it ->
                activateTask(it.data)
            }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        withContext(ioDispatcher) {
            coroutineScope {
                launch { tasksRemoteDataSource.deleteAllTasks() }
                launch { tasksLocalDataSource.deleteAllTasks() }
            }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }
    }

    private suspend fun getTaskWithId(id: String): Result<Task> {
        return tasksLocalDataSource.getTask(id)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext


class TasksLocalDataSource internal constructor(
    private val tasksDao: TasksDao,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksDataSource {

    override fun getTasksStream(): Flow<Result<List<Task>>> {
        return tasksDao.observeTasks().map {
            Success(it)
        }
    }

    override fun getTaskStream(taskId: String): Flow<Result<Task>> {
        return tasksDao.observeTaskById(taskId).map {
            Success(it)
        }
    }

    override suspend fun refreshTask(taskId: String) {
        
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun getTasks(): Result<List<Task>> = withContext(ioDispatcher) {
        return@withContext try {
            Success(tasksDao.getTasks())
        } catch (e: Exception) {
            Error(e)
        }
    }

    override suspend fun getTask(taskId: String): Result<Task> = withContext(ioDispatcher) {
        try {
            val task = tasksDao.getTaskById(taskId)
            if (task != null) {
                return@withContext Success(task)
            } else {
                return@withContext Error(Exception("Task not found!"))
            }
        } catch (e: Exception) {
            return@withContext Error(e)
        }
    }

    override suspend fun saveTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.insertTask(task)
    }

    override suspend fun completeTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.updateCompleted(task.id, true)
    }

    override suspend fun completeTask(taskId: String) {
        tasksDao.updateCompleted(taskId, true)
    }

    override suspend fun activateTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.updateCompleted(task.id, false)
    }

    override suspend fun activateTask(taskId: String) {
        tasksDao.updateCompleted(taskId, false)
    }

    override suspend fun clearCompletedTasks() = withContext<Unit>(ioDispatcher) {
        tasksDao.deleteCompletedTasks()
    }

    override suspend fun deleteAllTasks() = withContext(ioDispatcher) {
        tasksDao.deleteTasks()
    }

    override suspend fun deleteTask(taskId: String) = withContext<Unit>(ioDispatcher) {
        tasksDao.deleteTaskById(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking


object TasksRemoteDataSource : TasksDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, Task>(2)

    init {
        addTask("Build tower in Pisa", "Ground looks good, no foundation work required.")
        addTask("Finish bridge in Tacoma", "Found awesome girders at half the cost!")
    }

    private val observableTasks = MutableStateFlow(runBlocking { getTasks() })

    override suspend fun refreshTasks() {
        observableTasks.value = getTasks()
    }

    override fun getTaskStream(taskId: String): Flow<Result<Task>> {
        return observableTasks.map { tasks ->
            when (tasks) {
                is Error -> Error(tasks.exception)
                is Success -> {
                    val task = tasks.data.firstOrNull() { it.id == taskId }
                        ?: return@map Error(Exception("Not found"))
                    Success(task)
                }
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<Result<List<Task>>> {
        return observableTasks
    }

    override suspend fun getTasks(): Result<List<Task>> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return Success(tasks)
    }

    override suspend fun getTask(taskId: String): Result<Task> {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        TASKS_SERVICE_DATA[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Task not found"))
    }

    private fun addTask(title: String, description: String) {
        val newTask = Task(title, description)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        TASKS_SERVICE_DATA[task.id] = completedTask
    }

    override suspend fun completeTask(taskId: String) {
        
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        TASKS_SERVICE_DATA[task.id] = activeTask
    }

    override suspend fun activateTask(taskId: String) {
        
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import com.example.android.architecture.blueprints.todoapp.data.Task


internal fun getActiveAndCompletedStats(tasks: List<Task>?): StatsResult {

    return if (tasks == null || tasks.isEmpty()) {
        StatsResult(0f, 0f)
    } else {
        val totalTasks = tasks.size
        val numberOfActiveTasks = tasks.count { it.isActive }
        StatsResult(
            activeTasksPercent = 100f * numberOfActiveTasks / tasks.size,
            completedTasksPercent = 100f * (totalTasks - numberOfActiveTasks) / tasks.size
        )
    }
}

data class StatsResult(val activeTasksPercent: Float, val completedTasksPercent: Float)

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        tasksRepository.getTasksStream()
            .map { Async.Success(it) }
            .onStart<Async<Result<List<Task>>>> { emit(Async.Loading) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            tasksRepository.refreshTasks()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<Result<List<Task>>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Success -> {
                when (val result = taskLoad.data) {
                    is Success -> {
                        val stats = getActiveAndCompletedStats(result.data)
                        StatisticsUiState(
                            isEmpty = result.data.isEmpty(),
                            activeTasksPercent = stats.activeTasksPercent,
                            completedTasksPercent = stats.completedTasksPercent,
                            isLoading = false
                        )
                    }
                    else -> StatisticsUiState(isLoading = false)
                }
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch


data class AddEditTaskUiState(
    val title: String = "",
    val description: String = "",
    val isTaskCompleted: Boolean = false,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskSaved: Boolean = false
)


@HiltViewModel
class AddEditTaskViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val taskId: String? = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]

    
    
    
    private val _uiState = MutableStateFlow(AddEditTaskUiState())
    val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

    init {
        if (taskId != null) {
            loadTask(taskId)
        }
    }

    
    fun saveTask() {
        if (uiState.value.title.isEmpty() || uiState.value.description.isEmpty()) {
            _uiState.update {
                it.copy(userMessage = R.string.empty_task_message)
            }
            return
        }

        if (taskId == null) {
            createNewTask()
        } else {
            updateTask()
        }
    }

    fun snackbarMessageShown() {
        _uiState.update {
            it.copy(userMessage = null)
        }
    }

    fun updateTitle(newTitle: String) {
        _uiState.update {
            it.copy(title = newTitle)
        }
    }

    fun updateDescription(newDescription: String) {
        _uiState.update {
            it.copy(description = newDescription)
        }
    }

    private fun createNewTask() = viewModelScope.launch {
        val newTask = Task(uiState.value.title, uiState.value.description)
        tasksRepository.saveTask(newTask)
        _uiState.update {
            it.copy(isTaskSaved = true)
        }
    }

    private fun updateTask() {
        if (taskId == null) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            val updatedTask = Task(
                title = uiState.value.title,
                description = uiState.value.description,
                isCompleted = uiState.value.isTaskCompleted,
                id = taskId
            )
            tasksRepository.saveTask(updatedTask)
            _uiState.update {
                it.copy(isTaskSaved = true)
            }
        }
    }

    private fun loadTask(taskId: String) {
        _uiState.update {
            it.copy(isLoading = true)
        }
        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    val task = result.data
                    _uiState.update {
                        it.copy(
                            title = task.title,
                            description = task.description,
                            isTaskCompleted = task.isCompleted,
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(isLoading = false)
                    }
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(tasksRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .onStart<Async<List<Task>>> { emit(Async.Loading) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(
        tasksResult: Result<List<Task>>,
        filteringType: TasksFilterType
    ): List<Task> = if (tasksResult is Success) {
        filterItems(tasksResult.data, filteringType)
    } else {
        showSnackbarMessage(R.string.loading_tasks_error)
        emptyList()
    }

    private fun filterItems(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TaskDetailUiState(
    val task: Task? = null,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskDeleted: Boolean = false
)


@HiltViewModel
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    val taskId: String = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]!!

    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _isTaskDeleted = MutableStateFlow(false)
    private val _taskAsync = tasksRepository.getTaskStream(taskId)
        .map { handleResult(it) }
        .onStart { emit(Async.Loading) }

    val uiState: StateFlow<TaskDetailUiState> = combine(
        _userMessage, _isLoading, _isTaskDeleted, _taskAsync
    ) { userMessage, isLoading, isTaskDeleted, taskAsync ->
        when (taskAsync) {
            Async.Loading -> {
                TaskDetailUiState(isLoading = true)
            }
            is Async.Success -> {
                TaskDetailUiState(
                    task = taskAsync.data,
                    isLoading = isLoading,
                    userMessage = userMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TaskDetailUiState(isLoading = true)
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted.value = true
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = uiState.value.task ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTask(taskId)
            _isLoading.value = false
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    private fun handleResult(tasksResult: Result<Task>): Async<Task?> =
        if (tasksResult is Success) {
            Async.Success(tasksResult.data)
        } else {
            showSnackbarMessage(R.string.loading_tasks_error)
            Async.Success(null)
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

object FakeFailingTasksRemoteDataSource : TasksDataSource {
    override suspend fun getTasks(): Result<List<Task>> {
        return Result.Error(Exception("Test"))
    }

    override suspend fun getTask(taskId: String): Result<Task> {
        return Result.Error(Exception("Test"))
    }

    override fun getTasksStream(): Flow<Result<List<Task>>> {
        return flow { emit(getTasks()) }
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Result<Task>> {
        return flow { emit(getTask(taskId)) }
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun saveTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun activateTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun activateTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun clearCompletedTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteAllTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task("Title1", "Description1")
    private val task2 = Task("Title2", "Description2")
    private val task3 = Task("Title3", "Description3")
    private val newTask = Task("Title new", "Description new")
    private val remoteTasks = listOf(task1, task2).sortedBy { it.id }
    private val localTasks = listOf(task3).sortedBy { it.id }
    private val newTasks = listOf(task3).sortedBy { it.id }
    private lateinit var tasksRemoteDataSource: FakeDataSource
    private lateinit var tasksLocalDataSource: FakeDataSource

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksRemoteDataSource = FakeDataSource(remoteTasks.toMutableList())
        tasksLocalDataSource = FakeDataSource(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksRemoteDataSource, tasksLocalDataSource, Dispatchers.Main
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptySource = FakeDataSource()
        val tasksRepository = DefaultTasksRepository(
            emptySource, emptySource, Dispatchers.Main
        )

        assertThat(tasksRepository.getTasks() is Success).isTrue()
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks()

        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        val second = tasksRepository.getTasks()

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true) as Success

        
        assertThat(tasks.data).isEqualTo(remoteTasks)
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksRemoteDataSource.tasks).doesNotContain(newTask)
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask)

        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRemoteDataSource.tasks).contains(newTask)
        assertThat(tasksLocalDataSource.tasks).contains(newTask)
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true) as Success

        
        assertThat(refreshedTasks.data).isEqualTo(newTasks)
    }

    @Test
    fun getTasks_WithDirtyCache_remoteUnavailable_error() = runTest {
        
        tasksRemoteDataSource.tasks = null

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isInstanceOf(Result.Error::class.java)
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksRemoteDataSource.tasks = null

            
            assertThat((tasksRepository.getTasks() as Success).data).isEqualTo(localTasks)
        }

    @Test
    fun getTasks_WithBothDataSourcesUnavailable_returnsError() = runTest {
        
        tasksRemoteDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        assertThat(tasksRepository.getTasks()).isInstanceOf(Result.Error::class.java)
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = (tasksRepository.getTasks(true) as Success).data

        assertThat(newTasks).isEqualTo(remoteTasks)
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks)
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)

        
        assertThat((tasksRepository.getTask(newTask.id) as Success).data.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat((tasksRepository.getTask(newTask.id) as Success).data.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)
        tasksRepository.completeTask(newTask.id)

        
        assertThat((tasksRepository.getTask(newTask.id) as Success).data.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        val result = tasksRepository.getTask(newTask.id) as Success
        assertThat(result.data.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksRemoteDataSource.tasks = mutableListOf(task1)
        tasksRepository.getTask(task1.id, true)

        
        tasksRemoteDataSource.tasks = mutableListOf(task2)

        val task1SecondTime = tasksRepository.getTask(task1.id, true) as Success
        val task2SecondTime = tasksRepository.getTask(task2.id, true) as Success

        
        assertThat(task1SecondTime.data.id).isEqualTo(task1.id)
        assertThat(task2SecondTime.data.id).isEqualTo(task2.id)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksRemoteDataSource.tasks = mutableListOf(task1)
        tasksRepository.getTask(task1.id)

        
        tasksRemoteDataSource.tasks = mutableListOf(task2)

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat((task1SecondTime as? Success)?.data?.id).isNull()
        assertThat((task2SecondTime as? Success)?.data?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy().apply { isCompleted = true }
        tasksRemoteDataSource.tasks = mutableListOf(completedTask, task2)
        tasksRepository.clearCompletedTasks()

        val tasks = (tasksRepository.getTasks(true) as? Success)?.data

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = (tasksRepository.getTasks() as? Success)?.data

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = (tasksRepository.getTasks() as? Success)?.data

        
        assertThat(initialTasks).isNotEmpty()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasks = (tasksRepository.getTasks(true) as? Success)?.data

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = (tasksRepository.getTasks(true) as? Success)?.data

        
        assertThat(afterDeleteTasks?.size).isEqualTo(initialTasks!!.size - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow

class FakeDataSource(var tasks: MutableList<Task>? = mutableListOf()) : TasksDataSource {
    override suspend fun getTasks(): Result<List<Task>> {
        tasks?.let { return Success(ArrayList(it)) }
        return Error(
            Exception("Tasks not found")
        )
    }

    override suspend fun getTask(taskId: String): Result<Task> {
        tasks?.firstOrNull { it.id == taskId }?.let { return Success(it) }
        return Error(
            Exception("Task not found")
        )
    }

    override suspend fun saveTask(task: Task) {
        tasks?.add(task)
    }

    override suspend fun completeTask(task: Task) {
        tasks?.firstOrNull { it.id == task.id }?.let { it.isCompleted = true }
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = true }
    }

    override suspend fun activateTask(task: Task) {
        tasks?.firstOrNull { it.id == task.id }?.let { it.isCompleted = false }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = false }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.isCompleted }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }

    override fun getTasksStream(): Flow<Result<List<Task>>> {
        TODO("not implemented")
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Result<Task>> {
        TODO("not implemented")
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import com.example.android.architecture.blueprints.todoapp.data.Task
import org.hamcrest.core.Is.`is`
import org.junit.Assert.assertThat
import org.junit.Test


class StatisticsUtilsTest {

    @Test
    fun getActiveAndCompletedStats_noCompleted() {
        val tasks = listOf(
            Task("title", "desc", isCompleted = false)
        )
        
        val result = getActiveAndCompletedStats(tasks)

        
        assertThat(result.activeTasksPercent, `is`(100f))
        assertThat(result.completedTasksPercent, `is`(0f))
    }

    @Test
    fun getActiveAndCompletedStats_noActive() {
        val tasks = listOf(
            Task("title", "desc", isCompleted = true)
        )
        
        val result = getActiveAndCompletedStats(tasks)

        
        assertThat(result.activeTasksPercent, `is`(0f))
        assertThat(result.completedTasksPercent, `is`(100f))
    }

    @Test
    fun getActiveAndCompletedStats_both() {
        
        val tasks = listOf(
            Task("title", "desc", isCompleted = true),
            Task("title", "desc", isCompleted = true),
            Task("title", "desc", isCompleted = true),
            Task("title", "desc", isCompleted = false),
            Task("title", "desc", isCompleted = false)
        )
        
        val result = getActiveAndCompletedStats(tasks)

        
        assertThat(result.activeTasksPercent, `is`(40f))
        assertThat(result.completedTasksPercent, `is`(60f))
    }

    @Test
    fun getActiveAndCompletedStats_error() {
        
        val result = getActiveAndCompletedStats(null)

        
        assertThat(result.activeTasksPercent, `is`(0f))
        assertThat(result.completedTasksPercent, `is`(0f))
    }

    @Test
    fun getActiveAndCompletedStats_empty() {
        
        val result = getActiveAndCompletedStats(emptyList())

        
        assertThat(result.activeTasksPercent, `is`(0f))
        assertThat(result.completedTasksPercent, `is`(0f))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository, SavedStateHandle())
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(2)
    }

    @Test
    fun loadTasks_error() = runTest {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).isEmpty()
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_tasks_error)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = runTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.refresh()

        
        val allTasks = tasksViewModel.uiState.first().items
        val completedTasks = allTasks?.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.completed_tasks_cleared)
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_saved_task_message)
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_added_task_message)
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isActive).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() = runTest {
        val uiState = taskDetailViewModel.uiState.first()
        
        assertThat(uiState.task?.title).isEqualTo(task.title)
        assertThat(uiState.task?.description).isEqualTo(task.description)
    }

    @Test
    fun completeTask() = runTest {
        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isFalse()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask() = runTest {
        task.isCompleted = true

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(false)

        
        val newTask = (tasksRepository.getTask(task.id) as Success).data
        assertTrue(newTask.isActive)
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }

    @Test
    fun taskDetailViewModel_repositoryError() = runTest {
        
        tasksRepository.setReturnError(true)

        assertThat(taskDetailViewModel.uiState.value.task).isNull()
    }

    @Test
    fun deleteTask() = runTest {
        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isTrue()

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            taskDetailViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeRepository : TasksRepository {

    private var shouldReturnError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<Result<List<Task>>> = savedTasks.map {
        if (shouldReturnError) {
            Error(Exception())
        } else {
            Success(it.values.toList())
        }
    }

    fun setReturnError(value: Boolean) {
        shouldReturnError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<Result<List<Task>>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Result<Task>> {
        return observableTasks.map { tasks ->
            when (tasks) {
                is Error -> Error(tasks.exception)
                is Success -> {
                    val task = tasks.data.firstOrNull { it.id == taskId }
                        ?: return@map Error(Exception("Not found"))
                    Success(task)
                }
            }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        savedTasks.value[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Could not find task"))
    }

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        return observableTasks.first()
    }

    override suspend fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = completedTask
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        
        throw NotImplementedError()
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = activeTask
            newTasks
        }
    }

    override suspend fun activateTask(taskId: String) {
        throw NotImplementedError()
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.succeeded
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@MediumTest
class TasksLocalDataSourceTest {

    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            ToDoDatabase::class.java
        )
            .allowMainThreadQueries()
            .build()

        localDataSource = TasksLocalDataSource(database.taskDao(), Dispatchers.Main)
    }

    @After
    fun cleanUp() {
        database.close()
    }

    @Test
    fun saveTask_retrievesTask() = runTest {
        
        val newTask = Task("title", "description", true)
        localDataSource.saveTask(newTask)

        
        val result = localDataSource.getTask(newTask.id)

        
        assertThat(result.succeeded, `is`(true))
        result as Success
        assertThat(result.data.title, `is`("title"))
        assertThat(result.data.description, `is`("description"))
        assertThat(result.data.isCompleted, `is`(true))
    }

    @Test
    fun completeTask_retrievedTaskIsComplete() = runTest {
        
        val newTask = Task("title")
        localDataSource.saveTask(newTask)

        
        localDataSource.completeTask(newTask)
        val result = localDataSource.getTask(newTask.id)

        
        assertThat(result.succeeded, `is`(true))
        result as Success
        assertThat(result.data.title, `is`(newTask.title))
        assertThat(result.data.isCompleted, `is`(true))
    }

    @Test
    fun activateTask_retrievedTaskIsActive() = runTest {
        
        val newTask = Task("Some title", "Some description", true)
        localDataSource.saveTask(newTask)

        localDataSource.activateTask(newTask)

        
        val result = localDataSource.getTask(newTask.id)

        assertThat(result.succeeded, `is`(true))
        result as Success

        assertThat(result.data.title, `is`("Some title"))
        assertThat(result.data.isCompleted, `is`(false))
    }

    @Test
    fun clearCompletedTask_taskNotRetrievable() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title2")
        val newTask3 = Task("title3")
        localDataSource.saveTask(newTask1)
        localDataSource.completeTask(newTask1)
        localDataSource.saveTask(newTask2)
        localDataSource.completeTask(newTask2)
        localDataSource.saveTask(newTask3)
        
        localDataSource.clearCompletedTasks()

        
        assertThat(localDataSource.getTask(newTask1.id).succeeded, `is`(false))
        assertThat(localDataSource.getTask(newTask2.id).succeeded, `is`(false))

        val result3 = localDataSource.getTask(newTask3.id)

        assertThat(result3.succeeded, `is`(true))
        result3 as Success

        assertThat(result3.data, `is`(newTask3))
    }

    @Test
    fun deleteAllTasks_emptyListOfRetrievedTask() = runTest {
        
        val newTask = Task("title")

        localDataSource.saveTask(newTask)

        
        localDataSource.deleteAllTasks()

        
        val result = localDataSource.getTasks() as Success
        assertThat(result.data.isEmpty(), `is`(true))
    }

    @Test
    fun getTasks_retrieveSavedTasks() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title")

        localDataSource.saveTask(newTask1)
        localDataSource.saveTask(newTask2)
        
        val results = localDataSource.getTasks() as Success<List<Task>>
        val tasks = results.data
        assertThat(tasks.size, `is`(2))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@HiltAndroidTest
class AddEditTaskScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()

        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository, SavedStateHandle()),
                        topBarTitle = R.string.add_task,
                        onTaskUpdate = { },
                        onBack = { },
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = (repository.getTasksBlocking(true) as Result.Success).data
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.lifecycle.LiveData
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksRepository {

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        if (forceUpdate) {
            try {
                updateTasksFromRemoteDataSource()
            } catch (ex: Exception) {
                return Result.Error(ex)
            }
        }
        return tasksLocalDataSource.getTasks()
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun observeTasks(): LiveData<Result<List<Task>>> {
        return tasksLocalDataSource.observeTasks()
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksRemoteDataSource.getTasks()

        if (remoteTasks is Success) {
            
            tasksLocalDataSource.deleteAllTasks()
            remoteTasks.data.forEach { task ->
                tasksLocalDataSource.saveTask(task)
            }
        } else if (remoteTasks is Result.Error) {
            throw remoteTasks.exception
        }
    }

    override fun observeTask(taskId: String): LiveData<Result<Task>> {
        return tasksLocalDataSource.observeTask(taskId)
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksRemoteDataSource.getTask(taskId)

        if (remoteTask is Success) {
            tasksLocalDataSource.saveTask(remoteTask.data)
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksLocalDataSource.getTask(taskId)
    }

    override suspend fun saveTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.saveTask(task) }
            launch { tasksLocalDataSource.saveTask(task) }
        }
    }

    override suspend fun completeTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.completeTask(task) }
            launch { tasksLocalDataSource.completeTask(task) }
        }
    }

    override suspend fun completeTask(taskId: String) {
        withContext(ioDispatcher) {
            (getTaskWithId(taskId) as? Success)?.let { it ->
                completeTask(it.data)
            }
        }
    }

    override suspend fun activateTask(task: Task) = withContext<Unit>(ioDispatcher) {
        coroutineScope {
            launch { tasksRemoteDataSource.activateTask(task) }
            launch { tasksLocalDataSource.activateTask(task) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        withContext(ioDispatcher) {
            (getTaskWithId(taskId) as? Success)?.let { it ->
                activateTask(it.data)
            }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        withContext(ioDispatcher) {
            coroutineScope {
                launch { tasksRemoteDataSource.deleteAllTasks() }
                launch { tasksLocalDataSource.deleteAllTasks() }
            }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }
    }

    private suspend fun getTaskWithId(id: String): Result<Task> {
        return tasksLocalDataSource.getTask(id)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.lifecycle.LiveData
import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.android.architecture.blueprints.todoapp.data.Task


@Dao
interface TasksDao {

    
    @Query("SELECT * FROM Tasks")
    fun observeTasks(): LiveData<List<Task>>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    fun observeTaskById(taskId: String): LiveData<Task>

    
    @Query("SELECT * FROM Tasks")
    suspend fun getTasks(): List<Task>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    suspend fun getTaskById(taskId: String): Task?

    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTask(task: Task)

    
    @Update
    suspend fun updateTask(task: Task): Int

    
    @Query("UPDATE tasks SET completed = :completed WHERE entryid = :taskId")
    suspend fun updateCompleted(taskId: String, completed: Boolean)

    
    @Query("DELETE FROM Tasks WHERE entryid = :taskId")
    suspend fun deleteTaskById(taskId: String): Int

    
    @Query("DELETE FROM Tasks")
    suspend fun deleteTasks()

    
    @Query("DELETE FROM Tasks WHERE completed = 1")
    suspend fun deleteCompletedTasks(): Int
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val statisticsViewModel by viewModels<StatisticsViewModel> { getVmFactory() }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = DataBindingUtil.inflate(
            inflater, R.layout.statistics_frag, container,
            false
        )
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.viewmodel = statisticsViewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.graphics.Paint
import android.widget.TextView
import androidx.databinding.BindingAdapter
import androidx.recyclerview.widget.RecyclerView
import com.example.android.architecture.blueprints.todoapp.data.Task




@BindingAdapter("app:items")
fun setItems(listView: RecyclerView, items: List<Task>?) {
    items?.let {
        (listView.adapter as TasksAdapter).submitList(items)
    }
}

@BindingAdapter("app:completedTask")
fun setStyle(textView: TextView, enabled: Boolean) {
    if (enabled) {
        textView.paintFlags = textView.paintFlags or Paint.STRIKE_THRU_TEXT_FLAG
    } else {
        textView.paintFlags = textView.paintFlags and Paint.STRIKE_THRU_TEXT_FLAG.inv()
    }
}
<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getVmFactory() }

    private val args: TasksFragmentArgs by navArgs()

    private lateinit var viewDataBinding: TasksFragBinding

    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()
    }

    private fun setupNavigation() {
        viewModel.openTaskEvent.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewModel.newTaskEvent.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarMessage, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _forceUpdate = MutableLiveData<Boolean>(false)

    private val _items: LiveData<List<Task>> = _forceUpdate.switchMap { forceUpdate ->
        if (forceUpdate) {
            _dataLoading.value = true
            viewModelScope.launch {
                tasksRepository.refreshTasks()
                _dataLoading.value = false
            }
        }
        tasksRepository.observeTasks().switchMap { filterTasks(it) }

    }

    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    private var resultMessageShown: Boolean = false

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
        
        loadTasks(false)
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        if (resultMessageShown) return
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
        resultMessageShown = true
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    private fun filterTasks(tasksResult: Result<List<Task>>): LiveData<List<Task>> {
        
        val result = MutableLiveData<List<Task>>()

        if (tasksResult is Success) {
            isDataLoadingError.value = false
            viewModelScope.launch {
                result.value = filterItems(tasksResult.data, currentFiltering)
            }
        } else {
            result.value = emptyList()
            showSnackbarMessage(R.string.loading_tasks_error)
            isDataLoadingError.value = true
        }

        return result
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _forceUpdate.value = forceUpdate
    }

    private fun filterItems(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
            val tasksToShow = ArrayList<Task>()
            
            for (task in tasks) {
                when (filteringType) {
                    TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                    TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                        tasksToShow.add(task)
                    }
                    TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                        tasksToShow.add(task)
                    }
                }
            }
            return tasksToShow
        }

    fun refresh() {
        _forceUpdate.value = true
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {


    private val _params = MutableLiveData<Pair<String, Boolean>>()

    private val _task = _params.switchMap { (taskId, forceUpdate) ->
        if (forceUpdate) {
            _dataLoading.value = true
            viewModelScope.launch {
                tasksRepository.refreshTasks()
                _dataLoading.value = false
            }
        }
        tasksRepository.observeTask(taskId).switchMap { computeResult(it) }

    }
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskCommand = MutableLiveData<Event<Unit>>()
    val editTaskCommand: LiveData<Event<Unit>> = _editTaskCommand

    private val _deleteTaskCommand = MutableLiveData<Event<Unit>>()
    val deleteTaskCommand: LiveData<Event<Unit>> = _deleteTaskCommand

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }

    fun deleteTask() = viewModelScope.launch {
        _params.value?.first?.let {
            tasksRepository.deleteTask(it)
            _deleteTaskCommand.value = Event(Unit)
        }
    }

    fun editTask() {
        _editTaskCommand.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = _task.value ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun start(taskId: String?) {
        
        if (_dataLoading.value == true || taskId == _params.value?.first) {
            return
        }
        if (taskId == null) {
            _isDataAvailable.value = false
            return
        }

        _params.value = Pair(taskId, false)
    }

    private fun computeResult(taskResult: Result<Task>): LiveData<Task> {

        
        val result = MutableLiveData<Task>()

        if (taskResult is Success) {
            result.value = taskResult.data
            _isDataAvailable.value = true
        } else {
            result.value = null
            showSnackbarMessage(R.string.loading_tasks_error)
            _isDataAvailable.value = false
        }

        return result
    }


    fun refresh() {
        
        _params.value = _params.value?.copy(second = true)
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import androidx.annotation.VisibleForTesting
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException

@VisibleForTesting(otherwise = VisibleForTesting.NONE)
fun <T> LiveData<T>.awaitNextValue(
    time: Long = 2,
    timeUnit: TimeUnit = TimeUnit.SECONDS
): T {
    var data: T? = null
    val latch = CountDownLatch(1)
    val observer = object : Observer<T> {
        override fun onChanged(o: T?) {
            data = o
            latch.countDown()
            this@awaitNextValue.removeObserver(this)
        }
    }
    this.observeForever(observer)
    
    if (!latch.await(time, timeUnit)) {
        throw TimeoutException("LiveData value was never set.")
    }

    @Suppress("UNCHECKED_CAST")
    return data as T
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.LiveData
import org.junit.Assert.assertEquals

fun assertLiveDataEventTriggered(
    liveData: LiveData<Event<String>>,
    taskId: String
) {
    val value = liveData.awaitNextValue()
    assertEquals(value.getContentIfNotHandled(), taskId)
}

fun assertSnackbarMessage(snackbarLiveData: LiveData<Event<Int>>, messageId: Int) {
    val value: Event<Int> = snackbarLiveData.awaitNextValue()
    assertEquals(value.getContentIfNotHandled(), messageId)
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.FakeFailingTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.awaitNextValue
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class StatisticsViewModelTest {

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    
    private lateinit var statisticsViewModel: StatisticsViewModel

    
    private val tasksRepository = FakeRepository()

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupStatisticsViewModel() {
        statisticsViewModel = StatisticsViewModel(tasksRepository)
    }

    @Test
    fun loadEmptyTasksFromRepository_EmptyResults() = mainCoroutineRule.runBlockingTest {
        

        
        statisticsViewModel.start()

        
        assertThat(statisticsViewModel.empty.awaitNextValue()).isTrue()
    }

    @Test
    fun loadNonEmptyTasksFromRepository_NonEmptyResults() {
        
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        val task4 = Task("Title4", "Description4", true)
        tasksRepository.addTasks(task1, task2, task3, task4)

        
        statisticsViewModel.start()

        
        assertThat(statisticsViewModel.empty.awaitNextValue())
            .isFalse()
        assertThat(statisticsViewModel.activeTasksPercent.awaitNextValue())
            .isEqualTo(25f)
        assertThat(statisticsViewModel.completedTasksPercent.awaitNextValue())
            .isEqualTo(75f)
    }

    @Test
    fun loadStatisticsWhenTasksAreUnavailable_CallErrorToDisplay() =
        mainCoroutineRule.runBlockingTest {
            val errorViewModel = StatisticsViewModel(
                DefaultTasksRepository(
                    FakeFailingTasksRemoteDataSource,
                    FakeFailingTasksRemoteDataSource,
                    Dispatchers.Main  
                )
            )

            
            errorViewModel.start()

            
            assertThat(errorViewModel.empty.awaitNextValue()).isTrue()
            assertThat(errorViewModel.error.awaitNextValue()).isTrue()
        }

    @Test
    fun loadTasks_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        statisticsViewModel.start()

        
        assertThat(statisticsViewModel.dataLoading.awaitNextValue()).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(statisticsViewModel.dataLoading.awaitNextValue()).isFalse()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.awaitNextValue
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class AddEditTaskViewModelTest {

    
    private lateinit var addEditTaskViewModel: AddEditTaskViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    private val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()

        
        addEditTaskViewModel = AddEditTaskViewModel(tasksRepository)
    }

    @Test
    fun saveNewTaskToRepository_showsSuccessMessageUi() {
        val newTitle = "New Task Title"
        val newDescription = "Some Task Description"
        (addEditTaskViewModel).apply {
            title.value = newTitle
            description.value = newDescription
        }
        addEditTaskViewModel.saveTask()

        val newTask = tasksRepository.tasksServiceData.values.first()

        
        assertThat(newTask.title).isEqualTo(newTitle)
        assertThat(newTask.description).isEqualTo(newDescription)
    }

    @Test
    fun loadTasks_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(addEditTaskViewModel.dataLoading.awaitNextValue()).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(addEditTaskViewModel.dataLoading.awaitNextValue()).isFalse()
    }

    @Test
    fun loadTasks_taskShown() {
        
        tasksRepository.addTasks(task)

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(addEditTaskViewModel.title.awaitNextValue()).isEqualTo(task.title)
        assertThat(addEditTaskViewModel.description.awaitNextValue()).isEqualTo(task.description)
        assertThat(addEditTaskViewModel.dataLoading.awaitNextValue()).isFalse()
    }

    @Test
    fun saveNewTaskToRepository_emptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_nullTitle_error() {
        saveTaskAndAssertSnackbarError(null, "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescription_error() {
        saveTaskAndAssertSnackbarError("Title", "")
    }

    @Test
    fun saveNewTaskToRepository_nullDescription_error() {
        saveTaskAndAssertSnackbarError("Title", null)
    }

    @Test
    fun saveNewTaskToRepository_nullDescriptionNullTitle_error() {
        saveTaskAndAssertSnackbarError(null, null)
    }

    @Test
    fun saveNewTaskToRepository_emptyDescriptionEmptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "")
    }

    private fun saveTaskAndAssertSnackbarError(title: String?, description: String?) {
        (addEditTaskViewModel).apply {
            this.title.value = title
            this.description.value = description
        }

        
        addEditTaskViewModel.saveTask()

        
        assertSnackbarMessage(addEditTaskViewModel.snackbarMessage, string.empty_task_message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertLiveDataEventTriggered
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.awaitNextValue
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository)
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() {
        
        mainCoroutineRule.pauseDispatcher()

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForever { }

        
        assertThat(tasksViewModel.dataLoading.awaitNextValue()).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(tasksViewModel.dataLoading.awaitNextValue()).isFalse()

        
        assertThat(tasksViewModel.items.awaitNextValue()).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForever { }

        
        assertThat(tasksViewModel.dataLoading.awaitNextValue()).isFalse()

        
        assertThat(tasksViewModel.items.awaitNextValue()).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForever { }

        
        assertThat(tasksViewModel.dataLoading.awaitNextValue()).isFalse()

        
        assertThat(tasksViewModel.items.awaitNextValue()).hasSize(2)
    }

    @Test
    fun loadTasks_error() {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForever { }

        
        assertThat(tasksViewModel.dataLoading.awaitNextValue()).isFalse()

        
        assertThat(tasksViewModel.items.awaitNextValue()).isEmpty()

        
        assertSnackbarMessage(tasksViewModel.snackbarMessage, R.string.loading_tasks_error)
    }

    @Test
    fun clickOnFab_showsAddTaskUi() {
        
        tasksViewModel.addNewTask()

        
        val value = tasksViewModel.newTaskEvent.awaitNextValue()
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun clickOnOpenTask_setsEvent() {
        
        val taskId = "42"
        tasksViewModel.openTask(taskId)

        
        assertLiveDataEventTriggered(tasksViewModel.openTaskEvent, taskId)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = mainCoroutineRule.runBlockingTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.loadTasks(true)

        
        val allTasks = tasksViewModel.items.awaitNextValue()
        val completedTasks = allTasks.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.completed_tasks_cleared
        )
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_saved_task_message
        )
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_added_task_message
        )
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertSnackbarMessage(tasksViewModel.snackbarMessage, R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_complete
        )
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isActive).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_active
        )
    }

    @Test
    fun getTasksAddViewVisible() {
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        assertThat(tasksViewModel.tasksAddViewVisible.awaitNextValue()).isTrue()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.awaitNextValue
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test



@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(tasksRepository)
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() {
        taskDetailViewModel.start(task.id)

        
        assertThat(taskDetailViewModel.task.awaitNextValue().title).isEqualTo(task.title)
        assertThat(taskDetailViewModel.task.awaitNextValue().description)
            .isEqualTo(task.description)
    }

    @Test
    fun completeTask() {
        
        taskDetailViewModel.start(task.id)
        
        taskDetailViewModel.task.awaitNextValue()

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isFalse()

        
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_complete)
    }

    @Test
    fun activateTask() = runBlockingTest {
        task.isCompleted = true

        
        taskDetailViewModel.start(task.id)
        
        taskDetailViewModel.task.awaitNextValue()

        taskDetailViewModel.task.observeForever { }

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        taskDetailViewModel.setCompleted(false)

        
        val newTask = (tasksRepository.getTask(task.id) as Success).data
        assertTrue(newTask.isActive)
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_active)
    }

    @Test
    fun taskDetailViewModel_repositoryError() {
        
        tasksRepository.setReturnError(true)

        
        taskDetailViewModel.start(task.id)
        
        taskDetailViewModel.task.awaitNextValue()
        


        
        assertThat(taskDetailViewModel.isDataAvailable.awaitNextValue()).isFalse()
    }

    @Test
    fun updateSnackbar_nullValue() {
        
        val snackbarText = taskDetailViewModel.snackbarMessage.value

        
        assertThat(snackbarText).isNull()
    }

    @Test
    fun clickOnEditTask_SetsEvent() {
        
        taskDetailViewModel.editTask()

        
        val value = taskDetailViewModel.editTaskCommand.awaitNextValue()
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun deleteTask() {
        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isTrue()
        taskDetailViewModel.start(task.id)

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        taskDetailViewModel.start(task.id)
        
        taskDetailViewModel.task.observeForever { }
        
        taskDetailViewModel.refresh()

        
        assertThat(taskDetailViewModel.dataLoading.awaitNextValue()).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(taskDetailViewModel.dataLoading.awaitNextValue()).isFalse()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.map
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import java.util.LinkedHashMap


class FakeRepository : TasksRepository {

    var tasksServiceData: LinkedHashMap<String, Task> = LinkedHashMap()

    private var shouldReturnError = false

    private val observableTasks = MutableLiveData<Result<List<Task>>>()

    fun setReturnError(value: Boolean) {
        shouldReturnError = value
    }

    override suspend fun refreshTasks() {
        observableTasks.value = getTasks()
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun observeTasks(): LiveData<Result<List<Task>>> {
        runBlocking { refreshTasks() }
        return observableTasks
    }

    override fun observeTask(taskId: String): LiveData<Result<Task>> {
        runBlocking { refreshTasks() }
        return observableTasks.map { tasks ->
            when (tasks) {
                is Result.Loading -> Result.Loading
                is Error -> Error(tasks.exception)
                is Success -> {
                    val task = tasks.data.firstOrNull() { it.id == taskId }
                        ?: return@map Error(Exception("Not found"))
                    Success(task)
                }
            }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        tasksServiceData[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Could not find task"))
    }

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        return Success(tasksServiceData.values.toList())
    }

    override suspend fun saveTask(task: Task) {
        tasksServiceData[task.id] = task
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        tasksServiceData[task.id] = completedTask
    }

    override suspend fun completeTask(taskId: String) {
        
        throw NotImplementedError()
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        tasksServiceData[task.id] = activeTask
    }

    override suspend fun activateTask(taskId: String) {
        throw NotImplementedError()
    }

    override suspend fun clearCompletedTasks() {
        tasksServiceData = tasksServiceData.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteTask(taskId: String) {
        tasksServiceData.remove(taskId)
        refreshTasks()
    }

    override suspend fun deleteAllTasks() {
        tasksServiceData.clear()
        refreshTasks()
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        for (task in tasks) {
            tasksServiceData[task.id] = task
        }
        runBlocking { refreshTasks() }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import android.content.Context
import androidx.annotation.VisibleForTesting
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource
import kotlinx.coroutines.runBlocking


object ServiceLocator {

    private val lock = Any()
    private var database: ToDoDatabase? = null
    @Volatile
    var tasksRepository: TasksRepository? = null
        @VisibleForTesting set

    fun provideTasksRepository(context: Context): TasksRepository {
        synchronized(this) {
            return tasksRepository ?: tasksRepository ?: createTasksRepository(context)
        }
    }

    private fun createTasksRepository(context: Context): TasksRepository {
        return DefaultTasksRepository(TasksRemoteDataSource, createTaskLocalDataSource(context))
    }

    private fun createTaskLocalDataSource(context: Context): TasksDataSource {
        val database = database ?: createDataBase(context)
        return TasksLocalDataSource(database.taskDao())
    }

    private fun createDataBase(context: Context): ToDoDatabase {
        val result = Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java, "Tasks.db"
        ).build()
        database = result
        return result
    }

    @VisibleForTesting
    fun resetRepository() {
        synchronized(lock) {
            runBlocking {
                TasksRemoteDataSource.deleteAllTasks()
            }
            
            database?.apply {
                clearAllTables()
                close()
            }
            tasksRepository = null
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.lifecycle.LiveData
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksRepository {

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        if (forceUpdate) {
            try {
                updateTasksFromRemoteDataSource()
            } catch (ex: Exception) {
                return Result.Error(ex)
            }
        }
        return tasksLocalDataSource.getTasks()
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun observeTasks(): LiveData<Result<List<Task>>> {
        return tasksLocalDataSource.observeTasks()
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksRemoteDataSource.getTasks()

        if (remoteTasks is Success) {
            
            tasksLocalDataSource.deleteAllTasks()
            remoteTasks.data.forEach { task ->
                tasksLocalDataSource.saveTask(task)
            }
        } else if (remoteTasks is Result.Error) {
            throw remoteTasks.exception
        }
    }

    override fun observeTask(taskId: String): LiveData<Result<Task>> {
        return tasksLocalDataSource.observeTask(taskId)
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksRemoteDataSource.getTask(taskId)

        if (remoteTask is Success) {
            tasksLocalDataSource.saveTask(remoteTask.data)
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {

        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksLocalDataSource.getTask(taskId)
    }

    override suspend fun saveTask(task: Task) {
        

            coroutineScope {
                launch { tasksRemoteDataSource.saveTask(task) }
                launch { tasksLocalDataSource.saveTask(task) }
            }

    }

    override suspend fun completeTask(task: Task) {
        

            task.isCompleted = true
            coroutineScope {
                launch { tasksRemoteDataSource.completeTask(task) }
                launch { tasksLocalDataSource.completeTask(task) }
            }

    }

    override suspend fun completeTask(taskId: String) {
        withContext(ioDispatcher) {
            (getTaskWithId(taskId) as? Success)?.let { it ->
                completeTask(it.data)
            }
        }
    }

    override suspend fun activateTask(task: Task) = withContext<Unit>(ioDispatcher) {
        

            task.isCompleted = false
            coroutineScope {
                launch { tasksRemoteDataSource.activateTask(task) }
                launch { tasksLocalDataSource.activateTask(task) }
            }


    }

    override suspend fun activateTask(taskId: String) {
        withContext(ioDispatcher) {
            (getTaskWithId(taskId) as? Success)?.let { it ->
                activateTask(it.data)
            }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }



    }

    override suspend fun deleteAllTasks() {
        withContext(ioDispatcher) {
            coroutineScope {
                launch { tasksRemoteDataSource.deleteAllTasks() }
                launch { tasksLocalDataSource.deleteAllTasks() }
            }
        }

    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }


        Unit 
    }



















    private suspend fun getTaskWithId(id: String): Result<Task> {
        return tasksLocalDataSource.getTask(id)
    }















}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.lifecycle.LiveData
import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.android.architecture.blueprints.todoapp.data.Task


@Dao
interface TasksDao {

    
    @Query("SELECT * FROM Tasks")
    fun observeTasks(): LiveData<List<Task>>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    fun observeTaskById(taskId: String): LiveData<Task>

    
    @Query("SELECT * FROM Tasks")
    suspend fun getTasks(): List<Task>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    suspend fun getTaskById(taskId: String): Task?

    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTask(task: Task)

    
    @Update
    suspend fun updateTask(task: Task): Int

    
    @Query("UPDATE tasks SET completed = :completed WHERE entryid = :taskId")
    suspend fun updateCompleted(taskId: String, completed: Boolean)

    
    @Query("DELETE FROM Tasks WHERE entryid = :taskId")
    suspend fun deleteTaskById(taskId: String): Int

    
    @Query("DELETE FROM Tasks")
    suspend fun deleteTasks()

    
    @Query("DELETE FROM Tasks WHERE completed = 1")
    suspend fun deleteCompletedTasks(): Int
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val statisticsViewModel by viewModels<StatisticsViewModel> { getVmFactory() }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = DataBindingUtil.inflate(
            inflater, R.layout.statistics_frag, container,
            false
        )
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.viewmodel = statisticsViewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        statisticsViewModel.start()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.databinding.BindingAdapter
import androidx.recyclerview.widget.RecyclerView
import com.example.android.architecture.blueprints.todoapp.data.Task


@BindingAdapter("app:items")
fun setItems(listView: RecyclerView, items: List<Task>?) {
    items?.let {
        (listView.adapter as TasksAdapter).submitList(items)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getVmFactory() }

    private val args: TasksFragmentArgs by navArgs()

    private lateinit var viewDataBinding: TasksFragBinding

    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()

        
        
        viewModel.loadTasks(true)
    }

    private fun setupNavigation() {
        viewModel.openTaskEvent.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewModel.newTaskEvent.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarMessage, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                viewModel.loadTasks(false)
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _forceUpdate = MutableLiveData<Boolean>(false)

    private val _items: LiveData<List<Task>> = _forceUpdate.switchMap { forceUpdate ->
        if (forceUpdate) {
            viewModelScope.launch {
                tasksRepository.refreshTasks()
            }
        }
        tasksRepository.observeTasks().switchMap { filterTasks(it) }

    }

    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    private var resultMessageShown: Boolean = true

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
        
        loadTasks(false)
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        if (resultMessageShown) return
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
        resultMessageShown = true
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    private fun filterTasks(tasksResult: Result<List<Task>>): LiveData<List<Task>> {
        _dataLoading.value = true
        
        val result = MutableLiveData<List<Task>>()

        if (tasksResult is Success) {
            isDataLoadingError.value = false
            viewModelScope.launch {
                result.value = filterItems(tasksResult.data, currentFiltering)
            }
        } else {
            result.value = emptyList()
            showSnackbarMessage(R.string.loading_tasks_error)
            isDataLoadingError.value = true
        }

        _dataLoading.value = false
        return result
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _forceUpdate.value = forceUpdate
    }

    private suspend fun filterItems(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
            val tasksToShow = ArrayList<Task>()
            
            for (task in tasks) {
                when (filteringType) {
                    TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                    TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                        tasksToShow.add(task)
                    }
                    TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                        tasksToShow.add(task)
                    }
                }
            }
            return tasksToShow
        }

    fun refresh() {
        _forceUpdate.value = true
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {


    private val _params = MutableLiveData<Pair<String, Boolean>>()

    private val _task = _params.switchMap { (taskId, forceUpdate) ->
        if (forceUpdate) {
            viewModelScope.launch {
                tasksRepository.refreshTasks()
            }
        }
        tasksRepository.observeTask(taskId).switchMap { computeResult(it) }

    }
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskCommand = MutableLiveData<Event<Unit>>()
    val editTaskCommand: LiveData<Event<Unit>> = _editTaskCommand

    private val _deleteTaskCommand = MutableLiveData<Event<Unit>>()
    val deleteTaskCommand: LiveData<Event<Unit>> = _deleteTaskCommand

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }

    fun deleteTask() = viewModelScope.launch {
        _params.value?.first?.let {
            tasksRepository.deleteTask(it)
            _deleteTaskCommand.value = Event(Unit)
        }
    }

    fun editTask() {
        _editTaskCommand.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = _task.value ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun start(taskId: String?, forceRefresh: Boolean = true) {
        if (_isDataAvailable.value == true && !forceRefresh || _dataLoading.value == true) {
            return
        }
        if (taskId == null) {
            _isDataAvailable.value = false
            return
        }

        
        _dataLoading.value = true

        _params.value = Pair(taskId, forceRefresh)
    }

    private fun computeResult(taskResult: Result<Task>): LiveData<Task> {

        _dataLoading.value = true
        
        val result = MutableLiveData<Task>()

        if (taskResult is Success) {
            result.value = taskResult.data
            _isDataAvailable.value = true
        } else {
            result.value = null
            showSnackbarMessage(R.string.loading_tasks_error)
            _isDataAvailable.value = false
        }

        _dataLoading.value = false
        return result
    }


    fun refresh() {
        
        _params.value = _params.value?.copy(second = true)
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

object LiveDataTestUtil {

    
    fun <T> getValue(liveData: LiveData<T>): T {
        val data = arrayOfNulls<Any>(1)
        val latch = CountDownLatch(1)
        val observer = object : Observer<T> {
            override fun onChanged(o: T?) {
                data[0] = o
                latch.countDown()
                liveData.removeObserver(this)
            }
        }
        liveData.observeForever(observer)
        latch.await(2, TimeUnit.SECONDS)

        @Suppress("UNCHECKED_CAST")
        return data[0] as T
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.LiveData
import org.junit.Assert.assertEquals

fun assertLiveDataEventTriggered(
    liveData: LiveData<Event<String>>,
    taskId: String
) {
    val value = LiveDataTestUtil.getValue(liveData)
    assertEquals(value.getContentIfNotHandled(), taskId)
}

fun assertSnackbarMessage(snackbarLiveData: LiveData<Event<Int>>, messageId: Int) {
    val value: Event<Int> = LiveDataTestUtil.getValue(snackbarLiveData)
    assertEquals(value.getContentIfNotHandled(), messageId)
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.FakeFailingTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class StatisticsViewModelTest {

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    
    private lateinit var statisticsViewModel: StatisticsViewModel

    
    private val tasksRepository = FakeRepository()

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupStatisticsViewModel() {
        statisticsViewModel = StatisticsViewModel(tasksRepository)
    }

    @Test
    fun loadEmptyTasksFromRepository_EmptyResults() = mainCoroutineRule.runBlockingTest {
        

        
        statisticsViewModel.start()

        
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.empty)).isTrue()
    }

    @Test
    fun loadNonEmptyTasksFromRepository_NonEmptyResults() {
        
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        val task4 = Task("Title4", "Description4", true)
        tasksRepository.addTasks(task1, task2, task3, task4)

        
        statisticsViewModel.start()

        
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.empty))
            .isFalse()
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.activeTasksPercent))
            .isEqualTo(25f)
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.completedTasksPercent))
            .isEqualTo(75f)
    }

    @Test
    fun loadStatisticsWhenTasksAreUnavailable_CallErrorToDisplay() =
        mainCoroutineRule.runBlockingTest {
            val errorViewModel = StatisticsViewModel(
                DefaultTasksRepository(
                    FakeFailingTasksRemoteDataSource,
                    FakeFailingTasksRemoteDataSource,
                    Dispatchers.Main  
                )
            )

            
            errorViewModel.start()

            
            assertThat(LiveDataTestUtil.getValue(errorViewModel.empty)).isTrue()
            assertThat(LiveDataTestUtil.getValue(errorViewModel.error)).isTrue()
        }

    @Test
    fun loadTasks_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        statisticsViewModel.start()

        
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.dataLoading)).isFalse()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil.getValue
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class AddEditTaskViewModelTest {

    
    private lateinit var addEditTaskViewModel: AddEditTaskViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    private val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()

        
        addEditTaskViewModel = AddEditTaskViewModel(tasksRepository)
    }

    @Test
    fun saveNewTaskToRepository_showsSuccessMessageUi() {
        val newTitle = "New Task Title"
        val newDescription = "Some Task Description"
        (addEditTaskViewModel).apply {
            title.value = newTitle
            description.value = newDescription
        }
        addEditTaskViewModel.saveTask()

        val newTask = tasksRepository.tasksServiceData.values.first()

        
        assertThat(newTask.title).isEqualTo(newTitle)
        assertThat(newTask.description).isEqualTo(newDescription)
    }

    @Test
    fun loadTasks_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isFalse()
    }

    @Test
    fun loadTasks_taskShown() {
        
        tasksRepository.addTasks(task)

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(getValue(addEditTaskViewModel.title)).isEqualTo(task.title)
        assertThat(getValue(addEditTaskViewModel.description)).isEqualTo(task.description)
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isFalse()
    }

    @Test
    fun saveNewTaskToRepository_emptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_nullTitle_error() {
        saveTaskAndAssertSnackbarError(null, "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescription_error() {
        saveTaskAndAssertSnackbarError("Title", "")
    }

    @Test
    fun saveNewTaskToRepository_nullDescription_error() {
        saveTaskAndAssertSnackbarError("Title", null)
    }

    @Test
    fun saveNewTaskToRepository_nullDescriptionNullTitle_error() {
        saveTaskAndAssertSnackbarError(null, null)
    }

    @Test
    fun saveNewTaskToRepository_emptyDescriptionEmptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "")
    }

    private fun saveTaskAndAssertSnackbarError(title: String?, description: String?) {
        (addEditTaskViewModel).apply {
            this.title.value = title
            this.description.value = description
        }

        
        addEditTaskViewModel.saveTask()

        
        assertSnackbarMessage(addEditTaskViewModel.snackbarMessage, string.empty_task_message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertLiveDataEventTriggered
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository)
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() {
        
        mainCoroutineRule.pauseDispatcher()

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(2)
    }

    @Test
    fun loadTasks_error() {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).isEmpty()

        
        assertSnackbarMessage(tasksViewModel.snackbarMessage, R.string.loading_tasks_error)
    }

    @Test
    fun clickOnFab_showsAddTaskUi() {
        
        tasksViewModel.addNewTask()

        
        val value = LiveDataTestUtil.getValue(tasksViewModel.newTaskEvent)
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun clickOnOpenTask_setsEvent() {
        
        val taskId = "42"
        tasksViewModel.openTask(taskId)

        
        assertLiveDataEventTriggered(tasksViewModel.openTaskEvent, taskId)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = mainCoroutineRule.runBlockingTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.loadTasks(true)

        
        val allTasks = LiveDataTestUtil.getValue(tasksViewModel.items)
        val completedTasks = allTasks.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.completed_tasks_cleared
        )
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_saved_task_message
        )
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_added_task_message
        )
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_deleted_task_message
        )
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_complete
        )
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isActive).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_active
        )
    }

    @Test
    fun getTasksAddViewVisible() {
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.tasksAddViewVisible)).isTrue()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil.getValue
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(tasksRepository)
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() {
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.task).title).isEqualTo(task.title)
        assertThat(getValue(taskDetailViewModel.task).description)
            .isEqualTo(task.description)
    }

    @Test
    fun completeTask() {
        taskDetailViewModel.start(task.id)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isFalse()

        
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_complete)
    }

    @Test
    fun activateTask() {
        task.isCompleted = true

        taskDetailViewModel.start(task.id)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        taskDetailViewModel.setCompleted(false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isFalse()
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_active)

    }

    @Test
    fun taskDetailViewModel_repositoryError() {
        
        tasksRepository.setReturnError(true)

        
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.isDataAvailable)).isFalse()
    }

    @Test
    fun updateSnackbar_nullValue() {
        
        val snackbarText = taskDetailViewModel.snackbarMessage.value

        
        assertThat(snackbarText).isNull()
    }

    @Test
    fun clickOnEditTask_SetsEvent() {
        
        taskDetailViewModel.editTask()

        
        val value = getValue(taskDetailViewModel.editTaskCommand)
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun deleteTask() {
        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isTrue()
        taskDetailViewModel.start(task.id)

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(getValue(taskDetailViewModel.dataLoading)).isFalse()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.map
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import java.util.LinkedHashMap


class FakeRepository : TasksRepository {

    var tasksServiceData: LinkedHashMap<String, Task> = LinkedHashMap()

    private var shouldReturnError = false

    private val observableTasks = MutableLiveData<Result<List<Task>>>()

    fun setReturnError(value: Boolean) {
        shouldReturnError = value
    }

    override suspend fun refreshTasks() {
        observableTasks.value = getTasks()
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun observeTasks(): LiveData<Result<List<Task>>> {
        runBlocking { refreshTasks() }
        return observableTasks
    }

    override fun observeTask(taskId: String): LiveData<Result<Task>> {
        return observableTasks.map { tasks ->
            when (tasks) {
                is Result.Loading -> Result.Loading
                is Error -> Error(tasks.exception)
                is Success -> {
                    val task = tasks.data.firstOrNull() { it.id == taskId }
                        ?: return@map Error(Exception("Not found"))
                    Success(task)
                }
            }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        tasksServiceData[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Could not find task"))
    }

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        return Success(tasksServiceData.values.toList())
    }

    override suspend fun saveTask(task: Task) {
        tasksServiceData[task.id] = task
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        tasksServiceData[task.id] = completedTask
    }

    override suspend fun completeTask(taskId: String) {
        
        throw NotImplementedError()
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        tasksServiceData[task.id] = activeTask
    }

    override suspend fun activateTask(taskId: String) {
        throw NotImplementedError()
    }

    override suspend fun clearCompletedTasks() {
        tasksServiceData = tasksServiceData.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteTask(taskId: String) {
        tasksServiceData.remove(taskId)
        refreshTasks()
    }

    override suspend fun deleteAllTasks() {
        tasksServiceData.clear()
        refreshTasks()
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        for (task in tasks) {
            tasksServiceData[task.id] = task
        }
        runBlocking { refreshTasks() }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import android.content.Context
import androidx.annotation.VisibleForTesting
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource
import kotlinx.coroutines.runBlocking


object ServiceLocator {

    private val lock = Any()
    private var database: ToDoDatabase? = null
    @Volatile
    var tasksRepository: TasksRepository? = null
        @VisibleForTesting set

    fun provideTasksRepository(context: Context): TasksRepository {
        synchronized(this) {
            return tasksRepository ?: tasksRepository ?: createTasksRepository(context)
        }
    }

    private fun createTasksRepository(context: Context): TasksRepository {
        database = Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java, "Tasks.db"
        )
            .build()

        return DefaultTasksRepository(
            TasksRemoteDataSource,
            TasksLocalDataSource(database!!.taskDao())
        )
    }

    @VisibleForTesting
    fun resetRepository() {
        synchronized(lock) {
            runBlocking {
                TasksRemoteDataSource.deleteAllTasks()
            }
            
            database?.apply {
                clearAllTables()
                close()
            }
            tasksRepository = null
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.assertThat
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class AddEditTaskScreenTest {

    @Before
    @After
    fun clearDb() = runBlocking {
        ServiceLocator.provideTasksRepository(getApplicationContext()).deleteAllTasks()
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun validTask_isSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        val scenario = launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.add_task_title))
          .perform(replaceText("title")) 
        onView(withId(R.id.add_task_description)).perform(
          replaceText("description")) 
        onView(withId(R.id.fab_save_task)).perform(click())

        
        
        
        val tasks = (ServiceLocator.provideTasksRepository(getApplicationContext())
                        .getTasksBlocking(true) as Result.Success).data
        assertThat(tasks.size, `is`(1))
        
        assertThat(tasks[0], notNullValue())
        assertThat(tasks[0].title, `is`("title"))
        assertThat(tasks[0].description, `is`("description"))

        verify(navController).navigate(
            AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK))
    }

}
<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import android.view.View
import android.widget.ListView
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import androidx.test.filters.SmallTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@SmallTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class TasksSingleScreenTest {

    private lateinit var repository: TasksRepository

    @Before
    fun setup() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
              isDescendantOfA(isAssignableFrom(ListView::class.java)),
              withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        verify(navController).navigate(
          TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
            null, getApplicationContext<Context>().getString(R.string.add_task)))
    }

    @Test
    @MediumTest
    fun displayTask_whenRepositoryHasData() {
        
        val repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.saveTaskBlocking(Task("title", "description"))

        
        launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)

        
        onView(withItemText("title")).check(matches(isDisplayed()))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun deleteOneTest() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun deleteOneOfTwoTests() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION2))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
        
        onView(withText(TITLE2)).check(matches(isDisplayed()))
    }

    private fun viewAllTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_all)).perform(ViewActions.click())
    }

    private fun viewActiveTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_active)).perform(ViewActions.click())
    }

    private fun viewCompletedTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_completed)).perform(ViewActions.click())
    }

    companion object {

        const val TITLE1 = "TITLE1"
        const val TITLE2 = "TITLE2"

        const val DESCRIPTION1 = "DESCRIPTION1"
        const val DESCRIPTION2 = "DESCRIPTION2"
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.util

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.runBlocking


fun TasksRepository.saveTaskBlocking(task: Task) = runBlocking {
    this@saveTaskBlocking.saveTask(task)
}

fun TasksRepository.getTasksBlocking(forceUpdate: Boolean) = runBlocking {
    this@getTasksBlocking.getTasks(forceUpdate)
}
<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.SmallTest
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
@SmallTest
class TasksDaoTest {

    private lateinit var database: ToDoDatabase

    @Before
    fun initDb() {
        
        
        database = Room.inMemoryDatabaseBuilder(
            getApplicationContext(),
            ToDoDatabase::class.java
        ).allowMainThreadQueries().build()
    }

    @After
    fun closeDb() = database.close()

    @Test
    fun insertTaskAndGetById() {
        
        val task = Task("title", "description", true, "id")
        database.taskDao().insertTask(task)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_TASK.id)

        
        assertThat<Task>(loaded as Task, notNullValue())
        assertThat(loaded.id, `is`(task.id))
        assertThat(loaded.title, `is`(task.title))
        assertThat(loaded.description, `is`(task.description))
        assertThat(loaded.isCompleted, `is`(task.isCompleted))
    }

    @Test
    fun insertTaskReplacesOnConflict() {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        val newTask = Task(NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED, DEFAULT_ID)
        database.taskDao().insertTask(newTask)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_TASK.id)

        
        assertTask(loaded, DEFAULT_ID, NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED)
    }

    @Test
    fun insertTaskAndGetTasks() = runBlocking {
        
        val task = Task("title", "description", true, "id")
        database.taskDao().insertTask(task)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(1))
        assertThat<Task>(tasks[0] as Task, notNullValue())
        assertThat(tasks[0].id, `is`(task.id))
        assertThat(tasks[0].title, `is`(task.title))
        assertThat(tasks[0].description, `is`(task.description))
        assertThat(tasks[0].isCompleted, `is`(task.isCompleted))
    }

    @Test
    fun updateTaskAndGetById() {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        val updatedTask = Task(NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED, DEFAULT_ID)
        database.taskDao().updateTask(updatedTask)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_ID)

        
        assertTask(loaded, DEFAULT_ID, NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED)
    }

    @Test
    fun updateCompletedAndGetById() {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().updateCompleted(DEFAULT_TASK.id, false)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_ID)

        
        assertTask(loaded, DEFAULT_TASK.id, DEFAULT_TASK.title, DEFAULT_TASK.description, false)
    }

    @Test
    fun deleteTaskByIdAndGettingTasks() = runBlocking {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().deleteTaskById(DEFAULT_TASK.id)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(0))
    }

    @Test
    fun deleteTasksAndGettingTasks() = runBlocking {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().deleteTasks()

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(0))
    }

    @Test
    fun deleteCompletedTasksAndGettingTasks() = runBlocking {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().deleteCompletedTasks()

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(0))
    }

    private fun assertTask(
        task: Task?,
        id: String,
        title: String,
        description: String,
        completed: Boolean
    ) {
        assertThat<Task>(task as Task, notNullValue())
        assertThat(task.id, `is`(id))
        assertThat(task.title, `is`(title))
        assertThat(task.description, `is`(description))
        assertThat(task.isCompleted, `is`(completed))
    }

    companion object {

        private val DEFAULT_TITLE = "title"
        private val DEFAULT_DESCRIPTION = "description"
        private val DEFAULT_ID = "id"
        private val DEFAULT_IS_COMPLETED = true
        private val DEFAULT_TASK = Task(DEFAULT_TITLE, DEFAULT_DESCRIPTION, DEFAULT_IS_COMPLETED,
          DEFAULT_ID)

        private val NEW_TITLE = "title2"
        private val NEW_DESCRIPTION = "description2"
        private val NEW_IS_COMPLETED = true
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.filters.LargeTest
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }

    @Test
    fun clickOnStatisticsNavigationItem_ShowsStatisticsScreen() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withText(R.string.statistics_title)).perform(click())

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))
    }

    @Test
    fun clickOnListNavigationItem_ShowsListScreen() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withText(R.string.list_title)).perform(click())

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        val task = Task("UI <- button", "Description")
        ServiceLocator.provideTasksRepository(getApplicationContext()).saveTaskBlocking(task)

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("UI <- button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        val task = Task("Back button", "Description")
        ServiceLocator.provideTasksRepository(getApplicationContext()).saveTaskBlocking(task)

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("Back button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        Espresso.pressBack()
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        Espresso.pressBack()
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.filters.SdkSuppress
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.currentActivity
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksScreenTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    private lateinit var repository: TasksRepository

    
    @UiThreadTest
    @Before
    fun resetState() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        runBlocking {
            repository.deleteAllTasks()
        }
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun createTask() {
        
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title))
          .perform(typeText("title"))
        onView(withId(R.id.add_task_description))
          .perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun orientationChange_FilterActivePersists() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()

        
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun orientationChange_FilterCompletedPersists() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(string.label_completed)).check(matches(isDisplayed()))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_ChangePersists() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 

        
        currentActivity.rotateOrientation()

        
        onView(withId(R.id.add_task_title)).check(matches(withText(TITLE2)))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_NoDuplicate() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(DESCRIPTION),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewAllTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewCompletedTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewActiveTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class AddEditTaskScreenTest {

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }
}
<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Service
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@Ignore("blocked on robolectric/4862")
class TasksSingleScreenTest {

    private lateinit var repository: TasksRepository

    @Before
    fun setup() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTest() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun deleteOneOfTwoTests() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION2))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
        
        onView(withText(TITLE2)).check(matches(isDisplayed()))
    }

    private fun viewAllTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_all)).perform(ViewActions.click())
    }

    private fun viewActiveTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_active)).perform(ViewActions.click())
    }

    private fun viewCompletedTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_completed)).perform(ViewActions.click())
    }

    companion object {

        const val TITLE1 = "TITLE1"
        const val TITLE2 = "TITLE2"

        const val DESCRIPTION1 = "DESCRIPTION1"
        const val DESCRIPTION2 = "DESCRIPTION2"
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.util

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.runBlocking


fun TasksRepository.saveTaskBlocking(task: Task) = runBlocking {
    this@saveTaskBlocking.saveTask(task)
}
<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class TasksDaoTest {

    private lateinit var database: ToDoDatabase

    @Before
    fun initDb() {
        
        
        database = Room.inMemoryDatabaseBuilder(
            getApplicationContext(),
            ToDoDatabase::class.java
        ).allowMainThreadQueries().build()
    }

    @After
    fun closeDb() = database.close()

    @Test
    fun insertTaskAndGetById() {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_TASK.id)

        
        assertTask(loaded, DEFAULT_ID, DEFAULT_TITLE, DEFAULT_DESCRIPTION, DEFAULT_IS_COMPLETED)
    }

    @Test
    fun insertTaskReplacesOnConflict() {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        val newTask = Task(NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED, DEFAULT_ID)
        database.taskDao().insertTask(newTask)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_TASK.id)

        
        assertTask(loaded, DEFAULT_ID, NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED)
    }

    @Test
    fun insertTaskAndGetTasks() = runBlocking {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(1))
        
        assertTask(tasks[0], DEFAULT_ID, DEFAULT_TITLE, DEFAULT_DESCRIPTION, DEFAULT_IS_COMPLETED)
    }

    @Test
    fun updateTaskAndGetById() {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        val updatedTask = Task(NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED, DEFAULT_ID)
        database.taskDao().updateTask(updatedTask)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_ID)

        
        assertTask(loaded, DEFAULT_ID, NEW_TITLE, NEW_DESCRIPTION, NEW_IS_COMPLETED)
    }

    @Test
    fun updateCompletedAndGetById() {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().updateCompleted(DEFAULT_TASK.id, false)

        
        val loaded = database.taskDao().getTaskById(DEFAULT_ID)

        
        assertTask(loaded, DEFAULT_TASK.id, DEFAULT_TASK.title, DEFAULT_TASK.description, false)
    }

    @Test
    fun deleteTaskByIdAndGettingTasks() = runBlocking {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().deleteTaskById(DEFAULT_TASK.id)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(0))
    }

    @Test
    fun deleteTasksAndGettingTasks() = runBlocking {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().deleteTasks()

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(0))
    }

    @Test
    fun deleteCompletedTasksAndGettingTasks() = runBlocking {
        
        database.taskDao().insertTask(DEFAULT_TASK)

        
        database.taskDao().deleteCompletedTasks()

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(0))
    }

    private fun assertTask(
        task: Task?,
        id: String,
        title: String,
        description: String,
        completed: Boolean
    ) {
        assertThat<Task>(task as Task, notNullValue())
        assertThat(task.id, `is`(id))
        assertThat(task.title, `is`(title))
        assertThat(task.description, `is`(description))
        assertThat(task.isCompleted, `is`(completed))
    }

    companion object {

        private val DEFAULT_TITLE = "title"
        private val DEFAULT_DESCRIPTION = "description"
        private val DEFAULT_ID = "id"
        private val DEFAULT_IS_COMPLETED = true
        private val DEFAULT_TASK = Task(DEFAULT_TITLE, DEFAULT_DESCRIPTION, DEFAULT_IS_COMPLETED,
          DEFAULT_ID)

        private val NEW_TITLE = "title2"
        private val NEW_DESCRIPTION = "description2"
        private val NEW_IS_COMPLETED = true
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.filters.LargeTest
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.custom.action.NavigationViewActions.navigateTo
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }

    @Test
    fun clickOnStatisticsNavigationItem_ShowsStatisticsScreen() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view)).perform(navigateTo(R.id.statisticsFragment))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))
    }

    @Test
    fun clickOnListNavigationItem_ShowsListScreen() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.tasksFragment))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        val task = Task("UI <- button", "Description")
        ServiceLocator.provideTasksRepository(getApplicationContext()).saveTaskBlocking(task)

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("UI <- button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        val task = Task("Back button", "Description")
        ServiceLocator.provideTasksRepository(getApplicationContext()).saveTaskBlocking(task)

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("Back button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        Espresso.pressBack()
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        Espresso.pressBack()
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.filters.SdkSuppress
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.currentActivity
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksScreenTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    private lateinit var repository: TasksRepository

    
    @UiThreadTest
    @Before
    fun resetState() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        runBlocking {
            repository.deleteAllTasks()
        }
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_opensAddTaskUi() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun addTaskToTasksList() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        Espresso.pressBack();

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun orientationChange_FilterActivePersists() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()

        
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun orientationChange_FilterCompletedPersists() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(string.label_completed)).check(matches(isDisplayed()))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_ChangePersists() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 

        
        currentActivity.rotateOrientation()

        
        onView(withId(R.id.add_task_title)).check(matches(withText(TITLE2)))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_NoDuplicate() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(DESCRIPTION),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewAllTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewCompletedTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewActiveTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.custom.action

import android.content.res.Resources.NotFoundException
import com.google.android.material.navigation.NavigationView
import androidx.test.espresso.PerformException
import androidx.test.espresso.UiController
import androidx.test.espresso.ViewAction
import androidx.test.espresso.matcher.ViewMatchers
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isDisplayingAtLeast
import androidx.test.espresso.matcher.ViewMatchers.withEffectiveVisibility
import androidx.test.espresso.util.HumanReadables
import androidx.drawerlayout.widget.DrawerLayout
import android.view.Menu
import android.view.View
import org.hamcrest.Matchers.allOf


object NavigationViewActions {

    
    fun navigateTo(menuItemId: Int): ViewAction {

        return object : ViewAction {

            override fun perform(uiController: UiController, view: View) {
                with((view as NavigationView).menu) {
                    findItem(menuItemId) ?: throw PerformException.Builder()
                            .withActionDescription(description)
                            .withViewDescription(HumanReadables.describe(view))
                            .withCause(RuntimeException(getErrorMessage(this, view)))
                            .build()
                    performIdentifierAction(menuItemId, 0)
                }
                uiController.loopMainThreadUntilIdle()
            }

            private fun getErrorMessage(menu: Menu, view: View): String {
                val NEW_LINE = System.getProperty("line.separator")
                val errorMessage = StringBuilder(
                        "Menu item was not found; available menu items:$NEW_LINE")
                for (position in 0 until menu.size()) {
                    errorMessage.append("[MenuItem] position=$position")
                    menu.getItem(position)?.run {
                        title?.let { errorMessage.append(", title=$it") }
                        view.resources?.let {
                            try {
                                errorMessage.append(
                                        ", id=${view.resources.getResourceName(itemId)}")
                            } catch (nfe: NotFoundException) {
                                errorMessage.append("not found")
                            }
                        }
                        errorMessage.append(NEW_LINE)
                    }
                }
                return errorMessage.toString()
            }

            override fun getDescription() = "Click on menu item with id"

            override fun getConstraints() = allOf<View>(
                    isAssignableFrom(NavigationView::class.java),
                    withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE),
                    isDisplayingAtLeast(90))
        }

    }
}


<code block>

package com.example.android.architecture.blueprints.todoapp.util

import java.util.concurrent.Executor
import java.util.concurrent.Executors


class DiskIOThreadExecutor : Executor {

    private val diskIO: Executor

    init {
        diskIO = Executors.newSingleThreadExecutor()
    }

    override fun execute(command: Runnable) {
        diskIO.execute(command)
    }
}
<code block>


package com.example.android.architecture.blueprints.todoapp.util

import android.os.Handler
import android.os.Looper
import android.support.annotation.VisibleForTesting

import java.util.concurrent.Executor
import java.util.concurrent.Executors

const val THREAD_COUNT = 3


open class AppExecutors constructor(
        val diskIO: Executor = DiskIOThreadExecutor(),
        val networkIO: Executor = Executors.newFixedThreadPool(THREAD_COUNT),
        val mainThread: Executor = MainThreadExecutor()
) {

    private class MainThreadExecutor : Executor {
        private val mainThreadHandler = Handler(Looper.getMainLooper())

        override fun execute(command: Runnable) {
            mainThreadHandler.post(command)
        }
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.data

import android.arch.persistence.room.Entity
import android.arch.persistence.room.PrimaryKey
import android.arch.persistence.room.ColumnInfo
import java.util.UUID


@Entity(tableName = "tasks")
data class Task @JvmOverloads constructor(
        @ColumnInfo(name = "title") val title: String,
        @ColumnInfo(name = "description") val description: String = "",
        @PrimaryKey @ColumnInfo(name = "entryid") val id: String = UUID.randomUUID().toString()
) {

    @ColumnInfo(name = "completed") var isCompleted = false

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description


    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() && description.isEmpty()
}
<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.arch.persistence.room.Database
import android.arch.persistence.room.Room
import android.arch.persistence.room.RoomDatabase
import android.content.Context

import com.example.android.architecture.blueprints.todoapp.data.Task


@Database(entities = arrayOf(Task::class), version = 1)
abstract class ToDoDatabase : RoomDatabase() {

    abstract fun taskDao(): TasksDao

    companion object {

        private var INSTANCE: ToDoDatabase? = null

        private val lock = Any()

        fun getInstance(context: Context): ToDoDatabase {
            synchronized(lock) {
                if (INSTANCE == null) {
                    INSTANCE = Room.databaseBuilder(context.applicationContext,
                            ToDoDatabase::class.java, "Tasks.db")
                            .build()
                }
                return INSTANCE!!
            }
        }
    }

}
<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.arch.persistence.room.Dao
import android.arch.persistence.room.Insert
import android.arch.persistence.room.OnConflictStrategy
import android.arch.persistence.room.Query
import android.arch.persistence.room.Update
import com.example.android.architecture.blueprints.todoapp.data.Task


@Dao interface TasksDao {

    
    @Query("SELECT * FROM Tasks") fun getTasks(): List<Task>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId") fun getTaskById(taskId: String): Task?

    
    @Insert(onConflict = OnConflictStrategy.REPLACE) fun insertTask(task: Task)

    
    @Update fun updateTask(task: Task): Int

    
    @Query("UPDATE tasks SET completed = :completed WHERE entryid = :taskId")
    fun updateCompleted(taskId: String, completed: Boolean)

    
    @Query("DELETE FROM Tasks WHERE entryid = :taskId") fun deleteTaskById(taskId: String): Int

    
    @Query("DELETE FROM Tasks") fun deleteTasks()

    
    @Query("DELETE FROM Tasks WHERE completed = 1") fun deleteCompletedTasks(): Int
}
<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.support.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.util.AppExecutors



class TasksLocalDataSource private constructor(
        val appExecutors: AppExecutors,
        val tasksDao: TasksDao
) : TasksDataSource {

    
    override fun getTasks(callback: TasksDataSource.LoadTasksCallback) {
        appExecutors.diskIO.execute {
            val tasks = tasksDao.getTasks()
            appExecutors.mainThread.execute {
                if (tasks.isEmpty()) {
                    
                    callback.onDataNotAvailable()
                } else {
                    callback.onTasksLoaded(tasks)
                }
            }
        }
    }

    
    override fun getTask(taskId: String, callback: TasksDataSource.GetTaskCallback) {
        appExecutors.diskIO.execute {
            val task = tasksDao.getTaskById(taskId)
            appExecutors.mainThread.execute {
                if (task != null) {
                    callback.onTaskLoaded(task)
                } else {
                    callback.onDataNotAvailable()
                }
            }
        }
    }

    override fun saveTask(task: Task) {
        appExecutors.diskIO.execute {
            tasksDao.insertTask(task)
        }
    }

    override fun completeTask(task: Task) {
        appExecutors.diskIO.execute {
            tasksDao.updateCompleted(task.id, true)
        }
    }

    override fun completeTask(taskId: String) {
        
        
    }

    override fun activateTask(task: Task) {
        appExecutors.diskIO.execute {
            tasksDao.updateCompleted(task.id, false)
        }
    }

    override fun activateTask(taskId: String) {
        
        
    }

    override fun clearCompletedTasks() {
        appExecutors.diskIO.execute { tasksDao.deleteCompletedTasks() }
    }

    override fun refreshTasks() {
        
        
    }

    override fun deleteAllTasks() {
        appExecutors.diskIO.execute { tasksDao.deleteTasks() }
    }

    override fun deleteTask(taskId: String) {
        appExecutors.diskIO.execute { tasksDao.deleteTaskById(taskId) }
    }

    companion object {
        private var INSTANCE: TasksLocalDataSource? = null

        @JvmStatic
        fun getInstance(appExecutors: AppExecutors, tasksDao: TasksDao): TasksLocalDataSource {
            if (INSTANCE == null) {
                synchronized(TasksLocalDataSource::javaClass) {
                    INSTANCE = TasksLocalDataSource(appExecutors, tasksDao)
                }
            }
            return INSTANCE!!
        }

        @VisibleForTesting
        fun clearInstance() {
            INSTANCE = null
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.any
import com.example.android.architecture.blueprints.todoapp.util.capture
import com.example.android.architecture.blueprints.todoapp.util.eq
import com.google.common.collect.Lists
import org.hamcrest.CoreMatchers.`is`
import org.junit.After
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertThat
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentCaptor
import org.mockito.Captor
import org.mockito.Mock
import org.mockito.Mockito.never
import org.mockito.Mockito.times
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations


class TasksRepositoryTest {

    private val TASK_TITLE = "title"
    private val TASK_TITLE2 = "title2"
    private val TASK_TITLE3 = "title3"
    private val TASK_DESCRIPTION = "Some task description."
    private val TASKS = Lists.newArrayList(Task("Title1", "Description1"),
            Task("Title2", "Description2"))
    private lateinit var tasksRepository: TasksRepository
    @Mock private lateinit var tasksRemoteDataSource: TasksDataSource
    @Mock private lateinit var tasksLocalDataSource: TasksDataSource
    @Mock private lateinit var getTaskCallback: TasksDataSource.GetTaskCallback
    @Mock private lateinit var loadTasksCallback: TasksDataSource.LoadTasksCallback
    @Captor private lateinit var tasksCallbackCaptor:
            ArgumentCaptor<TasksDataSource.LoadTasksCallback>
    @Captor private lateinit var taskCallbackCaptor: ArgumentCaptor<TasksDataSource.GetTaskCallback>

    @Before fun setupTasksRepository() {
        
        
        MockitoAnnotations.initMocks(this)

        
        tasksRepository = TasksRepository.getInstance(
                tasksRemoteDataSource, tasksLocalDataSource)
    }

    @After fun destroyRepositoryInstance() {
        TasksRepository.destroyInstance()
    }

    @Test fun getTasks_repositoryCachesAfterFirstApiCall() {
        
        
        twoTasksLoadCallsToRepository(loadTasksCallback)

        
        verify<TasksDataSource>(tasksRemoteDataSource).getTasks(
                any<TasksDataSource.LoadTasksCallback>())
    }

    @Test fun getTasks_requestsAllTasksFromLocalDataSource() {
        
        tasksRepository.getTasks(loadTasksCallback)

        
        verify<TasksDataSource>(tasksLocalDataSource).getTasks(
                any<TasksDataSource.LoadTasksCallback>())
    }

    @Test fun saveTask_savesTaskToServiceAPI() {
        
        val newTask = Task(TASK_TITLE, TASK_DESCRIPTION)

        
        tasksRepository.saveTask(newTask)

        
        verify<TasksDataSource>(tasksRemoteDataSource).saveTask(newTask)
        verify<TasksDataSource>(tasksLocalDataSource).saveTask(newTask)
        assertThat(tasksRepository.cachedTasks.size, `is`(1))
    }

    @Test fun completeTask_completesTaskToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION)

            saveTask(newTask)

            
            completeTask(newTask)

            
            verify<TasksDataSource>(tasksRemoteDataSource).completeTask(newTask)
            verify<TasksDataSource>(tasksLocalDataSource).completeTask(newTask)
            assertThat(cachedTasks.size, `is`(1))
            val cachedNewTask = cachedTasks[newTask.id]
            assertNotNull(cachedNewTask as Task)
            assertThat(cachedNewTask.isActive, `is`(false))
        }
    }

    @Test fun completeTaskId_completesTaskToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            Task(TASK_TITLE, TASK_DESCRIPTION).also {
                saveTask(it)

                
                completeTask(it.id)
                
                verify<TasksDataSource>(tasksRemoteDataSource).completeTask(it)
                verify<TasksDataSource>(tasksLocalDataSource).completeTask(it)
                assertThat(tasksRepository.cachedTasks.size, `is`(1))

                val cachedNewTask = cachedTasks[it.id]
                assertNotNull(cachedNewTask as Task)
                assertThat(cachedNewTask.isActive, `is`(false))
            }
        }
    }

    @Test fun activateTask_activatesTaskToServiceAPIUpdatesCache() {
        
        val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
        with(tasksRepository) {
            tasksRepository.saveTask(newTask)
            
            tasksRepository.activateTask(newTask)
            
            verify(tasksRemoteDataSource).activateTask(newTask)
            verify(tasksLocalDataSource).activateTask(newTask)
            assertThat(cachedTasks.size, `is`(1))
            val cachedNewTask = cachedTasks[newTask.id]
            assertNotNull(cachedNewTask as Task)
            assertThat(cachedNewTask.isActive, `is`(true))
        }
    }

    @Test fun activateTaskId_activatesTaskToServiceAPIUpdatesCache() {
        
        val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
        with(tasksRepository) {
            saveTask(newTask)

            
            activateTask(newTask.id)

            
            verify(tasksRemoteDataSource).activateTask(newTask)
            verify(tasksLocalDataSource).activateTask(newTask)
            assertThat(cachedTasks.size, `is`(1))
            val cachedNewTask = cachedTasks[newTask.id]
            assertNotNull(cachedNewTask as Task)
            assertThat(cachedNewTask.isActive, `is`(true))
        }
    }

    @Test fun getTask_requestsSingleTaskFromLocalDataSource() {
        
        tasksRepository.getTask(TASK_TITLE, getTaskCallback)

        
        verify(tasksLocalDataSource).getTask(eq(TASK_TITLE), any<TasksDataSource.GetTaskCallback>())
    }

    @Test fun deleteCompletedTasks_deleteCompletedTasksToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask)
            val newTask2 = Task(TASK_TITLE2, TASK_DESCRIPTION)
            saveTask(newTask2)
            val newTask3 = Task(TASK_TITLE3, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask3)

            
            clearCompletedTasks()


            
            verify(tasksRemoteDataSource).clearCompletedTasks()
            verify(tasksLocalDataSource).clearCompletedTasks()

            assertThat(cachedTasks.size, `is`(1))
            val task = cachedTasks[newTask2.id]
            assertNotNull(task as Task)
            assertTrue(task.isActive)
            assertThat(task.title, `is`(TASK_TITLE2))
        }
    }

    @Test fun deleteAllTasks_deleteTasksToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask)
            val newTask2 = Task(TASK_TITLE2, TASK_DESCRIPTION)
            saveTask(newTask2)
            val newTask3 = Task(TASK_TITLE3, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask3)

            
            deleteAllTasks()

            
            verify(tasksRemoteDataSource).deleteAllTasks()
            verify(tasksLocalDataSource).deleteAllTasks()

            assertThat(cachedTasks.size, `is`(0))
        }
    }

    @Test fun deleteTask_deleteTaskToServiceAPIRemovedFromCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted }
            saveTask(newTask)
            assertThat(cachedTasks.containsKey(newTask.id), `is`(true))

            
            deleteTask(newTask.id)

            
            verify(tasksRemoteDataSource).deleteTask(newTask.id)
            verify(tasksLocalDataSource).deleteTask(newTask.id)

            
            assertThat(cachedTasks.containsKey(newTask.id), `is`(false))
        }
    }

    @Test fun getTasksWithDirtyCache_tasksAreRetrievedFromRemote() {
        with(tasksRepository) {
            
            refreshTasks()
            getTasks(loadTasksCallback)
        }

        
        setTasksAvailable(tasksRemoteDataSource, TASKS)

        
        verify(tasksLocalDataSource, never()).getTasks(loadTasksCallback)
        verify(loadTasksCallback).onTasksLoaded(TASKS)
    }

    @Test fun getTasksWithLocalDataSourceUnavailable_tasksAreRetrievedFromRemote() {
        
        tasksRepository.getTasks(loadTasksCallback)

        
        setTasksNotAvailable(tasksLocalDataSource)

        
        setTasksAvailable(tasksRemoteDataSource, TASKS)

        
        verify(loadTasksCallback).onTasksLoaded(TASKS)
    }

    @Test fun getTasksWithBothDataSourcesUnavailable_firesOnDataUnavailable() {
        
        tasksRepository.getTasks(loadTasksCallback)

        
        setTasksNotAvailable(tasksLocalDataSource)

        
        setTasksNotAvailable(tasksRemoteDataSource)

        
        verify(loadTasksCallback).onDataNotAvailable()
    }

    @Test fun getTaskWithBothDataSourcesUnavailable_firesOnDataUnavailable() {
        
        val taskId = "123"

        
        tasksRepository.getTask(taskId, getTaskCallback)

        
        setTaskNotAvailable(tasksLocalDataSource, taskId)

        
        setTaskNotAvailable(tasksRemoteDataSource, taskId)

        
        verify(getTaskCallback).onDataNotAvailable()
    }

    @Test fun getTasks_refreshesLocalDataSource() {
        with(tasksRepository) {
            
            refreshTasks()

            
            getTasks(loadTasksCallback)
        }

        
        setTasksAvailable(tasksRemoteDataSource, TASKS)

        
        verify(tasksLocalDataSource, times(TASKS.size)).saveTask(any<Task>())
    }

    
    private fun twoTasksLoadCallsToRepository(callback: TasksDataSource.LoadTasksCallback) {
        
        tasksRepository.getTasks(callback) 

        
        verify(tasksLocalDataSource).getTasks(capture(tasksCallbackCaptor))

        
        tasksCallbackCaptor.value.onDataNotAvailable()


        
        verify(tasksRemoteDataSource).getTasks(capture(tasksCallbackCaptor))

        
        tasksCallbackCaptor.value.onTasksLoaded(TASKS)

        tasksRepository.getTasks(callback) 
    }

    private fun setTasksNotAvailable(dataSource: TasksDataSource) {
        verify(dataSource).getTasks(capture(tasksCallbackCaptor))
        tasksCallbackCaptor.value.onDataNotAvailable()
    }

    private fun setTasksAvailable(dataSource: TasksDataSource, tasks: List<Task>) {
        verify(dataSource).getTasks(capture(tasksCallbackCaptor))
        tasksCallbackCaptor.value.onTasksLoaded(tasks)
    }

    private fun setTaskNotAvailable(dataSource: TasksDataSource, taskId: String) {
        verify(dataSource).getTask(eq(taskId), capture(taskCallbackCaptor))
        taskCallbackCaptor.value.onDataNotAvailable()
    }

    private fun setTaskAvailable(dataSource: TasksDataSource, task: Task) {
        verify(dataSource).getTask(eq(task.id), capture(taskCallbackCaptor))
        taskCallbackCaptor.value.onTaskLoaded(task)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import android.content.Context

import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource


object Injection {

    fun provideTasksRepository(context: Context) {
        val database = ToDoDatabase.getInstance(context)
        return TasksRepository.getInstance(FakeTasksRemoteDataSource,
                TasksLocalDataSource.getInstance(AppExecutors(), database.taskDao()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import android.content.Context

import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.util.AppExecutors


object Injection {

    fun provideTasksRepository(context: Context): TasksRepository {
        val database = ToDoDatabase.getInstance(context)
        return TasksRepository.getInstance(FakeTasksRemoteDataSource,
                TasksLocalDataSource.getInstance(AppExecutors(), database.taskDao()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.utils


import com.example.android.architecture.blueprints.todoapp.util.AppExecutors

import java.util.concurrent.Executor



class SingleExecutors : AppExecutors(instant, instant, instant) {
    companion object {
        private val instant = Executor { command -> command.run() }
    }
}
<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.arch.persistence.room.Room
import android.support.test.InstrumentationRegistry
import android.support.test.runner.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.data.Task
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class) class TasksDaoTest {

    private lateinit var database: ToDoDatabase

    @Before fun initDb() {
        
        
        database = Room.inMemoryDatabaseBuilder(InstrumentationRegistry.getContext(),
                ToDoDatabase::class.java).build()
    }

    @After fun closeDb() {
        database.close()
    }

    @Test fun insertTaskAndGetById() {
        
        database.taskDao().insertTask(TASK)

        
        val loaded = database.taskDao().getTaskById(TASK.id)

        
        assertTask(loaded, "id", "title", "description", true)
    }

    @Test fun insertTaskReplacesOnConflict() {
        
        database.taskDao().insertTask(TASK)

        
        val newTask = Task("title2", "description2", "id").apply {
            isCompleted = true
        }
        database.taskDao().insertTask(newTask)

        
        val loaded = database.taskDao().getTaskById(TASK.id)

        
        assertTask(loaded, "id", "title2", "description2", true)
    }

    @Test fun insertTaskAndGetTasks() {
        
        database.taskDao().insertTask(TASK)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(1))
        
        assertTask(tasks[0], "id", "title", "description", true)
    }

    @Test fun updateTaskAndGetById() {
        
        database.taskDao().insertTask(TASK)

        
        val updatedTask = Task("title2", "description2", "id").apply {
            isCompleted = true
        }
        database.taskDao().updateTask(updatedTask)

        
        val loaded = database.taskDao().getTaskById("id")

        
        assertTask(loaded, "id", "title2", "description2", true)
    }

    @Test fun updateCompletedAndGetById() {
        
        database.taskDao().insertTask(TASK)

        
        database.taskDao().updateCompleted(TASK.id, false)

        
        val loaded = database.taskDao().getTaskById("id")

        
        assertTask(loaded, TASK.id, TASK.title, TASK.description, false)
    }

    @Test fun deleteTaskByIdAndGettingTasks() {
        
        database.taskDao().insertTask(TASK)

        
        database.taskDao().deleteTaskById(TASK.id)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(0))
    }

    @Test fun deleteTasksAndGettingTasks() {
        
        database.taskDao().insertTask(TASK)

        
        database.taskDao().deleteTasks()

        
        val tasks = database.taskDao().getTasks()
        
        assertThat(tasks.size, `is`(0))
    }

    @Test fun deleteCompletedTasksAndGettingTasks() {
        
        database.taskDao().insertTask(TASK)

        
        database.taskDao().deleteCompletedTasks()

        
        val tasks = database.taskDao().getTasks()
        
        assertThat(tasks.size, `is`(0))
    }

    private fun assertTask(task: Task?, id: String, title: String,
            description: String, completed: Boolean) {
        assertThat<Task>(task as Task, notNullValue())
        assertThat(task.id, `is`(id))
        assertThat(task.title, `is`(title))
        assertThat(task.description, `is`(description))
        assertThat(task.isCompleted, `is`(completed))
    }

    companion object {
        private val TASK = Task("title", "description", "id").apply {
            isCompleted = true
        }
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.support.test.InstrumentationRegistry
import android.support.test.filters.LargeTest
import android.support.test.runner.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.util.any
import com.example.android.architecture.blueprints.todoapp.util.mock
import org.hamcrest.core.Is.`is`
import org.junit.After
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertThat
import org.junit.Assert.assertTrue
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify
import android.arch.persistence.room.Room
import com.example.android.architecture.blueprints.todoapp.utils.SingleExecutors



@RunWith(AndroidJUnit4::class) @LargeTest class TasksLocalDataSourceTest {

    private val TITLE = "title"
    private val TITLE2 = "title2"
    private val TITLE3 = "title3"
    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(InstrumentationRegistry.getContext(),
                ToDoDatabase::class.java)
                .build()

        
        TasksLocalDataSource.clearInstance()
        localDataSource = TasksLocalDataSource.getInstance(SingleExecutors(), database.taskDao())
    }

    @After
    fun cleanUp() {
        database.close()
        TasksLocalDataSource.clearInstance()
    }

    @Test fun testPreConditions() {
        assertNotNull(localDataSource)
    }

    @Test fun saveTask_retrievesTask() {
        
        val newTask = Task(TITLE)

        with(localDataSource) {
            
            saveTask(newTask)

            
            getTask(newTask.id, object : TasksDataSource.GetTaskCallback {
                override fun onTaskLoaded(task: Task) {
                    assertThat(task, `is`(newTask))
                }

                override fun onDataNotAvailable() {
                    fail("Callback error")
                }
            })
        }
    }

    @Test fun completeTask_retrievedTaskIsComplete() {
        
        val newTask = Task(TITLE)
        with(localDataSource) {
            saveTask(newTask)

            
            completeTask(newTask)

            
            getTask(newTask.id, object : TasksDataSource.GetTaskCallback {
                override fun onTaskLoaded(task: Task) {
                    assertThat(task, `is`(newTask))
                    assertThat(task.isCompleted, `is`(true))
                }

                override fun onDataNotAvailable() {
                    fail("Callback error")
                }
            })
        }
    }

    @Test fun activateTask_retrievedTaskIsActive() {
        
        val callback = mock<TasksDataSource.GetTaskCallback>()

        
        val newTask = Task(TITLE)
        with(localDataSource) {
            saveTask(newTask)
            completeTask(newTask)

            
            activateTask(newTask)

            
            getTask(newTask.id, callback)
        }
        verify(callback, never()).onDataNotAvailable()
        verify(callback).onTaskLoaded(newTask)

        assertThat(newTask.isCompleted, `is`(false))
    }

    @Test fun clearCompletedTask_taskNotRetrievable() {
        
        val callback1 = mock(TasksDataSource.GetTaskCallback::class.java)
        val callback2 = mock(TasksDataSource.GetTaskCallback::class.java)
        val callback3 = mock(TasksDataSource.GetTaskCallback::class.java)

        
        val newTask1 = Task(TITLE)
        val newTask2 = Task(TITLE2)
        val newTask3 = Task(TITLE3)
        with(localDataSource) {
            saveTask(newTask1)
            completeTask(newTask1)
            saveTask(newTask2)
            completeTask(newTask2)
            saveTask(newTask3)
            
            clearCompletedTasks()

            
            getTask(newTask1.id, callback1)

            verify(callback1).onDataNotAvailable()
            verify(callback1, never()).onTaskLoaded(newTask1)

            getTask(newTask2.id, callback2)

            verify(callback2).onDataNotAvailable()
            verify(callback2, never()).onTaskLoaded(newTask1)

            getTask(newTask3.id, callback3)

            verify(callback3, never()).onDataNotAvailable()
            verify(callback3).onTaskLoaded(newTask3)
        }
    }

    @Test fun deleteAllTasks_emptyListOfRetrievedTask() {
        val callback = mock(TasksDataSource.LoadTasksCallback::class.java)

        
        val newTask = Task(TITLE)

        with(localDataSource) {
            saveTask(newTask)

            
            deleteAllTasks()

            
            getTasks(callback)
        }
        verify<TasksDataSource.LoadTasksCallback>(callback).onDataNotAvailable()
        verify<TasksDataSource.LoadTasksCallback>(callback, never())
                .onTasksLoaded(any<List<Task>>())
    }

    @Test fun getTasks_retrieveSavedTasks() {
        
        val newTask1 = Task(TITLE)
        val newTask2 = Task(TITLE)

        with(localDataSource) {
            saveTask(newTask1)
            saveTask(newTask2)
            
            getTasks(object : TasksDataSource.LoadTasksCallback {
                override fun onTasksLoaded(tasks: List<Task>) {
                    assertNotNull(tasks)
                    assertTrue(tasks.size >= 2)

                    var newTask1IdFound = false
                    var newTask2IdFound = false
                    for ((_, _, id) in tasks) {
                        if (id == newTask1.id) {
                            newTask1IdFound = true
                        }
                        if (id == newTask2.id) {
                            newTask2IdFound = true
                        }
                    }
                    assertTrue(newTask1IdFound)
                    assertTrue(newTask2IdFound)
                }

                override fun onDataNotAvailable() {
                    fail()
                }
            })
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data

import java.util.UUID


data class Task @JvmOverloads constructor(
        val title: String,
        val description: String = "",
        val id: String = UUID.randomUUID().toString()
) {

    var isCompleted = false

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description


    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() && description.isEmpty()
}
<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.content.ContentValues
import android.content.Context
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_COMPLETED
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_DESCRIPTION
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_ENTRY_ID
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_TITLE
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.TABLE_NAME


class TasksLocalDataSource private constructor(context: Context) : TasksDataSource {

    private val dbHelper: TasksDbHelper = TasksDbHelper(context)

    
    override fun getTasks(callback: TasksDataSource.LoadTasksCallback) {
        val tasks = ArrayList<Task>()
        val db = dbHelper.readableDatabase

        val projection = arrayOf(COLUMN_NAME_ENTRY_ID, COLUMN_NAME_TITLE,
                COLUMN_NAME_DESCRIPTION, COLUMN_NAME_COMPLETED)

        val cursor = db.query(
                TABLE_NAME, projection, null, null, null, null, null)

        with(cursor) {
            while (moveToNext()) {
                val itemId = getString(getColumnIndexOrThrow(COLUMN_NAME_ENTRY_ID))
                val title = getString(getColumnIndexOrThrow(COLUMN_NAME_TITLE))
                val description = getString(getColumnIndexOrThrow(COLUMN_NAME_DESCRIPTION))
                val task = Task(title, description, itemId).apply {
                    isCompleted = getInt(getColumnIndexOrThrow(COLUMN_NAME_COMPLETED)) == 1
                }
                tasks.add(task)
            }
            if (tasks.isNotEmpty()) {
                callback.onTasksLoaded(tasks)
            } else {
                
                callback.onDataNotAvailable()
            }
            close()
        }
        db.close()
    }

    
    override fun getTask(taskId: String, callback: TasksDataSource.GetTaskCallback) {
        val db = dbHelper.readableDatabase

        val projection = arrayOf(COLUMN_NAME_ENTRY_ID, COLUMN_NAME_TITLE,
                COLUMN_NAME_DESCRIPTION, COLUMN_NAME_COMPLETED)

        val cursor = db.query(
                TABLE_NAME, projection, "$COLUMN_NAME_ENTRY_ID LIKE ?", arrayOf(taskId), null,
                null, null)

        with(cursor) {
            if (moveToFirst()) {
                val itemId = getString(getColumnIndexOrThrow(COLUMN_NAME_ENTRY_ID))
                val title = getString(getColumnIndexOrThrow(COLUMN_NAME_TITLE))
                val description = getString(getColumnIndexOrThrow(COLUMN_NAME_DESCRIPTION))
                val task = Task(title, description, itemId).apply {
                    isCompleted = getInt(getColumnIndexOrThrow(COLUMN_NAME_COMPLETED)) == 1
                }
                callback.onTaskLoaded(task)
            } else {
                callback.onDataNotAvailable()
            }
            close()
        }
        db.close()
    }

    override fun saveTask(task: Task) {
        val values = ContentValues().apply {
            put(COLUMN_NAME_ENTRY_ID, task.id)
            put(COLUMN_NAME_TITLE, task.title)
            put(COLUMN_NAME_DESCRIPTION, task.description)
            put(COLUMN_NAME_COMPLETED, task.isCompleted)
        }
        with(dbHelper.writableDatabase) {
            insert(TABLE_NAME, null, values)
            close()
        }
    }

    override fun completeTask(task: Task) {
        val values = ContentValues().apply {
            put(COLUMN_NAME_COMPLETED, true)
        }
        with(dbHelper.writableDatabase) {
            update(TABLE_NAME, values, "$COLUMN_NAME_ENTRY_ID LIKE ?", arrayOf(task.id))
            close()
        }
    }

    override fun completeTask(taskId: String) {
        
        
    }

    override fun activateTask(task: Task) {
        val values = ContentValues().apply {
            put(COLUMN_NAME_COMPLETED, false)
        }

        with(dbHelper.writableDatabase) {
            update(TABLE_NAME, values, "$COLUMN_NAME_ENTRY_ID LIKE ?", arrayOf(task.id))
            close()
        }
    }

    override fun activateTask(taskId: String) {
        
        
    }

    override fun clearCompletedTasks() {
        val selection = "$COLUMN_NAME_COMPLETED LIKE ?"
        val selectionArgs = arrayOf("1")
        with(dbHelper.writableDatabase) {
            delete(TABLE_NAME, selection, selectionArgs)
            close()
        }
    }

    override fun refreshTasks() {
        
        
    }

    override fun deleteAllTasks() {
        with(dbHelper.writableDatabase) {
            delete(TABLE_NAME, null, null)
            close()
        }
    }

    override fun deleteTask(taskId: String) {
        val selection = "$COLUMN_NAME_ENTRY_ID LIKE ?"
        val selectionArgs = arrayOf(taskId)
        with(dbHelper.writableDatabase) {
            delete(TABLE_NAME, selection, selectionArgs)
            close()
        }
    }

    companion object {
        private var INSTANCE: TasksLocalDataSource? = null

        @JvmStatic fun getInstance(context: Context): TasksLocalDataSource {
            return INSTANCE ?: TasksLocalDataSource(context).apply { INSTANCE = this }
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.provider.BaseColumns


object TasksPersistenceContract {

    
    object TaskEntry : BaseColumns {
        const val TABLE_NAME = "tasks"
        const val COLUMN_NAME_ENTRY_ID = "entryid"
        const val COLUMN_NAME_TITLE = "title"
        const val COLUMN_NAME_DESCRIPTION = "description"
        const val COLUMN_NAME_COMPLETED = "completed"
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_COMPLETED
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_DESCRIPTION
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_ENTRY_ID
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.COLUMN_NAME_TITLE
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksPersistenceContract.TaskEntry.TABLE_NAME

class TasksDbHelper(context: Context)
    : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(SQL_CREATE_ENTRIES)
    }

    
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) = Unit


    
    override fun onDowngrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) = Unit


    companion object {
        val DATABASE_VERSION = 1

        val DATABASE_NAME = "Tasks.db"

        private val SQL_CREATE_ENTRIES =
                "CREATE TABLE $TABLE_NAME (" +
                        "$COLUMN_NAME_ENTRY_ID TEXT PRIMARY KEY," +
                        "$COLUMN_NAME_TITLE TEXT," +
                        "$COLUMN_NAME_DESCRIPTION TEXT," +
                        "$COLUMN_NAME_COMPLETED INTEGER)"
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import android.content.Context
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.any
import com.example.android.architecture.blueprints.todoapp.util.capture
import com.example.android.architecture.blueprints.todoapp.util.eq
import com.google.common.collect.Lists
import org.hamcrest.CoreMatchers.`is`
import org.junit.After
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertThat
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentCaptor
import org.mockito.Captor
import org.mockito.Mock
import org.mockito.Mockito.never
import org.mockito.Mockito.times
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations


class TasksRepositoryTest {

    private val TASK_TITLE = "title"
    private val TASK_TITLE2 = "title2"
    private val TASK_TITLE3 = "title3"
    private val TASK_DESCRIPTION = "Some task description."
    private val TASKS = Lists.newArrayList(Task("Title1", "Description1"),
            Task("Title2", "Description2"))
    private lateinit var tasksRepository: TasksRepository
    @Mock private lateinit var tasksRemoteDataSource: TasksDataSource
    @Mock private lateinit var tasksLocalDataSource: TasksDataSource
    @Mock private lateinit var context: Context
    @Mock private lateinit var getTaskCallback: TasksDataSource.GetTaskCallback
    @Mock private lateinit var loadTasksCallback: TasksDataSource.LoadTasksCallback
    @Captor private lateinit var tasksCallbackCaptor:
            ArgumentCaptor<TasksDataSource.LoadTasksCallback>
    @Captor private lateinit var taskCallbackCaptor: ArgumentCaptor<TasksDataSource.GetTaskCallback>

    @Before fun setupTasksRepository() {
        
        
        MockitoAnnotations.initMocks(this)

        
        tasksRepository = TasksRepository.getInstance(
                tasksRemoteDataSource, tasksLocalDataSource)
    }

    @After fun destroyRepositoryInstance() {
        TasksRepository.destroyInstance()
    }

    @Test fun getTasks_repositoryCachesAfterFirstApiCall() {
        
        
        twoTasksLoadCallsToRepository(loadTasksCallback)

        
        verify<TasksDataSource>(tasksRemoteDataSource).getTasks(
                any<TasksDataSource.LoadTasksCallback>())
    }

    @Test fun getTasks_requestsAllTasksFromLocalDataSource() {
        
        tasksRepository.getTasks(loadTasksCallback)

        
        verify<TasksDataSource>(tasksLocalDataSource).getTasks(
                any<TasksDataSource.LoadTasksCallback>())
    }

    @Test fun saveTask_savesTaskToServiceAPI() {
        
        val newTask = Task(TASK_TITLE, TASK_DESCRIPTION)

        
        tasksRepository.saveTask(newTask)

        
        verify<TasksDataSource>(tasksRemoteDataSource).saveTask(newTask)
        verify<TasksDataSource>(tasksLocalDataSource).saveTask(newTask)
        assertThat(tasksRepository.cachedTasks.size, `is`(1))
    }

    @Test fun completeTask_completesTaskToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION)

            saveTask(newTask)

            
            completeTask(newTask)

            
            verify<TasksDataSource>(tasksRemoteDataSource).completeTask(newTask)
            verify<TasksDataSource>(tasksLocalDataSource).completeTask(newTask)
            assertThat(cachedTasks.size, `is`(1))
            val cachedNewTask = cachedTasks[newTask.id]
            assertNotNull(cachedNewTask as Task)
            assertThat(cachedNewTask.isActive, `is`(false))
        }
    }

    @Test fun completeTaskId_completesTaskToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            Task(TASK_TITLE, TASK_DESCRIPTION).also {
                saveTask(it)

                
                completeTask(it.id)
                
                verify<TasksDataSource>(tasksRemoteDataSource).completeTask(it)
                verify<TasksDataSource>(tasksLocalDataSource).completeTask(it)
                assertThat(tasksRepository.cachedTasks.size, `is`(1))

                val cachedNewTask = cachedTasks[it.id]
                assertNotNull(cachedNewTask as Task)
                assertThat(cachedNewTask.isActive, `is`(false))
            }
        }
    }

    @Test fun activateTask_activatesTaskToServiceAPIUpdatesCache() {
        
        val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
        with(tasksRepository) {
            tasksRepository.saveTask(newTask)
            
            tasksRepository.activateTask(newTask)
            
            verify(tasksRemoteDataSource).activateTask(newTask)
            verify(tasksLocalDataSource).activateTask(newTask)
            assertThat(cachedTasks.size, `is`(1))
            val cachedNewTask = cachedTasks[newTask.id]
            assertNotNull(cachedNewTask as Task)
            assertThat(cachedNewTask.isActive, `is`(true))
        }
    }

    @Test fun activateTaskId_activatesTaskToServiceAPIUpdatesCache() {
        
        val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
        with(tasksRepository) {
            saveTask(newTask)

            
            activateTask(newTask.id)

            
            verify(tasksRemoteDataSource).activateTask(newTask)
            verify(tasksLocalDataSource).activateTask(newTask)
            assertThat(cachedTasks.size, `is`(1))
            val cachedNewTask = cachedTasks[newTask.id]
            assertNotNull(cachedNewTask as Task)
            assertThat(cachedNewTask.isActive, `is`(true))
        }
    }

    @Test fun getTask_requestsSingleTaskFromLocalDataSource() {
        
        tasksRepository.getTask(TASK_TITLE, getTaskCallback)

        
        verify(tasksLocalDataSource).getTask(eq(TASK_TITLE), any<TasksDataSource.GetTaskCallback>())
    }

    @Test fun deleteCompletedTasks_deleteCompletedTasksToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask)
            val newTask2 = Task(TASK_TITLE2, TASK_DESCRIPTION)
            saveTask(newTask2)
            val newTask3 = Task(TASK_TITLE3, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask3)

            
            clearCompletedTasks()


            
            verify(tasksRemoteDataSource).clearCompletedTasks()
            verify(tasksLocalDataSource).clearCompletedTasks()

            assertThat(cachedTasks.size, `is`(1))
            val task = cachedTasks[newTask2.id]
            assertNotNull(task as Task)
            assertTrue(task.isActive)
            assertThat(task.title, `is`(TASK_TITLE2))
        }
    }

    @Test fun deleteAllTasks_deleteTasksToServiceAPIUpdatesCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask)
            val newTask2 = Task(TASK_TITLE2, TASK_DESCRIPTION)
            saveTask(newTask2)
            val newTask3 = Task(TASK_TITLE3, TASK_DESCRIPTION).apply { isCompleted = true }
            saveTask(newTask3)

            
            deleteAllTasks()

            
            verify(tasksRemoteDataSource).deleteAllTasks()
            verify(tasksLocalDataSource).deleteAllTasks()

            assertThat(cachedTasks.size, `is`(0))
        }
    }

    @Test fun deleteTask_deleteTaskToServiceAPIRemovedFromCache() {
        with(tasksRepository) {
            
            val newTask = Task(TASK_TITLE, TASK_DESCRIPTION).apply { isCompleted }
            saveTask(newTask)
            assertThat(cachedTasks.containsKey(newTask.id), `is`(true))

            
            deleteTask(newTask.id)

            
            verify(tasksRemoteDataSource).deleteTask(newTask.id)
            verify(tasksLocalDataSource).deleteTask(newTask.id)

            
            assertThat(cachedTasks.containsKey(newTask.id), `is`(false))
        }
    }

    @Test fun getTasksWithDirtyCache_tasksAreRetrievedFromRemote() {
        with(tasksRepository) {
            
            refreshTasks()
            getTasks(loadTasksCallback)
        }

        
        setTasksAvailable(tasksRemoteDataSource, TASKS)

        
        verify(tasksLocalDataSource, never()).getTasks(loadTasksCallback)
        verify(loadTasksCallback).onTasksLoaded(TASKS)
    }

    @Test fun getTasksWithLocalDataSourceUnavailable_tasksAreRetrievedFromRemote() {
        
        tasksRepository.getTasks(loadTasksCallback)

        
        setTasksNotAvailable(tasksLocalDataSource)

        
        setTasksAvailable(tasksRemoteDataSource, TASKS)

        
        verify(loadTasksCallback).onTasksLoaded(TASKS)
    }

    @Test fun getTasksWithBothDataSourcesUnavailable_firesOnDataUnavailable() {
        
        tasksRepository.getTasks(loadTasksCallback)

        
        setTasksNotAvailable(tasksLocalDataSource)

        
        setTasksNotAvailable(tasksRemoteDataSource)

        
        verify(loadTasksCallback).onDataNotAvailable()
    }

    @Test fun getTaskWithBothDataSourcesUnavailable_firesOnDataUnavailable() {
        
        val taskId = "123"

        
        tasksRepository.getTask(taskId, getTaskCallback)

        
        setTaskNotAvailable(tasksLocalDataSource, taskId)

        
        setTaskNotAvailable(tasksRemoteDataSource, taskId)

        
        verify(getTaskCallback).onDataNotAvailable()
    }

    @Test fun getTasks_refreshesLocalDataSource() {
        with(tasksRepository) {
            
            refreshTasks()

            
            getTasks(loadTasksCallback)
        }

        
        setTasksAvailable(tasksRemoteDataSource, TASKS)

        
        verify(tasksLocalDataSource, times(TASKS.size)).saveTask(any<Task>())
    }

    
    private fun twoTasksLoadCallsToRepository(callback: TasksDataSource.LoadTasksCallback) {
        
        tasksRepository.getTasks(callback) 

        
        verify(tasksLocalDataSource).getTasks(capture(tasksCallbackCaptor))

        
        tasksCallbackCaptor.value.onDataNotAvailable()


        
        verify(tasksRemoteDataSource).getTasks(capture(tasksCallbackCaptor))

        
        tasksCallbackCaptor.value.onTasksLoaded(TASKS)

        tasksRepository.getTasks(callback) 
    }

    private fun setTasksNotAvailable(dataSource: TasksDataSource) {
        verify(dataSource).getTasks(capture(tasksCallbackCaptor))
        tasksCallbackCaptor.value.onDataNotAvailable()
    }

    private fun setTasksAvailable(dataSource: TasksDataSource, tasks: List<Task>) {
        verify(dataSource).getTasks(capture(tasksCallbackCaptor))
        tasksCallbackCaptor.value.onTasksLoaded(tasks)
    }

    private fun setTaskNotAvailable(dataSource: TasksDataSource, taskId: String) {
        verify(dataSource).getTask(eq(taskId), capture(taskCallbackCaptor))
        taskCallbackCaptor.value.onDataNotAvailable()
    }

    private fun setTaskAvailable(dataSource: TasksDataSource, task: Task) {
        verify(dataSource).getTask(eq(task.id), capture(taskCallbackCaptor))
        taskCallbackCaptor.value.onTaskLoaded(task)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import android.content.Context

import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource


object Injection {

    fun provideTasksRepository(context: Context) =
            TasksRepository.getInstance(TasksRemoteDataSource,
                    TasksLocalDataSource.getInstance(context.applicationContext))
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import android.content.Context

import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource


object Injection {

    fun provideTasksRepository(context: Context) =
            TasksRepository.getInstance(FakeTasksRemoteDataSource,
                    TasksLocalDataSource.getInstance(context))
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data

import android.support.test.InstrumentationRegistry
import android.support.test.filters.LargeTest
import android.support.test.runner.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksDbHelper
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.util.any
import com.example.android.architecture.blueprints.todoapp.util.mock
import org.hamcrest.core.Is.`is`
import org.junit.After
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertThat
import org.junit.Assert.assertTrue
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.never
import org.mockito.Mockito.verify


@RunWith(AndroidJUnit4::class) @LargeTest class TasksLocalDataSourceTest {

    private val TITLE = "title"
    private val TITLE2 = "title2"
    private val TITLE3 = "title3"
    private lateinit var localDataSource: TasksLocalDataSource

    @Before fun setup() {
        localDataSource = TasksLocalDataSource.getInstance(
                InstrumentationRegistry.getTargetContext())
    }

    @After fun cleanUp() {
        localDataSource.deleteAllTasks()
    }

    @Test fun testPreConditions() {
        assertNotNull(localDataSource)
    }

    @Test fun saveTask_retrievesTask() {
        
        val newTask = Task(TITLE)

        with(localDataSource) {
            
            saveTask(newTask)

            
            getTask(newTask.id, object : TasksDataSource.GetTaskCallback {
                override fun onTaskLoaded(task: Task) {
                    assertThat(task, `is`(newTask))
                }

                override fun onDataNotAvailable() {
                    fail("Callback error")
                }
            })
        }
    }

    @Test fun completeTask_retrievedTaskIsComplete() {
        
        val newTask = Task(TITLE)
        with(localDataSource) {
            saveTask(newTask)

            
            completeTask(newTask)

            
            getTask(newTask.id, object : TasksDataSource.GetTaskCallback {
                override fun onTaskLoaded(task: Task) {
                    assertThat(task, `is`(newTask))
                    assertThat(task.isCompleted, `is`(true))
                }

                override fun onDataNotAvailable() {
                    fail("Callback error")
                }
            })
        }
    }

    @Test fun activateTask_retrievedTaskIsActive() {
        
        val callback = mock<TasksDataSource.GetTaskCallback>()

        
        val newTask = Task(TITLE)
        with(localDataSource) {
            saveTask(newTask)
            completeTask(newTask)

            
            activateTask(newTask)

            
            getTask(newTask.id, callback)
        }
        verify(callback, never()).onDataNotAvailable()
        verify(callback).onTaskLoaded(newTask)

        assertThat(newTask.isCompleted, `is`(false))
    }

    @Test fun clearCompletedTask_taskNotRetrievable() {
        
        val callback1 = mock(TasksDataSource.GetTaskCallback::class.java)
        val callback2 = mock(TasksDataSource.GetTaskCallback::class.java)
        val callback3 = mock(TasksDataSource.GetTaskCallback::class.java)

        
        val newTask1 = Task(TITLE)
        val newTask2 = Task(TITLE2)
        val newTask3 = Task(TITLE3)
        with(localDataSource) {
            saveTask(newTask1)
            completeTask(newTask1)
            saveTask(newTask2)
            completeTask(newTask2)
            saveTask(newTask3)
            
            clearCompletedTasks()

            
            getTask(newTask1.id, callback1)

            verify(callback1).onDataNotAvailable()
            verify(callback1, never()).onTaskLoaded(newTask1)

            getTask(newTask2.id, callback2)

            verify(callback2).onDataNotAvailable()
            verify(callback2, never()).onTaskLoaded(newTask1)

            getTask(newTask3.id, callback3)

            verify(callback3, never()).onDataNotAvailable()
            verify(callback3).onTaskLoaded(newTask3)
        }
    }

    @Test fun deleteAllTasks_emptyListOfRetrievedTask() {
        val callback = mock(TasksDataSource.LoadTasksCallback::class.java)

        
        val newTask = Task(TITLE)

        with(localDataSource) {
            saveTask(newTask)

            
            deleteAllTasks()

            
            getTasks(callback)
        }
        verify<TasksDataSource.LoadTasksCallback>(callback).onDataNotAvailable()
        verify<TasksDataSource.LoadTasksCallback>(callback, never())
                .onTasksLoaded(any<List<Task>>())
    }

    @Test fun getTasks_retrieveSavedTasks() {
        
        val newTask1 = Task(TITLE)
        val newTask2 = Task(TITLE)

        with(localDataSource) {
            saveTask(newTask1)
            saveTask(newTask2)
            
            getTasks(object : TasksDataSource.LoadTasksCallback {
                override fun onTasksLoaded(tasks: List<Task>) {
                    assertNotNull(tasks)
                    assertTrue(tasks.size >= 2)

                    var newTask1IdFound = false
                    var newTask2IdFound = false
                    for ((_, _, id) in tasks) {
                        if (id == newTask1.id) {
                            newTask1IdFound = true
                        }
                        if (id == newTask2.id) {
                            newTask2IdFound = true
                        }
                    }
                    assertTrue(newTask1IdFound)
                    assertTrue(newTask2IdFound)
                }

                override fun onDataNotAvailable() {
                    fail()
                }
            })
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import android.os.Bundle
import androidx.lifecycle.AbstractSavedStateViewModelFactory
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.savedstate.SavedStateRegistryOwner
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskViewModel
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsViewModel
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailViewModel
import com.example.android.architecture.blueprints.todoapp.tasks.TasksViewModel


@Suppress("UNCHECKED_CAST")
class ViewModelFactory constructor(
    private val tasksRepository: TasksRepository,
    owner: SavedStateRegistryOwner,
    defaultArgs: Bundle? = null
) : AbstractSavedStateViewModelFactory(owner, defaultArgs) {

    override fun <T : ViewModel> create(
        key: String,
        modelClass: Class<T>,
        handle: SavedStateHandle
    ) = with(modelClass) {
        when {
            isAssignableFrom(StatisticsViewModel::class.java) ->
                StatisticsViewModel(tasksRepository)
            isAssignableFrom(TaskDetailViewModel::class.java) ->
                TaskDetailViewModel(tasksRepository)
            isAssignableFrom(AddEditTaskViewModel::class.java) ->
                AddEditTaskViewModel(tasksRepository)
            isAssignableFrom(TasksViewModel::class.java) ->
                TasksViewModel(tasksRepository, handle)
            else ->
                throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
        }
    } as T
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val viewModel by viewModels<StatisticsViewModel> { getViewModelFactory() }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = DataBindingUtil.inflate(
            inflater, R.layout.statistics_frag, container,
            false
        )
        return viewDataBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewDataBinding.viewmodel = viewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    private val args: AddEditTaskFragmentArgs by navArgs()

    private val viewModel by viewModels<AddEditTaskViewModel> { getViewModelFactory() }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            this.viewmodel = viewModel
        }
        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        return viewDataBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupSnackbar()
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        viewModel.start(args.taskId)
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
    }

    private fun setupNavigation() {
        viewModel.taskUpdatedEvent.observe(viewLifecycleOwner, EventObserver {
            val action = AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
            findNavController().navigate(action)
        })
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getViewModelFactory() }

    private val args: TasksFragmentArgs by navArgs()

    private lateinit var viewDataBinding: TasksFragBinding

    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()
    }

    private fun setupNavigation() {
        viewModel.openTaskEvent.observe(viewLifecycleOwner, EventObserver {
            openTaskDetails(it)
        })
        viewModel.newTaskEvent.observe(viewLifecycleOwner, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(viewLifecycleOwner, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.add_task_fab)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.distinctUntilChanged
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import kotlinx.coroutines.launch


class TasksViewModel(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _forceUpdate = MutableLiveData<Boolean>(false)

    private val _items: LiveData<List<Task>> = _forceUpdate.switchMap { forceUpdate ->
        if (forceUpdate) {
            _dataLoading.value = true
            viewModelScope.launch {
                tasksRepository.refreshTasks()
                _dataLoading.value = false
            }
        }
        tasksRepository.observeTasks().distinctUntilChanged().switchMap { filterTasks(it) }
    }

    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarText: LiveData<Event<Int>> = _snackbarText

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    private var resultMessageShown: Boolean = false

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(getSavedFilterType())
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle.set(TASKS_FILTER_SAVED_STATE_KEY, requestType)

        
        when (requestType) {
            ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
        
        loadTasks(false)
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int,
        @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int,
        tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        if (resultMessageShown) return
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
        resultMessageShown = true
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    private fun filterTasks(tasksResult: Result<List<Task>>): LiveData<List<Task>> {
        
        val result = MutableLiveData<List<Task>>()

        if (tasksResult is Success) {
            isDataLoadingError.value = false
            viewModelScope.launch {
                result.value = filterItems(tasksResult.data, getSavedFilterType())
            }
        } else {
            result.value = emptyList()
            showSnackbarMessage(R.string.loading_tasks_error)
            isDataLoadingError.value = true
        }

        return result
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _forceUpdate.value = forceUpdate
    }

    private fun filterItems(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
        }

    fun refresh() {
        _forceUpdate.value = true
    }

    private fun getSavedFilterType(): TasksFilterType {
        return savedStateHandle.get(TASKS_FILTER_SAVED_STATE_KEY) ?: ALL_TASKS
    }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {
    private lateinit var viewDataBinding: TaskdetailFragBinding

    private val args: TaskDetailFragmentArgs by navArgs()

    private val viewModel by viewModels<TaskDetailViewModel> { getViewModelFactory() }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupFab()
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }

    private fun setupNavigation() {
        viewModel.deleteTaskEvent.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToTasksFragment(DELETE_RESULT_OK)
            findNavController().navigate(action)
        })
        viewModel.editTaskEvent.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToAddEditTaskFragment(
                    args.taskId,
                    resources.getString(R.string.edit_task)
                )
            findNavController().navigate(action)
        })
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.edit_task_fab)?.setOnClickListener {
            viewModel.editTask()
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = viewModel
        }
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner

        viewModel.start(args.taskId)

        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewModel.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import androidx.annotation.VisibleForTesting
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException


@VisibleForTesting(otherwise = VisibleForTesting.NONE)
fun <T> LiveData<T>.getOrAwaitValue(
    time: Long = 2,
    timeUnit: TimeUnit = TimeUnit.SECONDS,
    afterObserve: () -> Unit = {}
): T {
    var data: T? = null
    val latch = CountDownLatch(1)
    val observer = object : Observer<T> {
        override fun onChanged(o: T?) {
            data = o
            latch.countDown()
            this@getOrAwaitValue.removeObserver(this)
        }
    }
    this.observeForever(observer)

    try {
        afterObserve.invoke()

        
        if (!latch.await(time, timeUnit)) {
            this.removeObserver(observer)
            throw TimeoutException("LiveData value was never set.")
        }
    } finally {
        this.removeObserver(observer)
    }
    @Suppress("UNCHECKED_CAST")
    return data as T
}


fun <T> LiveData<T>.observeForTesting(block: () -> Unit) {
    val observer = Observer<T> { }
    try {
        observeForever(observer)
        block()
    } finally {
        removeObserver(observer)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.util

import android.view.View
import androidx.databinding.DataBindingUtil
import androidx.databinding.ViewDataBinding
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.fragment.app.testing.FragmentScenario
import androidx.test.core.app.ActivityScenario
import androidx.test.espresso.IdlingResource
import java.util.UUID


class DataBindingIdlingResource : IdlingResource {
    
    private val idlingCallbacks = mutableListOf<IdlingResource.ResourceCallback>()
    
    
    private val id = UUID.randomUUID().toString()
    
    
    private var wasNotIdle = false

    lateinit var activity: FragmentActivity

    override fun getName() = "DataBinding $id"

    override fun isIdleNow(): Boolean {
        val idle = !getBindings().any { it.hasPendingBindings() }
        @Suppress("LiftReturnOrAssignment")
        if (idle) {
            if (wasNotIdle) {
                
                idlingCallbacks.forEach { it.onTransitionToIdle() }
            }
            wasNotIdle = false
        } else {
            wasNotIdle = true
            
            activity.findViewById<View>(android.R.id.content).postDelayed({
                isIdleNow
            }, 16)
        }
        return idle
    }

    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback) {
        idlingCallbacks.add(callback)
    }

    
    private fun getBindings(): List<ViewDataBinding> {
        val fragments = (activity as? FragmentActivity)
            ?.supportFragmentManager
            ?.fragments

        val bindings =
            fragments?.mapNotNull {
                it.view?.getBinding()
            } ?: emptyList()
        val childrenBindings = fragments?.flatMap { it.childFragmentManager.fragments }
            ?.mapNotNull { it.view?.getBinding() } ?: emptyList()

        return bindings + childrenBindings
    }
}

private fun View.getBinding(): ViewDataBinding? = DataBindingUtil.getBinding(this)


fun DataBindingIdlingResource.monitorActivity(
    activityScenario: ActivityScenario<out FragmentActivity>
) {
    activityScenario.onActivity {
        this.activity = it
    }
}


fun <T : Fragment> DataBindingIdlingResource.monitorFragment(fragmentScenario: FragmentScenario<T>) {
    fragmentScenario.onFragment {
        this.activity = it.requireActivity()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.Navigation
import androidx.navigation.testing.TestNavHostController
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class AddEditTaskFragmentTest {
    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlockingTest {
        ServiceLocator.resetRepository()
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(
            null,
            getApplicationContext<Context>().getString(R.string.add_task)
        ).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title_edit_text)).perform(clearText())
        onView(withId(R.id.add_task_description_edit_text)).perform(clearText())
        onView(withId(R.id.save_task_fab)).perform(click())

        
        onView(withId(R.id.add_task_title_edit_text)).check(matches(isDisplayed()))
    }

    @Test
    fun validTask_navigatesBack() {
        
        val navController = TestNavHostController(getApplicationContext())
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title_edit_text)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description_edit_text)).perform(replaceText("description"))
        onView(withId(R.id.save_task_fab)).perform(click())

        
        assertEquals(navController.currentDestination?.id, R.id.tasks_fragment_dest)
    }

    @Test
    fun validTask_isSaved() {
        
        val navController = TestNavHostController(getApplicationContext())
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title_edit_text)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description_edit_text)).perform(replaceText("description"))
        onView(withId(R.id.save_task_fab)).perform(click())

        
        val tasks = (repository.getTasksBlocking(true) as Result.Success).data
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    private fun launchFragment(navController: TestNavHostController) {
        val bundle = AddEditTaskFragmentArgs(
            null,
            getApplicationContext<Context>().getString(R.string.add_task)
        ).toBundle()
        val scenario = launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)
        scenario.onFragment {
            navController.setGraph(R.navigation.nav_graph)
            navController.setCurrentDestination(R.id.add_edit_task_fragment_dest)
            Navigation.setViewNavController(it.requireView(), navController)
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.View
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.Navigation
import androidx.navigation.testing.TestNavHostController
import androidx.recyclerview.widget.RecyclerView
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ActivityScenario.launch
import androidx.test.core.app.ApplicationProvider
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.id
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import junit.framework.Assert.assertEquals
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Matcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlockingTest {
        ServiceLocator.resetRepository()
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        
        launchActivity()

        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchActivity()

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        launchActivity()

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchActivity()

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(doesNotExist())
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(matches(isDisplayed()))
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchActivity()

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(R.string.menu_clear)).perform(click())

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())

        
        onView(withText("You have no tasks!")).check(matches(isDisplayed()))
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        
        onView(withText("You have no completed tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())

        
        onView(withText("You have no active tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = TestNavHostController(ApplicationProvider.getApplicationContext())
        scenario.onFragment {
            navController.setGraph(R.navigation.nav_graph)
            navController.setCurrentDestination(R.id.tasks_fragment_dest)
            Navigation.setViewNavController(it.requireView(), navController)
        }

        
        onView(withId(R.id.add_task_fab)).perform(click())

        
        assertEquals(navController.currentDestination?.id, id.add_edit_task_fragment_dest)
    }

    private fun launchActivity(): ActivityScenario<TasksActivity>? {
        val activityScenario = launch(TasksActivity::class.java)
        activityScenario.onActivity { activity ->
            
            (activity.findViewById(R.id.tasks_list) as RecyclerView).itemAnimator = null
        }
        return activityScenario
    }

    private fun checkboxWithText(text: String): Matcher<View> {
        return allOf(withId(R.id.complete_checkbox), hasSibling(withText(text)))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import android.app.Application
import android.os.Bundle
import androidx.lifecycle.AbstractSavedStateViewModelFactory
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.SavedStateViewModelFactory
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.savedstate.SavedStateRegistryOwner
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskViewModel
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsViewModel
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailViewModel
import com.example.android.architecture.blueprints.todoapp.tasks.TasksViewModel


@Suppress("UNCHECKED_CAST")
class ViewModelFactory constructor(
        private val tasksRepository: TasksRepository,
        owner: SavedStateRegistryOwner,
        defaultArgs: Bundle? = null
) : AbstractSavedStateViewModelFactory(owner, defaultArgs) {

    override fun <T : ViewModel> create(
            key: String,
            modelClass: Class<T>,
            handle: SavedStateHandle
    ) = with(modelClass) {
        when {
            isAssignableFrom(StatisticsViewModel::class.java) ->
                StatisticsViewModel(tasksRepository)
            isAssignableFrom(TaskDetailViewModel::class.java) ->
                TaskDetailViewModel(tasksRepository)
            isAssignableFrom(AddEditTaskViewModel::class.java) ->
                AddEditTaskViewModel(tasksRepository)
            isAssignableFrom(TasksViewModel::class.java) ->
                TasksViewModel(tasksRepository, handle)
            else ->
                throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
        }
    } as T
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val viewModel by viewModels<StatisticsViewModel> { getViewModelFactory() }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = DataBindingUtil.inflate(
            inflater, R.layout.statistics_frag, container,
            false
        )
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.viewmodel = viewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    private val args: AddEditTaskFragmentArgs by navArgs()

    private val viewModel by viewModels<AddEditTaskViewModel> { getViewModelFactory() }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            this.viewmodel = viewModel
        }
        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupSnackbar()
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        viewModel.start(args.taskId)
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
    }

    private fun setupNavigation() {
        viewModel.taskUpdatedEvent.observe(this, EventObserver {
            val action = AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
            findNavController().navigate(action)
        })
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getViewModelFactory() }

    private val args: TasksFragmentArgs by navArgs()

    private lateinit var viewDataBinding: TasksFragBinding

    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()
    }

    private fun setupNavigation() {
        viewModel.openTaskEvent.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewModel.newTaskEvent.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.add_task_fab)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.distinctUntilChanged
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import kotlinx.coroutines.launch


class TasksViewModel(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _forceUpdate = MutableLiveData<Boolean>(false)

    private val _items: LiveData<List<Task>> = _forceUpdate.switchMap { forceUpdate ->
        if (forceUpdate) {
            _dataLoading.value = true
            viewModelScope.launch {
                tasksRepository.refreshTasks()
                _dataLoading.value = false
            }
        }
        tasksRepository.observeTasks().distinctUntilChanged().switchMap { filterTasks(it) }
    }

    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarText: LiveData<Event<Int>> = _snackbarText

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    private var resultMessageShown: Boolean = false

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(getSavedFilterType())
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle.set(TASKS_FILTER_SAVED_STATE_KEY, requestType)

        
        when (requestType) {
            ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
        
        loadTasks(false)
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int,
        @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int,
        tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        if (resultMessageShown) return
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
        resultMessageShown = true
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    private fun filterTasks(tasksResult: Result<List<Task>>): LiveData<List<Task>> {
        
        val result = MutableLiveData<List<Task>>()

        if (tasksResult is Success) {
            isDataLoadingError.value = false
            viewModelScope.launch {
                result.value = filterItems(tasksResult.data, getSavedFilterType())
            }
        } else {
            result.value = emptyList()
            showSnackbarMessage(R.string.loading_tasks_error)
            isDataLoadingError.value = true
        }

        return result
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _forceUpdate.value = forceUpdate
    }

    private fun filterItems(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
        }

    fun refresh() {
        _forceUpdate.value = true
    }

    private fun getSavedFilterType() : TasksFilterType {
        return savedStateHandle.get(TASKS_FILTER_SAVED_STATE_KEY) ?: ALL_TASKS
    }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {
    private lateinit var viewDataBinding: TaskdetailFragBinding

    private val args: TaskDetailFragmentArgs by navArgs()

    private val viewModel by viewModels<TaskDetailViewModel> { getViewModelFactory() }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }

    private fun setupNavigation() {
        viewModel.deleteTaskEvent.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToTasksFragment(DELETE_RESULT_OK)
            findNavController().navigate(action)
        })
        viewModel.editTaskEvent.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToAddEditTaskFragment(
                    args.taskId,
                    resources.getString(R.string.edit_task)
                )
            findNavController().navigate(action)
        })
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.edit_task_fab)?.setOnClickListener {
            viewModel.editTask()
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = viewModel
        }
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner

        viewModel.start(args.taskId)

        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewModel.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import androidx.annotation.VisibleForTesting
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException


@VisibleForTesting(otherwise = VisibleForTesting.NONE)
fun <T> LiveData<T>.getOrAwaitValue(
    time: Long = 2,
    timeUnit: TimeUnit = TimeUnit.SECONDS,
    afterObserve: () -> Unit = {}
): T {
    var data: T? = null
    val latch = CountDownLatch(1)
    val observer = object : Observer<T> {
        override fun onChanged(o: T?) {
            data = o
            latch.countDown()
            this@getOrAwaitValue.removeObserver(this)
        }
    }
    this.observeForever(observer)

    try {
        afterObserve.invoke()

        
        if (!latch.await(time, timeUnit)) {
            this.removeObserver(observer)
            throw TimeoutException("LiveData value was never set.")
        }

    } finally {
        this.removeObserver(observer)
    }
    @Suppress("UNCHECKED_CAST")
    return data as T
}


fun <T> LiveData<T>.observeForTesting(block: () -> Unit) {
    val observer = Observer<T> { }
    try {
        observeForever(observer)
        block()
    } finally {
        removeObserver(observer)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.util

import android.view.View
import androidx.databinding.DataBindingUtil
import androidx.databinding.ViewDataBinding
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.fragment.app.testing.FragmentScenario
import androidx.test.core.app.ActivityScenario
import androidx.test.espresso.IdlingResource
import java.util.UUID


class DataBindingIdlingResource : IdlingResource {
    
    private val idlingCallbacks = mutableListOf<IdlingResource.ResourceCallback>()
    
    
    private val id = UUID.randomUUID().toString()
    
    
    private var wasNotIdle = false

    lateinit var activity: FragmentActivity

    override fun getName() = "DataBinding $id"

    override fun isIdleNow(): Boolean {
        val idle = !getBindings().any { it.hasPendingBindings() }
        @Suppress("LiftReturnOrAssignment")
        if (idle) {
            if (wasNotIdle) {
                
                idlingCallbacks.forEach { it.onTransitionToIdle() }
            }
            wasNotIdle = false
        } else {
            wasNotIdle = true
            
            activity.findViewById<View>(android.R.id.content).postDelayed({
                isIdleNow
            }, 16)
        }
        return idle
    }

    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback) {
        idlingCallbacks.add(callback)
    }

    
    private fun getBindings(): List<ViewDataBinding> {
        val fragments = (activity as? FragmentActivity)
            ?.supportFragmentManager
            ?.fragments

        val bindings =
            fragments?.mapNotNull {
                it.view?.getBinding()
            } ?: emptyList()
        val childrenBindings = fragments?.flatMap { it.childFragmentManager.fragments }
            ?.mapNotNull { it.view?.getBinding() } ?: emptyList()

        return bindings + childrenBindings
    }
}

private fun View.getBinding(): ViewDataBinding? = DataBindingUtil.getBinding(this)


fun DataBindingIdlingResource.monitorActivity(
    activityScenario: ActivityScenario<out FragmentActivity>
) {
    activityScenario.onActivity {
        this.activity = it
    }
}


fun DataBindingIdlingResource.monitorFragment(fragmentScenario: FragmentScenario<out Fragment>) {
    fragmentScenario.onFragment {
        this.activity = it.requireActivity()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class AddEditTaskFragmentTest {
    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlockingTest {
        ServiceLocator.resetRepository()
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(
            null,
            getApplicationContext<Context>().getString(R.string.add_task)
        ).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title_edit_text)).perform(clearText())
        onView(withId(R.id.add_task_description_edit_text)).perform(clearText())
        onView(withId(R.id.save_task_fab)).perform(click())

        
        onView(withId(R.id.add_task_title_edit_text)).check(matches(isDisplayed()))
    }

    @Test
    fun validTask_navigatesBack() {
        
        val navController = mock(NavController::class.java)
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title_edit_text)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description_edit_text)).perform(replaceText("description"))
        onView(withId(R.id.save_task_fab)).perform(click())

        
        verify(navController).navigate(
            AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
        )
    }

    private fun launchFragment(navController: NavController?) {
        val bundle = AddEditTaskFragmentArgs(
            null,
            getApplicationContext<Context>().getString(R.string.add_task)
        ).toBundle()
        val scenario = launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }
    }

    @Test
    fun validTask_isSaved() {
        
        val navController = mock(NavController::class.java)
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title_edit_text)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description_edit_text)).perform(replaceText("description"))
        onView(withId(R.id.save_task_fab)).perform(click())

        
        val tasks = (repository.getTasksBlocking(true) as Result.Success).data
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import android.view.View
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.recyclerview.widget.RecyclerView
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ActivityScenario.launch
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Matcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlockingTest {
        ServiceLocator.resetRepository()
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        
        launchActivity()

        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchActivity()

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        launchActivity()

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchActivity()

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(doesNotExist())
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(matches(isDisplayed()))
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchActivity()

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(R.string.menu_clear)).perform(click())

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())

        
        onView(withText("You have no tasks!")).check(matches(isDisplayed()))
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        
        onView(withText("You have no completed tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())

        
        onView(withText("You have no active tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.add_task_fab)).perform(click())

        
        verify(navController).navigate(
            TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
                null, getApplicationContext<Context>().getString(R.string.add_task)
            )
        )
    }

    private fun launchActivity(): ActivityScenario<TasksActivity>? {
        val activityScenario = launch(TasksActivity::class.java)
        activityScenario.onActivity { activity ->
            
            (activity.findViewById(R.id.tasks_list) as RecyclerView).itemAnimator = null
        }
        return activityScenario
    }

    private fun checkboxWithText(text: String): Matcher<View> {
        return allOf(withId(R.id.complete_checkbox), hasSibling(withText(text)))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import kotlinx.coroutines.flow.Flow


interface TaskRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refresh()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun createTask(title: String, description: String): String

    suspend fun updateTask(taskId: String, title: String, description: String)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.TaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.di.ApplicationScope
import com.example.android.architecture.blueprints.todoapp.di.DefaultDispatcher
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


@Singleton
class DefaultTaskRepository @Inject constructor(
    private val networkDataSource: NetworkDataSource,
    private val localDataSource: TaskDao,
    @DefaultDispatcher private val dispatcher: CoroutineDispatcher,
    @ApplicationScope private val scope: CoroutineScope,
) : TaskRepository {

    override suspend fun createTask(title: String, description: String): String {
        
        
        val taskId = withContext(dispatcher) {
            UUID.randomUUID().toString()
        }
        val task = Task(
            title = title,
            description = description,
            id = taskId,
        )
        localDataSource.upsert(task.toLocal())
        saveTasksToNetwork()
        return taskId
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val task = getTask(taskId)?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        localDataSource.upsert(task.toLocal())
        saveTasksToNetwork()
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            refresh()
        }
        return withContext(dispatcher) {
            localDataSource.getAll().toExternal()
        }
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return localDataSource.observeAll().map { tasks ->
            withContext(dispatcher) {
                tasks.toExternal()
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        refresh()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return localDataSource.observeById(taskId).map { it.toExternal() }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            refresh()
        }
        return localDataSource.getById(taskId)?.toExternal()
    }

    override suspend fun completeTask(taskId: String) {
        localDataSource.updateCompleted(taskId = taskId, completed = true)
        saveTasksToNetwork()
    }

    override suspend fun activateTask(taskId: String) {
        localDataSource.updateCompleted(taskId = taskId, completed = false)
        saveTasksToNetwork()
    }

    override suspend fun clearCompletedTasks() {
        localDataSource.deleteCompleted()
        saveTasksToNetwork()
    }

    override suspend fun deleteAllTasks() {
        localDataSource.deleteAll()
        saveTasksToNetwork()
    }

    override suspend fun deleteTask(taskId: String) {
        localDataSource.deleteById(taskId)
        saveTasksToNetwork()
    }

    

    
    override suspend fun refresh() {
        withContext(dispatcher) {
            val remoteTasks = networkDataSource.loadTasks()
            localDataSource.deleteAll()
            localDataSource.upsertAll(remoteTasks.toLocal())
        }
    }

    
    private fun saveTasksToNetwork() {
        scope.launch {
            try {
                val localTasks = localDataSource.getAll()
                networkDataSource.saveTasks(localTasks.toNetwork())
            } catch (e: Exception) {
                
                
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network

import javax.inject.Inject
import kotlinx.coroutines.delay


class TaskNetworkDataSource @Inject constructor() : NetworkDataSource {

    private val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASK_SERVICE_DATA = LinkedHashMap<String, NetworkTask>(2)

    init {
        addTask(
            id = "PISA",
            title = "Build tower in Pisa",
            shortDescription = "Ground looks good, no foundation work required."
        )
        addTask(
            id = "TACOMA",
            title = "Finish bridge in Tacoma",
            shortDescription = "Found awesome girders at half the cost!"
        )
    }

    override suspend fun loadTasks(): List<NetworkTask> {
        
        val tasks = TASK_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun saveTasks(tasks: List<NetworkTask>) {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        TASK_SERVICE_DATA.clear()
        TASK_SERVICE_DATA.putAll(tasks.associateBy(NetworkTask::id))
    }

    private fun addTask(id: String, title: String, shortDescription: String) {
        val newTask = NetworkTask(id = id, title = title, shortDescription = shortDescription)
        TASK_SERVICE_DATA[newTask.id] = newTask
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.DefaultTaskRepository
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.network.TaskNetworkDataSource
import dagger.Binds
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Singleton
    @Binds
    abstract fun bindTaskRepository(repository: DefaultTaskRepository): TaskRepository
}

@Module
@InstallIn(SingletonComponent::class)
abstract class DataSourceModule {

    @Singleton
    @Binds
    abstract fun bindNetworkDataSource(dataSource: TaskNetworkDataSource): NetworkDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }

    @Provides
    fun provideTaskDao(database: ToDoDatabase): TaskDao = database.taskDao()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class IoDispatcher

@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class DefaultDispatcher

@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class ApplicationScope

@Module
@InstallIn(SingletonComponent::class)
object CoroutinesModule {

    @Provides
    @IoDispatcher
    fun providesIODispatcher(): CoroutineDispatcher = Dispatchers.IO

    @Provides
    @DefaultDispatcher
    fun providesDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default

    @Provides
    @Singleton
    @ApplicationScope
    fun providesCoroutineScope(
        @DefaultDispatcher dispatcher: CoroutineDispatcher
    ): CoroutineScope = CoroutineScope(SupervisorJob() + dispatcher)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val taskRepository: TaskRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        taskRepository.getTasksStream()
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            taskRepository.refresh()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<List<Task>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Error -> {
                
                StatisticsUiState(isEmpty = true, isLoading = false)
            }
            is Async.Success -> {
                val stats = getActiveAndCompletedStats(taskLoad.data)
                StatisticsUiState(
                    isEmpty = taskLoad.data.isEmpty(),
                    activeTasksPercent = stats.activeTasksPercent,
                    completedTasksPercent = stats.completedTasksPercent,
                    isLoading = false
                )
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val taskRepository: TaskRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(taskRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            taskRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            taskRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            taskRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            taskRepository.refresh()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.source.local.FakeTaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.FakeNetworkDataSource
import com.google.common.truth.Truth.assertThat
import junit.framework.TestCase.assertEquals
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTaskRepositoryTest {

    private val task1 = Task(id = "1", title = "Title1", description = "Description1")
    private val task2 = Task(id = "2", title = "Title2", description = "Description2")
    private val task3 = Task(id = "3", title = "Title3", description = "Description3")

    private val newTaskTitle = "Title new"
    private val newTaskDescription = "Description new"
    private val newTask = Task(id = "new", title = newTaskTitle, description = newTaskDescription)
    private val newTasks = listOf(newTask)

    private val networkTasks = listOf(task1, task2).toNetwork()
    private val localTasks = listOf(task3.toLocal())

    private lateinit var networkDataSource: FakeNetworkDataSource
    private lateinit var localDataSource: FakeTaskDao

    
    private lateinit var tasksRepository: DefaultTaskRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        networkDataSource = FakeNetworkDataSource(networkTasks.toMutableList())
        localDataSource = FakeTaskDao(localTasks)
        
        tasksRepository = DefaultTaskRepository(
            networkDataSource = networkDataSource,
            localDataSource = localDataSource,
            dispatcher = StandardTestDispatcher(),
            scope = TestScope()
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        networkDataSource.tasks?.clear()
        localDataSource.deleteAll()

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(networkTasks.toExternal())
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        advanceUntilIdle()

        
        assertThat(networkDataSource.tasks?.map { it.id }?.contains(newTaskId))
        assertThat(localDataSource.tasks?.map { it.id }?.contains(newTaskId))
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        networkDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            networkDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks.toExternal())
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        networkDataSource.tasks = null
        localDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        
        val expectedTasks = networkTasks.toExternal()

        val newTasks = tasksRepository.getTasks(true)

        assertEquals(expectedTasks, newTasks)
        assertEquals(expectedTasks, localDataSource.tasks?.toExternal())
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        localDataSource = FakeTaskDao(mutableListOf(task1.toLocal()))
        val initial = tasksRepository.getTask(task1.id)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        networkDataSource.tasks = mutableListOf(task1.toNetwork())
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        networkDataSource.tasks = mutableListOf(task2.toNetwork())

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        localDataSource.tasks = listOf(completedTask.toLocal(), task2.toLocal())
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.annotation.VisibleForTesting
import java.util.UUID
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeTaskRepository : TaskRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refresh() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refresh()
    }

    override suspend fun createTask(title: String, description: String): String {
        val taskId = generateTaskId()
        Task(title = title, description = description, id = taskId).also {
            saveTask(it)
        }
        return taskId
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val updatedTask = _savedTasks.value[taskId]?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        saveTask(updatedTask)
    }

    private fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    private fun generateTaskId() = UUID.randomUUID().toString()

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import kotlinx.coroutines.flow.Flow


interface TaskRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun createTask(title: String, description: String): String

    suspend fun updateTask(taskId: String, title: String, description: String)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.TaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import java.util.UUID
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext


class DefaultTaskRepository(
    private val tasksNetworkDataSource: NetworkDataSource,
    private val taskDao: TaskDao,
    private val coroutineDispatcher: CoroutineDispatcher = Dispatchers.Default
) : TaskRepository {

    override suspend fun createTask(title: String, description: String): String {
        
        
        val taskId = withContext(coroutineDispatcher) {
            UUID.randomUUID().toString()
        }
        val task = Task(
            title = title,
            description = description,
            id = taskId,
        )
        taskDao.upsert(task.toLocal())
        saveTasksToNetwork()
        return taskId
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val task = getTask(taskId)?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        taskDao.upsert(task.toLocal())
        saveTasksToNetwork()
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            loadTasksFromNetwork()
        }
        return withContext(coroutineDispatcher) {
            taskDao.getAll().toExternal()
        }
    }

    override suspend fun refreshTasks() {
        loadTasksFromNetwork()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return taskDao.observeAll().map { tasks ->
            withContext(coroutineDispatcher) {
                tasks.toExternal()
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        loadTasksFromNetwork()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return taskDao.observeById(taskId).map { it.toExternal() }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            loadTasksFromNetwork()
        }
        return taskDao.getById(taskId)?.toExternal()
    }

    override suspend fun completeTask(taskId: String) {
        taskDao.updateCompleted(taskId = taskId, completed = true)
        saveTasksToNetwork()
    }

    override suspend fun activateTask(taskId: String) {
        taskDao.updateCompleted(taskId = taskId, completed = false)
        saveTasksToNetwork()
    }

    override suspend fun clearCompletedTasks() {
        taskDao.deleteCompleted()
        saveTasksToNetwork()
    }

    override suspend fun deleteAllTasks() {
        taskDao.deleteAll()
        saveTasksToNetwork()
    }

    override suspend fun deleteTask(taskId: String) {
        taskDao.deleteById(taskId)
        saveTasksToNetwork()
    }

    
    private suspend fun loadTasksFromNetwork() {
        withContext(coroutineDispatcher) {
            val remoteTasks = tasksNetworkDataSource.loadTasks()
            taskDao.deleteAll()
            taskDao.upsertAll(remoteTasks.toLocal())
        }
    }

    private suspend fun saveTasksToNetwork() {
        withContext(coroutineDispatcher) {
            val localTasks = taskDao.getAll()
            tasksNetworkDataSource.saveTasks(localTasks.toNetwork())
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network

import kotlinx.coroutines.delay


object TaskNetworkDataSource : NetworkDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASK_SERVICE_DATA = LinkedHashMap<String, NetworkTask>(2)

    init {
        addTask(
            id = "PISA",
            title = "Build tower in Pisa",
            shortDescription = "Ground looks good, no foundation work required."
        )
        addTask(
            id = "TACOMA",
            title = "Finish bridge in Tacoma",
            shortDescription = "Found awesome girders at half the cost!"
        )
    }

    override suspend fun loadTasks(): List<NetworkTask> {
        
        val tasks = TASK_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun saveTasks(tasks: List<NetworkTask>) {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        TASK_SERVICE_DATA.clear()
        TASK_SERVICE_DATA.putAll(tasks.associateBy(NetworkTask::id))
    }

    private fun addTask(id: String, title: String, shortDescription: String) {
        val newTask = NetworkTask(id = id, title = title, shortDescription = shortDescription)
        TASK_SERVICE_DATA[newTask.id] = newTask
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.DefaultTaskRepository
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.network.TaskNetworkDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class NetworkTaskDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTaskRepository(
        @NetworkTaskDataSource remoteDataSource: NetworkDataSource,
        database: ToDoDatabase,
    ): TaskRepository {
        return DefaultTaskRepository(remoteDataSource, database.taskDao())
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @NetworkTaskDataSource
    @Provides
    fun provideTaskRemoteDataSource(): NetworkDataSource = TaskNetworkDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class IoDispatcher

@Module
@InstallIn(SingletonComponent::class)
object CoroutinesModule {

    @Provides
    @IoDispatcher
    fun providesIODispatcher(): CoroutineDispatcher = Dispatchers.IO
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val taskRepository: TaskRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        taskRepository.getTasksStream()
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            taskRepository.refreshTasks()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<List<Task>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Error -> {
                
                StatisticsUiState(isEmpty = true, isLoading = false)
            }
            is Async.Success -> {
                val stats = getActiveAndCompletedStats(taskLoad.data)
                StatisticsUiState(
                    isEmpty = taskLoad.data.isEmpty(),
                    activeTasksPercent = stats.activeTasksPercent,
                    completedTasksPercent = stats.completedTasksPercent,
                    isLoading = false
                )
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TaskRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val taskRepository: TaskRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(taskRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            taskRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            taskRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            taskRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            taskRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.source.local.FakeTaskDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.FakeNetworkDataSource
import com.google.common.truth.Truth.assertThat
import junit.framework.TestCase.assertEquals
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTaskRepositoryTest {

    private val task1 = Task(id = "1", title = "Title1", description = "Description1")
    private val task2 = Task(id = "2", title = "Title2", description = "Description2")
    private val task3 = Task(id = "3", title = "Title3", description = "Description3")

    private val newTaskTitle = "Title new"
    private val newTaskDescription = "Description new"
    private val newTask = Task(id = "new", title = newTaskTitle, description = newTaskDescription)
    private val newTasks = listOf(newTask)

    private val networkTasks = listOf(task1, task2).toNetwork()
    private val localTasks = listOf(task3.toLocal())

    private lateinit var networkDataSource: FakeNetworkDataSource
    private lateinit var localDataSource: FakeTaskDao

    
    private lateinit var tasksRepository: DefaultTaskRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        networkDataSource = FakeNetworkDataSource(networkTasks.toMutableList())
        localDataSource = FakeTaskDao(localTasks)
        
        tasksRepository = DefaultTaskRepository(
            networkDataSource, localDataSource
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptyRemoteSource = FakeNetworkDataSource()
        val emptyLocalSource = FakeTaskDao()

        val tasksRepository = DefaultTaskRepository(
            emptyRemoteSource, emptyLocalSource
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(networkTasks.toExternal())
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(networkDataSource.tasks?.map { it.id }?.contains(newTaskId))
        assertThat(localDataSource.tasks?.map { it.id }?.contains(newTaskId))
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        networkDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            networkDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks.toExternal())
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        networkDataSource.tasks = null
        localDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        
        val expectedTasks = networkTasks.toExternal()

        val newTasks = tasksRepository.getTasks(true)

        assertEquals(expectedTasks, newTasks)
        assertEquals(expectedTasks, localDataSource.tasks?.toExternal())
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTaskId = tasksRepository.createTask(newTask.title, newTask.description)
        tasksRepository.completeTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTaskId)

        
        assertThat(tasksRepository.getTask(newTaskId)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        localDataSource = FakeTaskDao(mutableListOf(task1.toLocal()))
        val initial = tasksRepository.getTask(task1.id)

        
        networkDataSource.tasks = newTasks.toNetwork().toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        networkDataSource.tasks = mutableListOf(task1.toNetwork())
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        networkDataSource.tasks = mutableListOf(task2.toNetwork())

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        localDataSource.tasks = listOf(completedTask.toLocal(), task2.toLocal())
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.annotation.VisibleForTesting
import java.util.UUID
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeTaskRepository : TaskRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override suspend fun createTask(title: String, description: String): String {
        val taskId = generateTaskId()
        Task(title = title, description = description, id = taskId).also {
            saveTask(it)
        }
        return taskId
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val updatedTask = _savedTasks.value[taskId]?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        saveTask(updatedTask)
    }

    private fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    private fun generateTaskId() = UUID.randomUUID().toString()

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID


@Entity(tableName = "tasks")
data class Task @JvmOverloads constructor(
    @ColumnInfo(name = "title") val title: String = "",
    @ColumnInfo(name = "description") val description: String = "",
    @ColumnInfo(name = "completed") val isCompleted: Boolean = false,
    @PrimaryKey @ColumnInfo(name = "entryid") val id: String = UUID.randomUUID().toString()
) {

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description

    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() || description.isEmpty()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksDataSource {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
) : TasksRepository {

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            updateTasksFromRemoteDataSource()
        }
        return tasksLocalDataSource.getTasks()
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return tasksLocalDataSource.getTasksStream()
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksRemoteDataSource.getTasks()

        
        tasksLocalDataSource.deleteAllTasks()
        remoteTasks.forEach { task ->
            tasksLocalDataSource.saveTask(task)
        }
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return tasksLocalDataSource.getTaskStream(taskId)
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksRemoteDataSource.getTask(taskId)

        if (remoteTask == null) {
            tasksLocalDataSource.deleteTask(taskId)
        } else {
            tasksLocalDataSource.saveTask(remoteTask)
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksLocalDataSource.getTask(taskId)
    }

    override suspend fun saveTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.saveTask(task) }
            launch { tasksLocalDataSource.saveTask(task) }
        }
    }

    override suspend fun completeTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.completeTask(taskId) }
            launch { tasksLocalDataSource.completeTask(taskId) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.activateTask(taskId) }
            launch { tasksLocalDataSource.activateTask(taskId) }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteAllTasks() }
            launch { tasksLocalDataSource.deleteAllTasks() }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource


class TasksLocalDataSource internal constructor(
    private val tasksDao: TasksDao
) : TasksDataSource {

    override fun getTasksStream() = tasksDao.observeTasks()

    override fun getTaskStream(taskId: String) = tasksDao.observeTaskById(taskId)

    override suspend fun refreshTask(taskId: String) {
        
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun getTasks(): List<Task> = tasksDao.getTasks()

    override suspend fun getTask(taskId: String): Task? = tasksDao.getTaskById(taskId)

    override suspend fun saveTask(task: Task) = tasksDao.insertTask(task)

    override suspend fun completeTask(taskId: String) =
        tasksDao.updateCompleted(taskId, true)

    override suspend fun activateTask(taskId: String) =
        tasksDao.updateCompleted(taskId, false)

    override suspend fun clearCompletedTasks() {
        tasksDao.deleteCompletedTasks()
    }

    override suspend fun deleteAllTasks() = tasksDao.deleteTasks()

    override suspend fun deleteTask(taskId: String) {
        tasksDao.deleteTaskById(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking


object TasksRemoteDataSource : TasksDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, Task>(2)

    init {
        addTask("Build tower in Pisa", "Ground looks good, no foundation work required.")
        addTask("Finish bridge in Tacoma", "Found awesome girders at half the cost!")
    }

    private val observableTasks = MutableStateFlow(runBlocking { getTasks() })

    override suspend fun refreshTasks() {
        observableTasks.value = getTasks()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return observableTasks
    }

    override suspend fun getTasks(): List<Task> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun getTask(taskId: String): Task? {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        return TASKS_SERVICE_DATA[taskId]
    }

    private fun addTask(title: String, description: String) {
        val newTask = Task(title, description)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class RemoteTasksDataSource

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class LocalTasksDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTasksRepository(
        @RemoteTasksDataSource remoteDataSource: TasksDataSource,
        @LocalTasksDataSource localDataSource: TasksDataSource,
    ): TasksRepository {
        return DefaultTasksRepository(remoteDataSource, localDataSource)
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @RemoteTasksDataSource
    @Provides
    fun provideTasksRemoteDataSource(): TasksDataSource = TasksRemoteDataSource

    @Singleton
    @LocalTasksDataSource
    @Provides
    fun provideTasksLocalDataSource(
        database: ToDoDatabase
    ): TasksDataSource {
        return TasksLocalDataSource(database.taskDao())
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(tasksRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TaskDetailUiState(
    val task: Task? = null,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskDeleted: Boolean = false
)


@HiltViewModel
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    val taskId: String = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]!!

    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _isTaskDeleted = MutableStateFlow(false)
    private val _taskAsync = tasksRepository.getTaskStream(taskId)
        .map { handleTask(it) }
        .catch { emit(Async.Error(R.string.loading_task_error)) }

    val uiState: StateFlow<TaskDetailUiState> = combine(
        _userMessage, _isLoading, _isTaskDeleted, _taskAsync
    ) { userMessage, isLoading, isTaskDeleted, taskAsync ->
        when (taskAsync) {
            Async.Loading -> {
                TaskDetailUiState(isLoading = true)
            }
            is Async.Error -> {
                TaskDetailUiState(
                    userMessage = taskAsync.errorMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
            is Async.Success -> {
                TaskDetailUiState(
                    task = taskAsync.data,
                    isLoading = isLoading,
                    userMessage = userMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TaskDetailUiState(isLoading = true)
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted.value = true
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = uiState.value.task ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTask(taskId)
            _isLoading.value = false
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    private fun handleTask(task: Task?): Async<Task?> {
        if (task == null) {
            return Async.Error(R.string.task_not_found)
        }
        return Async.Success(task)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

object FakeFailingTasksRemoteDataSource : TasksDataSource {
    override suspend fun getTasks(): List<Task> {
        throw Exception("Test")
    }

    override suspend fun getTask(taskId: String): Task? {
        throw Exception("Test")
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return flow { emit(getTasks()) }
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return flow { emit(getTask(taskId)) }
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun saveTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun activateTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun clearCompletedTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteAllTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task("Title1", "Description1")
    private val task2 = Task("Title2", "Description2")
    private val task3 = Task("Title3", "Description3")
    private val newTask = Task("Title new", "Description new")
    private val remoteTasks = listOf(task1, task2).sortedBy { it.id }
    private val localTasks = listOf(task3).sortedBy { it.id }
    private val newTasks = listOf(newTask).sortedBy { it.id }
    private lateinit var tasksRemoteDataSource: FakeDataSource
    private lateinit var tasksLocalDataSource: FakeDataSource

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksRemoteDataSource = FakeDataSource(remoteTasks.toMutableList())
        tasksLocalDataSource = FakeDataSource(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksRemoteDataSource, tasksLocalDataSource
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptySource = FakeDataSource()
        val tasksRepository = DefaultTasksRepository(
            emptySource, emptySource
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(remoteTasks)
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksRemoteDataSource.tasks).doesNotContain(newTask)
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask)

        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRemoteDataSource.tasks).contains(newTask)
        assertThat(tasksLocalDataSource.tasks).contains(newTask)
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        tasksRemoteDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksRemoteDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks)
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        tasksRemoteDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = tasksRepository.getTasks(true)

        assertThat(newTasks).isEqualTo(remoteTasks)
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks)
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksLocalDataSource.tasks = mutableListOf(task1)
        val initial = tasksRepository.getTask(task1.id)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksRemoteDataSource.tasks = mutableListOf(task1)
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        tasksRemoteDataSource.tasks = mutableListOf(task2)

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        tasksRemoteDataSource.tasks = mutableListOf(completedTask, task2)
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow

class FakeDataSource(var tasks: MutableList<Task>? = mutableListOf()) : TasksDataSource {
    override suspend fun getTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTask(taskId: String) = tasks?.firstOrNull { it.id == taskId }

    override suspend fun saveTask(task: Task) {
        tasks?.add(task)
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.isCompleted }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }

    override fun getTasksStream(): Flow<List<Task>> {
        TODO("not implemented")
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task> {
        TODO("not implemented")
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() = runTest {
        val uiState = taskDetailViewModel.uiState.first()
        
        assertThat(uiState.task?.title).isEqualTo(task.title)
        assertThat(uiState.task?.description).isEqualTo(task.description)
    }

    @Test
    fun completeTask() = runTest {
        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isFalse()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask() = runTest {
        tasksRepository.deleteAllTasks()
        tasksRepository.addTasks(task.copy(isCompleted = true))

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(false)

        
        val newTask = tasksRepository.getTask(task.id)
        assertTrue((newTask?.isActive) ?: false)
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }

    @Test
    fun taskDetailViewModel_repositoryError() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_task_error)
    }

    @Test
    fun taskDetailViewModel_taskNotFound() = runTest {
        
        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "nonexistent_id"))
        )

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_not_found)
    }

    @Test
    fun deleteTask() = runTest {
        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isTrue()

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            taskDetailViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeRepository : TasksRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.nullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@MediumTest
class TasksLocalDataSourceTest {

    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            ToDoDatabase::class.java
        )
            .allowMainThreadQueries()
            .build()

        localDataSource = TasksLocalDataSource(database.taskDao())
    }

    @After
    fun cleanUp() {
        database.close()
    }

    @Test
    fun saveTask_retrievesTask() = runTest {
        
        val newTask = Task("title", "description", true)
        localDataSource.saveTask(newTask)

        
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`("title"))
        assertThat(task?.description, `is`("description"))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun completeTask_retrievedTaskIsComplete() = runTest {
        
        val newTask = Task("title")
        localDataSource.saveTask(newTask)

        
        localDataSource.completeTask(newTask.id)
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`(newTask.title))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun activateTask_retrievedTaskIsActive() = runTest {
        
        val newTask = Task("Some title", "Some description", true)
        localDataSource.saveTask(newTask)

        localDataSource.activateTask(newTask.id)

        
        val task = localDataSource.getTask(newTask.id)

        assertThat(task?.title, `is`("Some title"))
        assertThat(task?.isCompleted, `is`(false))
    }

    @Test
    fun clearCompletedTask_taskNotRetrievable() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title2")
        val newTask3 = Task("title3")
        localDataSource.saveTask(newTask1)
        localDataSource.completeTask(newTask1.id)
        localDataSource.saveTask(newTask2)
        localDataSource.completeTask(newTask2.id)
        localDataSource.saveTask(newTask3)
        
        localDataSource.clearCompletedTasks()

        
        assertThat(localDataSource.getTask(newTask1.id), `is`(nullValue()))
        assertThat(localDataSource.getTask(newTask2.id), `is`(nullValue()))

        val result3 = localDataSource.getTask(newTask3.id)
        assertThat(result3, `is`(newTask3))
    }

    @Test
    fun deleteAllTasks_emptyListOfRetrievedTask() = runTest {
        
        val newTask = Task("title")

        localDataSource.saveTask(newTask)

        
        localDataSource.deleteAllTasks()

        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun getTasks_retrieveSavedTasks() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title")

        localDataSource.saveTask(newTask1)
        localDataSource.saveTask(newTask2)
        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.size, `is`(2))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID


@Entity(tableName = "tasks")
data class Task @JvmOverloads constructor(
    @ColumnInfo(name = "title") var title: String = "",
    @ColumnInfo(name = "description") var description: String = "",
    @ColumnInfo(name = "completed") var isCompleted: Boolean = false,
    @PrimaryKey @ColumnInfo(name = "entryid") var id: String = UUID.randomUUID().toString()
) {

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description

    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() || description.isEmpty()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(task: Task)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksDataSource {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(task: Task)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksRepository {

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            updateTasksFromRemoteDataSource()
        }
        return tasksLocalDataSource.getTasks()
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return tasksLocalDataSource.getTasksStream()
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksRemoteDataSource.getTasks()

        
        tasksLocalDataSource.deleteAllTasks()
        remoteTasks.forEach { task ->
            tasksLocalDataSource.saveTask(task)
        }
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return tasksLocalDataSource.getTaskStream(taskId)
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksRemoteDataSource.getTask(taskId)

        if (remoteTask == null) {
            tasksLocalDataSource.deleteTask(taskId)
        } else {
            tasksLocalDataSource.saveTask(remoteTask)
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksLocalDataSource.getTask(taskId)
    }

    override suspend fun saveTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.saveTask(task) }
            launch { tasksLocalDataSource.saveTask(task) }
        }
    }

    override suspend fun completeTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.completeTask(task) }
            launch { tasksLocalDataSource.completeTask(task) }
        }
    }

    override suspend fun completeTask(taskId: String) {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let { completeTask(it) }
        }
    }

    override suspend fun activateTask(task: Task) = withContext<Unit>(ioDispatcher) {
        coroutineScope {
            launch { tasksRemoteDataSource.activateTask(task) }
            launch { tasksLocalDataSource.activateTask(task) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let { activateTask(it) }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        withContext(ioDispatcher) {
            coroutineScope {
                launch { tasksRemoteDataSource.deleteAllTasks() }
                launch { tasksLocalDataSource.deleteAllTasks() }
            }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }
    }

    private suspend fun getTaskWithId(id: String): Task? {
        return tasksLocalDataSource.getTask(id)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext


class TasksLocalDataSource internal constructor(
    private val tasksDao: TasksDao,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksDataSource {

    override fun getTasksStream() = tasksDao.observeTasks()

    override fun getTaskStream(taskId: String) = tasksDao.observeTaskById(taskId)

    override suspend fun refreshTask(taskId: String) {
        
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun getTasks(): List<Task> = withContext(ioDispatcher) {
        return@withContext tasksDao.getTasks()
    }

    override suspend fun getTask(taskId: String): Task? = withContext(ioDispatcher) {
        return@withContext tasksDao.getTaskById(taskId)
    }

    override suspend fun saveTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.insertTask(task)
    }

    override suspend fun completeTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.updateCompleted(task.id, true)
    }

    override suspend fun completeTask(taskId: String) {
        tasksDao.updateCompleted(taskId, true)
    }

    override suspend fun activateTask(task: Task) = withContext(ioDispatcher) {
        tasksDao.updateCompleted(task.id, false)
    }

    override suspend fun activateTask(taskId: String) {
        tasksDao.updateCompleted(taskId, false)
    }

    override suspend fun clearCompletedTasks() = withContext<Unit>(ioDispatcher) {
        tasksDao.deleteCompletedTasks()
    }

    override suspend fun deleteAllTasks() = withContext(ioDispatcher) {
        tasksDao.deleteTasks()
    }

    override suspend fun deleteTask(taskId: String) = withContext<Unit>(ioDispatcher) {
        tasksDao.deleteTaskById(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking


object TasksRemoteDataSource : TasksDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, Task>(2)

    init {
        addTask("Build tower in Pisa", "Ground looks good, no foundation work required.")
        addTask("Finish bridge in Tacoma", "Found awesome girders at half the cost!")
    }

    private val observableTasks = MutableStateFlow(runBlocking { getTasks() })

    override suspend fun refreshTasks() {
        observableTasks.value = getTasks()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return observableTasks
    }

    override suspend fun getTasks(): List<Task> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun getTask(taskId: String): Task? {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        return TASKS_SERVICE_DATA[taskId]
    }

    private fun addTask(title: String, description: String) {
        val newTask = Task(title, description)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        TASKS_SERVICE_DATA[task.id] = completedTask
    }

    override suspend fun completeTask(taskId: String) {
        
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        TASKS_SERVICE_DATA[task.id] = activeTask
    }

    override suspend fun activateTask(taskId: String) {
        
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineDispatcher

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class RemoteTasksDataSource

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class LocalTasksDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTasksRepository(
        @RemoteTasksDataSource remoteDataSource: TasksDataSource,
        @LocalTasksDataSource localDataSource: TasksDataSource,
        @IoDispatcher ioDispatcher: CoroutineDispatcher
    ): TasksRepository {
        return DefaultTasksRepository(remoteDataSource, localDataSource, ioDispatcher)
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @RemoteTasksDataSource
    @Provides
    fun provideTasksRemoteDataSource(): TasksDataSource = TasksRemoteDataSource

    @Singleton
    @LocalTasksDataSource
    @Provides
    fun provideTasksLocalDataSource(
        database: ToDoDatabase,
        @IoDispatcher ioDispatcher: CoroutineDispatcher
    ): TasksDataSource {
        return TasksLocalDataSource(database.taskDao(), ioDispatcher)
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(tasksRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TaskDetailUiState(
    val task: Task? = null,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskDeleted: Boolean = false
)


@HiltViewModel
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    val taskId: String = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]!!

    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _isTaskDeleted = MutableStateFlow(false)
    private val _taskAsync = tasksRepository.getTaskStream(taskId)
        .map { handleTask(it) }
        .catch { emit(Async.Error(R.string.loading_task_error)) }

    val uiState: StateFlow<TaskDetailUiState> = combine(
        _userMessage, _isLoading, _isTaskDeleted, _taskAsync
    ) { userMessage, isLoading, isTaskDeleted, taskAsync ->
        when (taskAsync) {
            Async.Loading -> {
                TaskDetailUiState(isLoading = true)
            }
            is Async.Error -> {
                TaskDetailUiState(
                    userMessage = taskAsync.errorMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
            is Async.Success -> {
                TaskDetailUiState(
                    task = taskAsync.data,
                    isLoading = isLoading,
                    userMessage = userMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TaskDetailUiState(isLoading = true)
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted.value = true
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = uiState.value.task ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTask(taskId)
            _isLoading.value = false
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    private fun handleTask(task: Task?): Async<Task?> {
        if (task == null) {
            return Async.Error(R.string.task_not_found)
        }
        return Async.Success(task)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

object FakeFailingTasksRemoteDataSource : TasksDataSource {
    override suspend fun getTasks(): List<Task> {
        throw Exception("Test")
    }

    override suspend fun getTask(taskId: String): Task? {
        throw Exception("Test")
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return flow { emit(getTasks()) }
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return flow { emit(getTask(taskId)) }
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun saveTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun activateTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun activateTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun clearCompletedTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteAllTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task("Title1", "Description1")
    private val task2 = Task("Title2", "Description2")
    private val task3 = Task("Title3", "Description3")
    private val newTask = Task("Title new", "Description new")
    private val remoteTasks = listOf(task1, task2).sortedBy { it.id }
    private val localTasks = listOf(task3).sortedBy { it.id }
    private val newTasks = listOf(newTask).sortedBy { it.id }
    private lateinit var tasksRemoteDataSource: FakeDataSource
    private lateinit var tasksLocalDataSource: FakeDataSource

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksRemoteDataSource = FakeDataSource(remoteTasks.toMutableList())
        tasksLocalDataSource = FakeDataSource(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksRemoteDataSource, tasksLocalDataSource, Dispatchers.Main
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptySource = FakeDataSource()
        val tasksRepository = DefaultTasksRepository(
            emptySource, emptySource, Dispatchers.Main
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(remoteTasks)
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksRemoteDataSource.tasks).doesNotContain(newTask)
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask)

        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRemoteDataSource.tasks).contains(newTask)
        assertThat(tasksLocalDataSource.tasks).contains(newTask)
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        tasksRemoteDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksRemoteDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks)
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        tasksRemoteDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = tasksRepository.getTasks(true)

        assertThat(newTasks).isEqualTo(remoteTasks)
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks)
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksLocalDataSource.tasks = mutableListOf(task1)
        val initial = tasksRepository.getTask(task1.id)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksRemoteDataSource.tasks = mutableListOf(task1)
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        tasksRemoteDataSource.tasks = mutableListOf(task2)

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy().apply { isCompleted = true }
        tasksRemoteDataSource.tasks = mutableListOf(completedTask, task2)
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow

class FakeDataSource(var tasks: MutableList<Task>? = mutableListOf()) : TasksDataSource {
    override suspend fun getTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTask(taskId: String) = tasks?.firstOrNull { it.id == taskId }

    override suspend fun saveTask(task: Task) {
        tasks?.add(task)
    }

    override suspend fun completeTask(task: Task) {
        tasks?.firstOrNull { it.id == task.id }?.let { it.isCompleted = true }
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = true }
    }

    override suspend fun activateTask(task: Task) {
        tasks?.firstOrNull { it.id == task.id }?.let { it.isCompleted = false }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = false }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.isCompleted }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }

    override fun getTasksStream(): Flow<List<Task>> {
        TODO("not implemented")
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task> {
        TODO("not implemented")
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() = runTest {
        val uiState = taskDetailViewModel.uiState.first()
        
        assertThat(uiState.task?.title).isEqualTo(task.title)
        assertThat(uiState.task?.description).isEqualTo(task.description)
    }

    @Test
    fun completeTask() = runTest {
        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isFalse()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask() = runTest {
        task.isCompleted = true

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(false)

        
        val newTask = tasksRepository.getTask(task.id)
        assertTrue((newTask?.isActive) ?: false)
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }

    @Test
    fun taskDetailViewModel_repositoryError() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_task_error)
    }

    @Test
    fun taskDetailViewModel_taskNotFound() = runTest {
        
        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "nonexistent_id"))
        )

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_not_found)
    }

    @Test
    fun deleteTask() = runTest {
        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isTrue()

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            taskDetailViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeRepository : TasksRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = completedTask
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        
        throw NotImplementedError()
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = activeTask
            newTasks
        }
    }

    override suspend fun activateTask(taskId: String) {
        throw NotImplementedError()
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.nullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@MediumTest
class TasksLocalDataSourceTest {

    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            ToDoDatabase::class.java
        )
            .allowMainThreadQueries()
            .build()

        localDataSource = TasksLocalDataSource(database.taskDao(), Dispatchers.Main)
    }

    @After
    fun cleanUp() {
        database.close()
    }

    @Test
    fun saveTask_retrievesTask() = runTest {
        
        val newTask = Task("title", "description", true)
        localDataSource.saveTask(newTask)

        
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`("title"))
        assertThat(task?.description, `is`("description"))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun completeTask_retrievedTaskIsComplete() = runTest {
        
        val newTask = Task("title")
        localDataSource.saveTask(newTask)

        
        localDataSource.completeTask(newTask)
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`(newTask.title))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun activateTask_retrievedTaskIsActive() = runTest {
        
        val newTask = Task("Some title", "Some description", true)
        localDataSource.saveTask(newTask)

        localDataSource.activateTask(newTask)

        
        val task = localDataSource.getTask(newTask.id)

        assertThat(task?.title, `is`("Some title"))
        assertThat(task?.isCompleted, `is`(false))
    }

    @Test
    fun clearCompletedTask_taskNotRetrievable() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title2")
        val newTask3 = Task("title3")
        localDataSource.saveTask(newTask1)
        localDataSource.completeTask(newTask1)
        localDataSource.saveTask(newTask2)
        localDataSource.completeTask(newTask2)
        localDataSource.saveTask(newTask3)
        
        localDataSource.clearCompletedTasks()

        
        assertThat(localDataSource.getTask(newTask1.id), `is`(nullValue()))
        assertThat(localDataSource.getTask(newTask2.id), `is`(nullValue()))

        val result3 = localDataSource.getTask(newTask3.id)
        assertThat(result3, `is`(newTask3))
    }

    @Test
    fun deleteAllTasks_emptyListOfRetrievedTask() = runTest {
        
        val newTask = Task("title")

        localDataSource.saveTask(newTask)

        
        localDataSource.deleteAllTasks()

        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun getTasks_retrieveSavedTasks() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title")

        localDataSource.saveTask(newTask1)
        localDataSource.saveTask(newTask2)
        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.size, `is`(2))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import java.util.UUID


data class Task internal constructor(
    val title: String = "",
    val description: String = "",
    val isCompleted: Boolean = false,
    val id: String = UUID.randomUUID().toString()
) {

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description

    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() || description.isEmpty()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.LocalTask
import com.example.android.architecture.blueprints.todoapp.data.source.remote.NetworkTask
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TaskStatus




fun Task.toLocalModel() = LocalTask(
    id = id,
    title = title,
    description = description,
    isCompleted = isCompleted,
)

fun List<Task>.toLocalModels() = map(Task::toLocalModel)


fun LocalTask.toExternalModel() = Task(
    id = id,
    title = title,
    description = description,
    isCompleted = isCompleted,
)




@JvmName("taskEntitiesToExternalModels")
fun List<LocalTask>.toExternalModels() = map(LocalTask::toExternalModel)


fun NetworkTask.toTaskEntity() = LocalTask(
    id = id,
    title = title,
    description = shortDescription,
    isCompleted = (status == TaskStatus.COMPLETE),
)

@JvmName("networkTasksToTaskEntities")
fun List<NetworkTask>.toTaskEntities() = map(NetworkTask::toTaskEntity)


fun LocalTask.toNetworkModel() = NetworkTask(
    id = id,
    title = title,
    shortDescription = description,
    status = if (isCompleted) { TaskStatus.COMPLETE } else { TaskStatus.ACTIVE }
)


fun Task.toNetworkModel() = toLocalModel().toNetworkModel()

@JvmName("tasksToNetworkTasks")
fun List<Task>.toNetworkModels() = map(Task::toNetworkModel)


fun NetworkTask.toExternalModel() = toTaskEntity().toExternalModel()

@JvmName("networkTasksToTasks")
fun List<NetworkTask>.toExternalModels() = map(NetworkTask::toExternalModel)

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun createTask(title: String, description: String): Task

    suspend fun updateTask(taskId: String, title: String, description: String)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.source.remote.NetworkTask


interface NetworkDataSource {

    suspend fun loadTasks(): List<NetworkTask>

    suspend fun getTask(taskId: String): NetworkTask?

    suspend fun saveTask(task: NetworkTask)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksDao
import com.example.android.architecture.blueprints.todoapp.data.toExternalModel
import com.example.android.architecture.blueprints.todoapp.data.toLocalModel
import com.example.android.architecture.blueprints.todoapp.data.toNetworkModel
import com.example.android.architecture.blueprints.todoapp.data.toTaskEntity
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch


class DefaultTasksRepository(
    private val tasksNetworkDataSource: NetworkDataSource,
    private val tasksDao: TasksDao,
) : TasksRepository {

    override suspend fun createTask(title: String, description: String): Task {
        val task = Task(title = title, description = description)

        coroutineScope {
            launch { tasksNetworkDataSource.saveTask(task.toNetworkModel()) }
            launch {
                tasksDao.insertTask(task.toLocalModel())
            }
        }
        return task
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {

        val task = getTask(taskId)?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        coroutineScope {
            launch { tasksNetworkDataSource.saveTask(task.toNetworkModel()) }
            launch {
                tasksDao.insertTask(task.toLocalModel())
            }
        }
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            updateTasksFromRemoteDataSource()
        }
        return tasksDao.getTasks().map { it.toExternalModel() }
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return tasksDao.observeTasks().map { tasks ->
            tasks.map { task ->
                task.toExternalModel()
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksNetworkDataSource.loadTasks()

        
        tasksDao.deleteTasks()
        remoteTasks.forEach { task ->
            tasksDao.insertTask(task.toTaskEntity())
        }
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return tasksDao.observeTaskById(taskId).map { it.toExternalModel() }
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksNetworkDataSource.getTask(taskId)

        if (remoteTask == null) {
            tasksDao.deleteTaskById(taskId)
        } else {
            tasksDao.insertTask(
                remoteTask.toTaskEntity()
            )
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksDao.getTaskById(taskId)?.toExternalModel()
    }

    override suspend fun completeTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.completeTask(taskId) }
            launch { tasksDao.updateCompleted(taskId = taskId, completed = true) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.activateTask(taskId) }
            launch { tasksDao.updateCompleted(taskId = taskId, completed = false) }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksNetworkDataSource.clearCompletedTasks() }
            launch { tasksDao.deleteCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        coroutineScope {
            launch { tasksNetworkDataSource.deleteAllTasks() }
            launch { tasksDao.deleteTasks() }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.deleteTask(taskId) }
            launch { tasksDao.deleteTaskById(taskId) }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Database
import androidx.room.RoomDatabase


@Database(entities = [LocalTask::class], version = 1, exportSchema = false)
abstract class ToDoDatabase : RoomDatabase() {

    abstract fun taskDao(): TasksDao
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey


@Entity(
    tableName = "tasks"
)
data class LocalTask(
    @PrimaryKey @ColumnInfo(name = "entryid") val id: String,
    var title: String = "",
    var description: String = "",
    @ColumnInfo(name = "completed") var isCompleted: Boolean = false,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow


@Dao
interface TasksDao {

    
    @Query("SELECT * FROM Tasks")
    fun observeTasks(): Flow<List<LocalTask>>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    fun observeTaskById(taskId: String): Flow<LocalTask>

    
    @Query("SELECT * FROM Tasks")
    suspend fun getTasks(): List<LocalTask>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    suspend fun getTaskById(taskId: String): LocalTask?

    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTask(task: LocalTask)

    
    @Update
    suspend fun updateTask(task: LocalTask): Int

    
    @Query("UPDATE tasks SET completed = :completed WHERE entryid = :taskId")
    suspend fun updateCompleted(taskId: String, completed: Boolean)

    
    @Query("DELETE FROM Tasks WHERE entryid = :taskId")
    suspend fun deleteTaskById(taskId: String): Int

    
    @Query("DELETE FROM Tasks")
    suspend fun deleteTasks()

    
    @Query("DELETE FROM Tasks WHERE completed = 1")
    suspend fun deleteCompletedTasks(): Int
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.source.NetworkDataSource
import kotlinx.coroutines.delay


object TasksNetworkDataSource : NetworkDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, NetworkTask>(2)

    init {
        addTask(
            id = "PISA",
            title = "Build tower in Pisa",
            shortDescription = "Ground looks good, no foundation work required."
        )
        addTask(
            id = "TACOMA",
            title = "Finish bridge in Tacoma",
            shortDescription = "Found awesome girders at half the cost!"
        )
    }

    override suspend fun loadTasks(): List<NetworkTask> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun getTask(taskId: String): NetworkTask? {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        return TASKS_SERVICE_DATA[taskId]
    }

    private fun addTask(id: String, title: String, shortDescription: String) {
        val newTask = NetworkTask(id = id, title = title, shortDescription = shortDescription)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: NetworkTask) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(status = TaskStatus.COMPLETE))
        }
    }

    override suspend fun activateTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(status = TaskStatus.ACTIVE))
        }
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            it.status == TaskStatus.COMPLETE
        } as LinkedHashMap<String, NetworkTask>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote


data class NetworkTask(
    val id: String,
    val title: String,
    val shortDescription: String,
    val priority: Int? = null,
    val status: TaskStatus = TaskStatus.ACTIVE
)

enum class TaskStatus {
    ACTIVE,
    COMPLETE
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksNetworkDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class RemoteTasksDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTasksRepository(
        @RemoteTasksDataSource remoteDataSource: NetworkDataSource,
        database: ToDoDatabase,
    ): TasksRepository {
        return DefaultTasksRepository(remoteDataSource, database.taskDao())
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @RemoteTasksDataSource
    @Provides
    fun provideTasksRemoteDataSource(): NetworkDataSource = TasksNetworkDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch


data class AddEditTaskUiState(
    val title: String = "",
    val description: String = "",
    val isTaskCompleted: Boolean = false,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskSaved: Boolean = false
)


@HiltViewModel
class AddEditTaskViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val taskId: String? = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]

    
    
    
    private val _uiState = MutableStateFlow(AddEditTaskUiState())
    val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

    init {
        if (taskId != null) {
            loadTask(taskId)
        }
    }

    
    fun saveTask() {
        if (uiState.value.title.isEmpty() || uiState.value.description.isEmpty()) {
            _uiState.update {
                it.copy(userMessage = R.string.empty_task_message)
            }
            return
        }

        if (taskId == null) {
            createNewTask()
        } else {
            updateTask()
        }
    }

    fun snackbarMessageShown() {
        _uiState.update {
            it.copy(userMessage = null)
        }
    }

    fun updateTitle(newTitle: String) {
        _uiState.update {
            it.copy(title = newTitle)
        }
    }

    fun updateDescription(newDescription: String) {
        _uiState.update {
            it.copy(description = newDescription)
        }
    }

    private fun createNewTask() = viewModelScope.launch {
        tasksRepository.createTask(uiState.value.title, uiState.value.description)
        _uiState.update {
            it.copy(isTaskSaved = true)
        }
    }

    private fun updateTask() {
        if (taskId == null) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.updateTask(
                taskId,
                title = uiState.value.title,
                description = uiState.value.description,
            )
            _uiState.update {
                it.copy(isTaskSaved = true)
            }
        }
    }

    private fun loadTask(taskId: String) {
        _uiState.update {
            it.copy(isLoading = true)
        }
        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { task ->
                if (task != null) {
                    _uiState.update {
                        it.copy(
                            title = task.title,
                            description = task.description,
                            isTaskCompleted = task.isCompleted,
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(isLoading = false)
                    }
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.source.local.LocalTask
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksDao
import kotlinx.coroutines.flow.Flow

class FakeTasksDao(var tasks: MutableList<LocalTask>? = mutableListOf()) : TasksDao {

    override suspend fun getTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTaskById(taskId: String): LocalTask? =
        tasks?.firstOrNull { it.id == taskId }

    override suspend fun insertTask(task: LocalTask) {
        tasks?.add(task)
    }

    override suspend fun updateTask(task: LocalTask): Int {
        tasks?.apply {
            val didTaskExist = removeIf { it.id == task.id }
            if (didTaskExist) {
                if (add(task)) {
                    return 1
                }
            }
        }
        return 0
    }

    override suspend fun updateCompleted(taskId: String, completed: Boolean) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = completed }
    }

    override suspend fun deleteTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTaskById(taskId: String): Int {
        val wasDeleted = tasks?.removeIf { it.id == taskId } ?: false
        return if (wasDeleted) 1 else 0
    }

    override suspend fun deleteCompletedTasks(): Int {
        tasks?.apply {
            val originalSize = size
            if (removeIf { it.isCompleted }) {
                return originalSize - size
            }
        }
        return 0
    }

    override fun observeTasks(): Flow<List<LocalTask>> {
        TODO("Not implemented")
    }

    override fun observeTaskById(taskId: String): Flow<LocalTask> {
        TODO("Not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.toExternalModels
import com.example.android.architecture.blueprints.todoapp.data.toLocalModel
import com.example.android.architecture.blueprints.todoapp.data.toNetworkModel
import com.example.android.architecture.blueprints.todoapp.data.toNetworkModels
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task(title = "Title1", description = "Description1")
    private val task2 = Task(title = "Title2", description = "Description2")
    private val task3 = Task(title = "Title3", description = "Description3")
    private val newTask = Task(title = "Title new", description = "Description new")
    private val networkTasks = listOf(task1, task2).toNetworkModels().sortedBy { it.id }
    private val localTasks = listOf(task3.toLocalModel()).sortedBy { it.id }

    private val newTasks = listOf(newTask).sortedBy { it.id }
    private lateinit var tasksNetworkDataSource: FakeNetworkDataSource
    private lateinit var tasksLocalDataSource: FakeTasksDao

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksNetworkDataSource = FakeNetworkDataSource(networkTasks.toMutableList())
        tasksLocalDataSource = FakeTasksDao(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksNetworkDataSource, tasksLocalDataSource
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptyRemoteSource = FakeNetworkDataSource()
        val emptyLocalSource = FakeTasksDao()

        val tasksRepository = DefaultTasksRepository(
            emptyRemoteSource, emptyLocalSource
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(networkTasks.toExternalModels())
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksNetworkDataSource.tasks).doesNotContain(newTask.toNetworkModel())
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask.toLocalModel())

        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksNetworkDataSource.tasks).contains(newTask.toNetworkModel())
        assertThat(tasksLocalDataSource.tasks?.contains(newTask.toLocalModel()))
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        tasksNetworkDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksNetworkDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks.toExternalModels())
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        tasksNetworkDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = tasksRepository.getTasks(true)

        assertThat(newTasks).isEqualTo(networkTasks.toExternalModels())
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks?.toExternalModels())
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksLocalDataSource.tasks = mutableListOf(task1.toLocalModel())
        val initial = tasksRepository.getTask(task1.id)

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksNetworkDataSource.tasks = mutableListOf(task1.toNetworkModel())
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        tasksNetworkDataSource.tasks = mutableListOf(task2.toNetworkModel())

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        tasksNetworkDataSource.tasks = mutableListOf(
            completedTask.toNetworkModel(),
            task2.toNetworkModel()
        )
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.source.remote.NetworkTask
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TaskStatus

class FakeNetworkDataSource(
    var tasks: MutableList<NetworkTask>? = mutableListOf()
) : NetworkDataSource {
    override suspend fun loadTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTask(taskId: String) = tasks?.firstOrNull { it.id == taskId }

    override suspend fun saveTask(task: NetworkTask) {
        tasks?.add(task)
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(status = TaskStatus.COMPLETE))
        }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(status = TaskStatus.ACTIVE))
        }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.status == TaskStatus.COMPLETE }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeRepository : TasksRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override suspend fun createTask(title: String, description: String): Task {
        return Task(title = title, description = description).also {
            saveTask(it)
        }
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val updatedTask = _savedTasks.value[taskId]?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        saveTask(updatedTask)
    }

    private fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.SmallTest
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@SmallTest
class TasksDaoTest {

    private lateinit var database: ToDoDatabase

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun initDb() {
        
        
        database = Room.inMemoryDatabaseBuilder(
            getApplicationContext(),
            ToDoDatabase::class.java
        ).allowMainThreadQueries().build()
    }

    @After
    fun closeDb() = database.close()

    @Test
    fun insertTaskAndGetById() = runTest {
        
        val task = LocalTask(title = "title", description = "description", id = "id")
        database.taskDao().insertTask(task)

        
        val loaded = database.taskDao().getTaskById(task.id)

        
        assertThat<LocalTask>(loaded as LocalTask, notNullValue())
        assertThat(loaded.id, `is`(task.id))
        assertThat(loaded.title, `is`(task.title))
        assertThat(loaded.description, `is`(task.description))
        assertThat(loaded.isCompleted, `is`(task.isCompleted))
    }

    @Test
    fun insertTaskReplacesOnConflict() = runTest {
        
        val task = LocalTask(title = "title", description = "description", id = "id")
        database.taskDao().insertTask(task)

        
        val newTask = LocalTask(
            title = "title2",
            description = "description2",
            isCompleted = true,
            id = task.id
        )
        database.taskDao().insertTask(newTask)

        
        val loaded = database.taskDao().getTaskById(task.id)
        assertThat(loaded?.id, `is`(task.id))
        assertThat(loaded?.title, `is`("title2"))
        assertThat(loaded?.description, `is`("description2"))
        assertThat(loaded?.isCompleted, `is`(true))
    }

    @Test
    fun insertTaskAndGetTasks() = runTest {
        
        val task = LocalTask(title = "title", description = "description", id = "id")
        database.taskDao().insertTask(task)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(1))
        assertThat(tasks[0].id, `is`(task.id))
        assertThat(tasks[0].title, `is`(task.title))
        assertThat(tasks[0].description, `is`(task.description))
        assertThat(tasks[0].isCompleted, `is`(task.isCompleted))
    }

    @Test
    fun updateTaskAndGetById() = runTest {
        
        val originalTask = LocalTask(title = "title", description = "description", id = "id")
        database.taskDao().insertTask(originalTask)

        
        val updatedTask = LocalTask(
            title = "new title",
            description = "new description",
            isCompleted = true,
            id = originalTask.id
        )
        database.taskDao().updateTask(updatedTask)

        
        val loaded = database.taskDao().getTaskById(originalTask.id)
        assertThat(loaded?.id, `is`(originalTask.id))
        assertThat(loaded?.title, `is`("new title"))
        assertThat(loaded?.description, `is`("new description"))
        assertThat(loaded?.isCompleted, `is`(true))
    }

    @Test
    fun updateCompletedAndGetById() = runTest {
        
        val task = LocalTask(
            title = "title",
            description = "description",
            id = "id",
            isCompleted = true
        )
        database.taskDao().insertTask(task)

        
        database.taskDao().updateCompleted(task.id, false)

        
        val loaded = database.taskDao().getTaskById(task.id)
        assertThat(loaded?.id, `is`(task.id))
        assertThat(loaded?.title, `is`(task.title))
        assertThat(loaded?.description, `is`(task.description))
        assertThat(loaded?.isCompleted, `is`(false))
    }

    @Test
    fun deleteTaskByIdAndGettingTasks() = runTest {
        
        val task = LocalTask(title = "title", description = "description", id = "id")
        database.taskDao().insertTask(task)

        
        database.taskDao().deleteTaskById(task.id)

        
        val tasks = database.taskDao().getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun deleteTasksAndGettingTasks() = runTest {
        
        database.taskDao().insertTask(
            LocalTask(
                title = "title",
                description = "description",
                id = "id"
            )
        )

        
        database.taskDao().deleteTasks()

        
        val tasks = database.taskDao().getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun deleteCompletedTasksAndGettingTasks() = runTest {
        
        database.taskDao().insertTask(
            LocalTask(title = "completed", description = "task", id = "id", isCompleted = true)
        )

        
        database.taskDao().deleteCompletedTasks()

        
        val tasks = database.taskDao().getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
@HiltAndroidTest
@ExperimentalCoroutinesApi
class StatisticsScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun tasks_showsNonEmptyMessage() = runTest {
        
        repository.apply {
            createTask("Title1", "Description1")
            createTask("Title2", "Description2").also {
                completeTask(it.id)
            }
        }

        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    StatisticsScreen(
                        openDrawer = { },
                        viewModel = StatisticsViewModel(repository)
                    )
                }
            }
        }

        val expectedActiveTaskText = activity.getString(R.string.statistics_active_tasks, 50.0f)
        val expectedCompletedTaskText = activity
            .getString(R.string.statistics_completed_tasks, 50.0f)

        
        composeTestRule.onNodeWithText(expectedActiveTaskText).assertIsDisplayed()
        composeTestRule.onNodeWithText(expectedCompletedTaskText).assertIsDisplayed()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@HiltAndroidTest
@ExperimentalCoroutinesApi
class AddEditTaskScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()

        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository, SavedStateHandle()),
                        topBarTitle = R.string.add_task,
                        onTaskUpdate = { },
                        onBack = { },
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() = runTest {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = repository.getTasks(true)
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
@HiltAndroidTest
@ExperimentalCoroutinesApi
class TaskDetailScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() = runTest {
        
        val activeTask = repository.createTask(
            title = "Active Task",
            description = "AndroidX Rocks"
        )

        
        setContent(activeTask)

        
        
        composeTestRule.onNodeWithText("Active Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() = runTest {
        
        val completedTask = repository.createTask("Completed Task", "AndroidX Rocks")
        repository.completeTask(completedTask.id)

        
        setContent(completedTask)

        
        
        composeTestRule.onNodeWithText("Completed Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    private fun setContent(activeTask: Task) {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TaskDetailScreen(
                        viewModel = TaskDetailViewModel(
                            repository,
                            SavedStateHandle(mapOf("taskId" to activeTask.id))
                        ),
                        onEditTask = {  },
                        onBack = { },
                        onDeleteTask = { },
                    )
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
@OptIn(ExperimentalCoroutinesApi::class)
class TasksTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun editTask() = runTest {
        val originalTaskTitle = "TITLE1"
        repository.createTask(originalTaskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText("DESCRIPTION").assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.edit_task)).assertIsDisplayed()
        findTextField(originalTaskTitle).performTextReplacement("NEW TITLE")
        findTextField("DESCRIPTION").performTextReplacement("NEW DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("NEW TITLE").assertIsDisplayed()
        
        composeTestRule.onNodeWithText(originalTaskTitle).assertDoesNotExist()
    }

    @Test
    fun createOneTask_deleteTask() {
        setContent()

        val taskTitle = "TITLE1"
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput(taskTitle)
        findTextField(R.string.description_hint).performTextInput("DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()

        
        composeTestRule.onNodeWithText(taskTitle).performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.nav_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertDoesNotExist()
    }

    @Test
    fun createTwoTasks_deleteOneTask() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION")
            createTask("TITLE2", "DESCRIPTION")
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).performClick()
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() = runTest {
        
        val taskTitle = "COMPLETED"
        repository.createTask(taskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() = runTest {
        
        val taskTitle = "ACTIVE"
        repository.apply {
            createTask(taskTitle, "DESCRIPTION").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() = runTest {
        
        val taskTitle = "ACT-COMP"
        repository.createTask(taskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() = runTest {
        
        val taskTitle = "COMP-ACT"
        repository.apply {
            createTask(taskTitle, "DESCRIPTION").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun createTask() {
        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("title").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun findTextField(textId: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(textId))
        )
    }

    private fun findTextField(text: String): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(text)
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onAllNodesWithText
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.test.espresso.Espresso.pressBack
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
class AppNavigationTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var tasksRepository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun drawerNavigationFromTasksToStatistics() {
        setContent()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_no_tasks))
            .assertIsDisplayed()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.no_tasks_all))
            .assertIsDisplayed()
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsDisplayed()
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        openDrawer()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()

        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        assertTrue(
            composeTestRule.onAllNodesWithText(activity.getString(R.string.statistics_title))
                .fetchSemanticsNodes().isNotEmpty()
        )
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() = runTest {
        val taskName = "UI <- button"
        tasksRepository.createTask(taskName, "Description")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .assertIsDisplayed()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    @Test
    fun taskDetailScreen_doubleBackButton() = runTest {
        val taskName = "Back button"
        tasksRepository.createTask(taskName, "Description")

        setContent()

        
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        pressBack()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        pressBack()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun openDrawer() {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.open_drawer))
            .performClick()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.StringRes
import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith



@RunWith(AndroidJUnit4::class)
@MediumTest


@HiltAndroidTest
@OptIn(ExperimentalCoroutinesApi::class)
class TasksScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun displayTask_whenRepositoryHasData() = runTest {
        
        repository.createTask("TITLE1", "DESCRIPTION1")

        
        setContent()

        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun displayActiveTask() = runTest {
        repository.createTask("TITLE1", "DESCRIPTION1")

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_completed)

        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun displayCompletedTask() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1").also { completeTask(it.id) }
        }

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()

        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsComplete() = runTest {
        repository.createTask("TITLE1", "DESCRIPTION1")

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsActive() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun showAllTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
    }

    @Test
    fun showActiveTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2")
            createTask("TITLE3", "DESCRIPTION3").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertDoesNotExist()
    }

    @Test
    fun showCompletedTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
            createTask("TITLE3", "DESCRIPTION3").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertIsDisplayed()
    }

    @Test
    fun clearCompletedTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_more))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).performClick()

        openFilterAndSelectOption(R.string.nav_all)
        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_all)

        
        composeTestRule.onNodeWithText("You have no tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_completed)
        
        composeTestRule.onNodeWithText("You have no completed tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_active)
        
        composeTestRule.onNodeWithText("You have no active tasks!").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TasksScreen(
                        viewModel = TasksViewModel(repository, SavedStateHandle()),
                        userMessage = R.string.successfully_added_task_message,
                        onUserMessageDisplayed = { },
                        onAddTask = { },
                        onTaskClick = { },
                        openDrawer = { }
                    )
                }
            }
        }
    }

    private fun openFilterAndSelectOption(@StringRes option: Int) {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(option)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(option)).performClick()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID


@Entity(tableName = "tasks")
data class Task @JvmOverloads constructor(
    @ColumnInfo(name = "title") val title: String = "",
    @ColumnInfo(name = "description") val description: String = "",
    @ColumnInfo(name = "completed") val isCompleted: Boolean = false,
    @PrimaryKey @ColumnInfo(name = "entryid") val id: String = UUID.randomUUID().toString()
) {

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description

    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() || description.isEmpty()
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksDataSource {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun saveTask(task: Task)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
) : TasksRepository {

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            updateTasksFromRemoteDataSource()
        }
        return tasksLocalDataSource.getTasks()
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return tasksLocalDataSource.getTasksStream()
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksRemoteDataSource.getTasks()

        
        tasksLocalDataSource.deleteAllTasks()
        remoteTasks.forEach { task ->
            tasksLocalDataSource.saveTask(task)
        }
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return tasksLocalDataSource.getTaskStream(taskId)
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksRemoteDataSource.getTask(taskId)

        if (remoteTask == null) {
            tasksLocalDataSource.deleteTask(taskId)
        } else {
            tasksLocalDataSource.saveTask(remoteTask)
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksLocalDataSource.getTask(taskId)
    }

    override suspend fun saveTask(task: Task) {
        coroutineScope {
            launch { tasksRemoteDataSource.saveTask(task) }
            launch { tasksLocalDataSource.saveTask(task) }
        }
    }

    override suspend fun completeTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.completeTask(taskId) }
            launch { tasksLocalDataSource.completeTask(taskId) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.activateTask(taskId) }
            launch { tasksLocalDataSource.activateTask(taskId) }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteAllTasks() }
            launch { tasksLocalDataSource.deleteAllTasks() }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Database
import androidx.room.RoomDatabase
import com.example.android.architecture.blueprints.todoapp.data.Task


@Database(entities = [Task::class], version = 1, exportSchema = false)
abstract class ToDoDatabase : RoomDatabase() {

    abstract fun taskDao(): TasksDao
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


@Dao
interface TasksDao {

    
    @Query("SELECT * FROM Tasks")
    fun observeTasks(): Flow<List<Task>>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    fun observeTaskById(taskId: String): Flow<Task>

    
    @Query("SELECT * FROM Tasks")
    suspend fun getTasks(): List<Task>

    
    @Query("SELECT * FROM Tasks WHERE entryid = :taskId")
    suspend fun getTaskById(taskId: String): Task?

    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTask(task: Task)

    
    @Update
    suspend fun updateTask(task: Task): Int

    
    @Query("UPDATE tasks SET completed = :completed WHERE entryid = :taskId")
    suspend fun updateCompleted(taskId: String, completed: Boolean)

    
    @Query("DELETE FROM Tasks WHERE entryid = :taskId")
    suspend fun deleteTaskById(taskId: String): Int

    
    @Query("DELETE FROM Tasks")
    suspend fun deleteTasks()

    
    @Query("DELETE FROM Tasks WHERE completed = 1")
    suspend fun deleteCompletedTasks(): Int
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource


class TasksLocalDataSource internal constructor(
    private val tasksDao: TasksDao
) : TasksDataSource {

    override fun getTasksStream() = tasksDao.observeTasks()

    override fun getTaskStream(taskId: String) = tasksDao.observeTaskById(taskId)

    override suspend fun refreshTask(taskId: String) {
        
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun getTasks(): List<Task> = tasksDao.getTasks()

    override suspend fun getTask(taskId: String): Task? = tasksDao.getTaskById(taskId)

    override suspend fun saveTask(task: Task) = tasksDao.insertTask(task)

    override suspend fun completeTask(taskId: String) =
        tasksDao.updateCompleted(taskId, true)

    override suspend fun activateTask(taskId: String) =
        tasksDao.updateCompleted(taskId, false)

    override suspend fun clearCompletedTasks() {
        tasksDao.deleteCompletedTasks()
    }

    override suspend fun deleteAllTasks() = tasksDao.deleteTasks()

    override suspend fun deleteTask(taskId: String) {
        tasksDao.deleteTaskById(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking


object TasksRemoteDataSource : TasksDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, Task>(2)

    init {
        addTask("Build tower in Pisa", "Ground looks good, no foundation work required.")
        addTask("Finish bridge in Tacoma", "Found awesome girders at half the cost!")
    }

    private val observableTasks = MutableStateFlow(runBlocking { getTasks() })

    override suspend fun refreshTasks() {
        observableTasks.value = getTasks()
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return observableTasks
    }

    override suspend fun getTasks(): List<Task> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun getTask(taskId: String): Task? {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        return TASKS_SERVICE_DATA[taskId]
    }

    private fun addTask(title: String, description: String) {
        val newTask = Task(title, description)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class RemoteTasksDataSource

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class LocalTasksDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTasksRepository(
        @RemoteTasksDataSource remoteDataSource: TasksDataSource,
        @LocalTasksDataSource localDataSource: TasksDataSource,
    ): TasksRepository {
        return DefaultTasksRepository(remoteDataSource, localDataSource)
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @RemoteTasksDataSource
    @Provides
    fun provideTasksRemoteDataSource(): TasksDataSource = TasksRemoteDataSource

    @Singleton
    @LocalTasksDataSource
    @Provides
    fun provideTasksLocalDataSource(
        database: ToDoDatabase
    ): TasksDataSource {
        return TasksLocalDataSource(database.taskDao())
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch


data class AddEditTaskUiState(
    val title: String = "",
    val description: String = "",
    val isTaskCompleted: Boolean = false,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskSaved: Boolean = false
)


@HiltViewModel
class AddEditTaskViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val taskId: String? = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]

    
    
    
    private val _uiState = MutableStateFlow(AddEditTaskUiState())
    val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

    init {
        if (taskId != null) {
            loadTask(taskId)
        }
    }

    
    fun saveTask() {
        if (uiState.value.title.isEmpty() || uiState.value.description.isEmpty()) {
            _uiState.update {
                it.copy(userMessage = R.string.empty_task_message)
            }
            return
        }

        if (taskId == null) {
            createNewTask()
        } else {
            updateTask()
        }
    }

    fun snackbarMessageShown() {
        _uiState.update {
            it.copy(userMessage = null)
        }
    }

    fun updateTitle(newTitle: String) {
        _uiState.update {
            it.copy(title = newTitle)
        }
    }

    fun updateDescription(newDescription: String) {
        _uiState.update {
            it.copy(description = newDescription)
        }
    }

    private fun createNewTask() = viewModelScope.launch {
        val newTask = Task(uiState.value.title, uiState.value.description)
        tasksRepository.saveTask(newTask)
        _uiState.update {
            it.copy(isTaskSaved = true)
        }
    }

    private fun updateTask() {
        if (taskId == null) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            val updatedTask = Task(
                title = uiState.value.title,
                description = uiState.value.description,
                isCompleted = uiState.value.isTaskCompleted,
                id = taskId
            )
            tasksRepository.saveTask(updatedTask)
            _uiState.update {
                it.copy(isTaskSaved = true)
            }
        }
    }

    private fun loadTask(taskId: String) {
        _uiState.update {
            it.copy(isLoading = true)
        }
        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { task ->
                if (task != null) {
                    _uiState.update {
                        it.copy(
                            title = task.title,
                            description = task.description,
                            isTaskCompleted = task.isCompleted,
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(isLoading = false)
                    }
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

object FakeFailingTasksRemoteDataSource : TasksDataSource {
    override suspend fun getTasks(): List<Task> {
        throw Exception("Test")
    }

    override suspend fun getTask(taskId: String): Task? {
        throw Exception("Test")
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return flow { emit(getTasks()) }
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return flow { emit(getTask(taskId)) }
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun saveTask(task: Task) {
        TODO("not implemented")
    }

    override suspend fun completeTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun activateTask(taskId: String) {
        TODO("not implemented")
    }

    override suspend fun clearCompletedTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteAllTasks() {
        TODO("not implemented")
    }

    override suspend fun deleteTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task("Title1", "Description1")
    private val task2 = Task("Title2", "Description2")
    private val task3 = Task("Title3", "Description3")
    private val newTask = Task("Title new", "Description new")
    private val remoteTasks = listOf(task1, task2).sortedBy { it.id }
    private val localTasks = listOf(task3).sortedBy { it.id }
    private val newTasks = listOf(newTask).sortedBy { it.id }
    private lateinit var tasksRemoteDataSource: FakeDataSource
    private lateinit var tasksLocalDataSource: FakeDataSource

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksRemoteDataSource = FakeDataSource(remoteTasks.toMutableList())
        tasksLocalDataSource = FakeDataSource(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksRemoteDataSource, tasksLocalDataSource
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptySource = FakeDataSource()
        val tasksRepository = DefaultTasksRepository(
            emptySource, emptySource
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(remoteTasks)
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksRemoteDataSource.tasks).doesNotContain(newTask)
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask)

        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRemoteDataSource.tasks).contains(newTask)
        assertThat(tasksLocalDataSource.tasks).contains(newTask)
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        tasksRemoteDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksRemoteDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks)
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        tasksRemoteDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = tasksRepository.getTasks(true)

        assertThat(newTasks).isEqualTo(remoteTasks)
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks)
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        tasksRepository.saveTask(newTask)
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksLocalDataSource.tasks = mutableListOf(task1)
        val initial = tasksRepository.getTask(task1.id)

        
        tasksRemoteDataSource.tasks = newTasks.toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksRemoteDataSource.tasks = mutableListOf(task1)
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        tasksRemoteDataSource.tasks = mutableListOf(task2)

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        tasksRemoteDataSource.tasks = mutableListOf(completedTask, task2)
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow

class FakeDataSource(var tasks: MutableList<Task>? = mutableListOf()) : TasksDataSource {
    override suspend fun getTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTask(taskId: String) = tasks?.firstOrNull { it.id == taskId }

    override suspend fun saveTask(task: Task) {
        tasks?.add(task)
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.isCompleted }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }

    override fun getTasksStream(): Flow<List<Task>> {
        TODO("not implemented")
    }

    override suspend fun refreshTasks() {
        TODO("not implemented")
    }

    override fun getTaskStream(taskId: String): Flow<Task> {
        TODO("not implemented")
    }

    override suspend fun refreshTask(taskId: String) {
        TODO("not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.util

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.runBlocking


fun TasksRepository.saveTaskBlocking(task: Task) = runBlocking {
    this@saveTaskBlocking.saveTask(task)
}

fun TasksRepository.getTasksBlocking(forceUpdate: Boolean) = runBlocking {
    this@getTasksBlocking.getTasks(forceUpdate)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeRepository : TasksRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.SmallTest
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@SmallTest
class TasksDaoTest {

    private lateinit var database: ToDoDatabase

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun initDb() {
        
        
        database = Room.inMemoryDatabaseBuilder(
            getApplicationContext(),
            ToDoDatabase::class.java
        ).allowMainThreadQueries().build()
    }

    @After
    fun closeDb() = database.close()

    @Test
    fun insertTaskAndGetById() = runTest {
        
        val task = Task("title", "description")
        database.taskDao().insertTask(task)

        
        val loaded = database.taskDao().getTaskById(task.id)

        
        assertThat<Task>(loaded as Task, notNullValue())
        assertThat(loaded.id, `is`(task.id))
        assertThat(loaded.title, `is`(task.title))
        assertThat(loaded.description, `is`(task.description))
        assertThat(loaded.isCompleted, `is`(task.isCompleted))
    }

    @Test
    fun insertTaskReplacesOnConflict() = runTest {
        
        val task = Task("title", "description")
        database.taskDao().insertTask(task)

        
        val newTask = Task("title2", "description2", true, task.id)
        database.taskDao().insertTask(newTask)

        
        val loaded = database.taskDao().getTaskById(task.id)
        assertThat(loaded?.id, `is`(task.id))
        assertThat(loaded?.title, `is`("title2"))
        assertThat(loaded?.description, `is`("description2"))
        assertThat(loaded?.isCompleted, `is`(true))
    }

    @Test
    fun insertTaskAndGetTasks() = runTest {
        
        val task = Task("title", "description")
        database.taskDao().insertTask(task)

        
        val tasks = database.taskDao().getTasks()

        
        assertThat(tasks.size, `is`(1))
        assertThat(tasks[0].id, `is`(task.id))
        assertThat(tasks[0].title, `is`(task.title))
        assertThat(tasks[0].description, `is`(task.description))
        assertThat(tasks[0].isCompleted, `is`(task.isCompleted))
    }

    @Test
    fun updateTaskAndGetById() = runTest {
        
        val originalTask = Task("title", "description")
        database.taskDao().insertTask(originalTask)

        
        val updatedTask = Task("new title", "new description", true, originalTask.id)
        database.taskDao().updateTask(updatedTask)

        
        val loaded = database.taskDao().getTaskById(originalTask.id)
        assertThat(loaded?.id, `is`(originalTask.id))
        assertThat(loaded?.title, `is`("new title"))
        assertThat(loaded?.description, `is`("new description"))
        assertThat(loaded?.isCompleted, `is`(true))
    }

    @Test
    fun updateCompletedAndGetById() = runTest {
        
        val task = Task("title", "description", true)
        database.taskDao().insertTask(task)

        
        database.taskDao().updateCompleted(task.id, false)

        
        val loaded = database.taskDao().getTaskById(task.id)
        assertThat(loaded?.id, `is`(task.id))
        assertThat(loaded?.title, `is`(task.title))
        assertThat(loaded?.description, `is`(task.description))
        assertThat(loaded?.isCompleted, `is`(false))
    }

    @Test
    fun deleteTaskByIdAndGettingTasks() = runTest {
        
        val task = Task("title", "description")
        database.taskDao().insertTask(task)

        
        database.taskDao().deleteTaskById(task.id)

        
        val tasks = database.taskDao().getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun deleteTasksAndGettingTasks() = runTest {
        
        database.taskDao().insertTask(Task("title", "description"))

        
        database.taskDao().deleteTasks()

        
        val tasks = database.taskDao().getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun deleteCompletedTasksAndGettingTasks() = runTest {
        
        database.taskDao().insertTask(Task("completed", "task", true))

        
        database.taskDao().deleteCompletedTasks()

        
        val tasks = database.taskDao().getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.nullValue
import org.hamcrest.MatcherAssert.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@ExperimentalCoroutinesApi
@RunWith(AndroidJUnit4::class)
@MediumTest
class TasksLocalDataSourceTest {

    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            ToDoDatabase::class.java
        )
            .allowMainThreadQueries()
            .build()

        localDataSource = TasksLocalDataSource(database.taskDao())
    }

    @After
    fun cleanUp() {
        database.close()
    }

    @Test
    fun saveTask_retrievesTask() = runTest {
        
        val newTask = Task("title", "description", true)
        localDataSource.saveTask(newTask)

        
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`("title"))
        assertThat(task?.description, `is`("description"))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun completeTask_retrievedTaskIsComplete() = runTest {
        
        val newTask = Task("title")
        localDataSource.saveTask(newTask)

        
        localDataSource.completeTask(newTask.id)
        val task = localDataSource.getTask(newTask.id)

        
        assertThat(task?.title, `is`(newTask.title))
        assertThat(task?.isCompleted, `is`(true))
    }

    @Test
    fun activateTask_retrievedTaskIsActive() = runTest {
        
        val newTask = Task("Some title", "Some description", true)
        localDataSource.saveTask(newTask)

        localDataSource.activateTask(newTask.id)

        
        val task = localDataSource.getTask(newTask.id)

        assertThat(task?.title, `is`("Some title"))
        assertThat(task?.isCompleted, `is`(false))
    }

    @Test
    fun clearCompletedTask_taskNotRetrievable() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title2")
        val newTask3 = Task("title3")
        localDataSource.saveTask(newTask1)
        localDataSource.completeTask(newTask1.id)
        localDataSource.saveTask(newTask2)
        localDataSource.completeTask(newTask2.id)
        localDataSource.saveTask(newTask3)
        
        localDataSource.clearCompletedTasks()

        
        assertThat(localDataSource.getTask(newTask1.id), `is`(nullValue()))
        assertThat(localDataSource.getTask(newTask2.id), `is`(nullValue()))

        val result3 = localDataSource.getTask(newTask3.id)
        assertThat(result3, `is`(newTask3))
    }

    @Test
    fun deleteAllTasks_emptyListOfRetrievedTask() = runTest {
        
        val newTask = Task("title")

        localDataSource.saveTask(newTask)

        
        localDataSource.deleteAllTasks()

        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.isEmpty(), `is`(true))
    }

    @Test
    fun getTasks_retrieveSavedTasks() = runTest {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title")

        localDataSource.saveTask(newTask1)
        localDataSource.saveTask(newTask2)
        
        val tasks = localDataSource.getTasks()
        assertThat(tasks.size, `is`(2))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
@HiltAndroidTest
class StatisticsScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun tasks_showsNonEmptyMessage() {
        
        repository.apply {
            saveTaskBlocking(Task("Title1", "Description1", false))
            saveTaskBlocking(Task("Title2", "Description2", true))
        }

        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    StatisticsScreen(
                        openDrawer = { },
                        viewModel = StatisticsViewModel(repository)
                    )
                }
            }
        }

        val expectedActiveTaskText = activity.getString(R.string.statistics_active_tasks, 50.0f)
        val expectedCompletedTaskText = activity
            .getString(R.string.statistics_completed_tasks, 50.0f)

        
        composeTestRule.onNodeWithText(expectedActiveTaskText).assertIsDisplayed()
        composeTestRule.onNodeWithText(expectedCompletedTaskText).assertIsDisplayed()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@HiltAndroidTest
class AddEditTaskScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()

        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository, SavedStateHandle()),
                        topBarTitle = R.string.add_task,
                        onTaskUpdate = { },
                        onBack = { },
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = repository.getTasksBlocking(true)
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
@HiltAndroidTest
class TaskDetailScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        
        val activeTask = Task("Active Task", "AndroidX Rocks", false)
        repository.saveTaskBlocking(activeTask)

        
        setContent(activeTask)

        
        
        composeTestRule.onNodeWithText("Active Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        
        val completedTask = Task("Completed Task", "AndroidX Rocks", true)
        repository.saveTaskBlocking(completedTask)

        
        setContent(completedTask)

        
        
        composeTestRule.onNodeWithText("Completed Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    private fun setContent(activeTask: Task) {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TaskDetailScreen(
                        viewModel = TaskDetailViewModel(
                            repository,
                            SavedStateHandle(mapOf("taskId" to activeTask.id))
                        ),
                        onEditTask = {  },
                        onBack = { },
                        onDeleteTask = { },
                    )
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
class TasksTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun editTask() {
        val originalTaskTitle = "TITLE1"
        repository.saveTaskBlocking(Task(originalTaskTitle, "DESCRIPTION"))

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText("DESCRIPTION").assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.edit_task)).assertIsDisplayed()
        findTextField(originalTaskTitle).performTextReplacement("NEW TITLE")
        findTextField("DESCRIPTION").performTextReplacement("NEW DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("NEW TITLE").assertIsDisplayed()
        
        composeTestRule.onNodeWithText(originalTaskTitle).assertDoesNotExist()
    }

    @Test
    fun createOneTask_deleteTask() {
        setContent()

        val taskTitle = "TITLE1"
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput(taskTitle)
        findTextField(R.string.description_hint).performTextInput("DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()

        
        composeTestRule.onNodeWithText(taskTitle).performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.nav_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertDoesNotExist()
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION"))

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).performClick()
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMPLETED"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACTIVE"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACT-COMP"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMP-ACT"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun createTask() {
        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("title").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun findTextField(textId: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(textId))
        )
    }

    private fun findTextField(text: String): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(text)
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onAllNodesWithText
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.test.espresso.Espresso.pressBack
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
class AppNavigationTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var tasksRepository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun drawerNavigationFromTasksToStatistics() {
        setContent()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_no_tasks))
            .assertIsDisplayed()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.no_tasks_all))
            .assertIsDisplayed()
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsDisplayed()
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        openDrawer()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()

        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        assertTrue(
            composeTestRule.onAllNodesWithText(activity.getString(R.string.statistics_title))
                .fetchSemanticsNodes().isNotEmpty()
        )
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        val taskName = "UI <- button"
        val task = Task(taskName, "Description")
        tasksRepository.saveTaskBlocking(task)

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .assertIsDisplayed()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        val taskName = "Back button"
        val task = Task(taskName, "Description")
        tasksRepository.saveTaskBlocking(task)

        setContent()

        
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        pressBack()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        pressBack()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun openDrawer() {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.open_drawer))
            .performClick()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.StringRes
import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith



@RunWith(AndroidJUnit4::class)
@MediumTest


@HiltAndroidTest
class TasksScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        
        setContent()

        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_completed)

        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()

        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        setContent()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        setContent()

        
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertDoesNotExist()
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        setContent()

        
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertIsDisplayed()
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_more))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).performClick()

        openFilterAndSelectOption(R.string.nav_all)
        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_all)

        
        composeTestRule.onNodeWithText("You have no tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_completed)
        
        composeTestRule.onNodeWithText("You have no completed tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_active)
        
        composeTestRule.onNodeWithText("You have no active tasks!").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TasksScreen(
                        viewModel = TasksViewModel(repository, SavedStateHandle()),
                        userMessage = R.string.successfully_added_task_message,
                        onUserMessageDisplayed = { },
                        onAddTask = { },
                        onTaskClick = { },
                        openDrawer = { }
                    )
                }
            }
        }
    }

    private fun openFilterAndSelectOption(@StringRes option: Int) {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(option)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(option)).performClick()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import androidx.compose.ui.test.assertIsOn
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.internal.runner.junit4.statement.UiThreadStatement.runOnUiThread
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private lateinit var repository: TasksRepository

    @get:Rule
    val composeTestRule = createAndroidComposeRule<TasksActivity>()
    private val activity get() = composeTestRule.activity

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        
        runOnUiThread {
            ServiceLocator.createDataBase(getApplicationContext(), inMemory = true)
            repository = ServiceLocator.provideTasksRepository(getApplicationContext())
            repository.deleteAllTasksBlocking()
        }
    }

    @After
    fun reset() {
        runOnUiThread {
            ServiceLocator.resetRepository()
        }
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun editTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText("TITLE1")).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("DESCRIPTION").assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()
        findTextField("TITLE1").performTextReplacement("NEW TITLE")
        findTextField("DESCRIPTION").performTextReplacement("NEW DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        onView(withText("NEW TITLE")).check(matches(isDisplayed()))
        
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput("TITLE1")
        findTextField(R.string.description_hint).performTextInput("DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText("TITLE2")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "COMPLETED"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "ACTIVE"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "ACT-COMP"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "COMP-ACT"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun createTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        onView(withText("title")).check(matches(isDisplayed()))
    }

    private fun findTextField(textId: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(textId))
        )
    }

    private fun findTextField(text: String): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(text)
        )
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.Gravity
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.contrib.NavigationViewActions.navigateTo
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private lateinit var tasksRepository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @get:Rule
    val composeTestRule = createAndroidComposeRule<TasksActivity>()
    private val activity get() = composeTestRule.activity

    @Before
    fun init() {
        tasksRepository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun drawerNavigationFromTasksToStatistics() {
        
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.statistics_fragment_dest))

        
        composeTestRule.onNodeWithText("You have no tasks.").assertIsDisplayed()
        composeTestRule.waitForIdle()

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.tasks_fragment_dest))

        
        composeTestRule.onNodeWithText("You have no tasks!").assertIsDisplayed()
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        composeTestRule.activityRule.scenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statistics_fragment_dest)
        }
        composeTestRule.waitForIdle()

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        val task = Task("UI <- button", "Description")
        tasksRepository.saveTaskBlocking(task)
        composeTestRule.waitForIdle()

        
        onView(withText("UI <- button")).perform(click())
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())
        composeTestRule.onNodeWithText("UI <- button").assertIsDisplayed()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())
        composeTestRule.onNodeWithText("All tasks").assertIsDisplayed()
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        val task = Task("Back button", "Description")
        tasksRepository.saveTaskBlocking(task)
        composeTestRule.waitForIdle()

        
        onView(withText("Back button")).perform(click())
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        pressBack()
        composeTestRule.onNodeWithText("Back button").assertIsDisplayed()

        
        pressBack()
        composeTestRule.onNodeWithText("All tasks").assertIsDisplayed()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.Checkbox
import androidx.compose.material.FloatingActionButton
import androidx.compose.material.Icon
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Scaffold
import androidx.compose.material.Surface
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.rememberScaffoldState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.dimensionResource
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.LoadingContent
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.google.accompanist.appcompattheme.AppCompatTheme

@Composable
fun TasksScreen(
    onAddTask: () -> Unit,
    onTaskClick: (Task) -> Unit,
    modifier: Modifier = Modifier,
    viewModel: TasksViewModel = viewModel(factory = getViewModelFactory())
) {
    val scaffoldState = rememberScaffoldState()
    Scaffold(
        scaffoldState = scaffoldState,
        modifier = modifier.fillMaxSize(),
        floatingActionButton = {
            FloatingActionButton(onClick = onAddTask) {
                Icon(Icons.Filled.Add, stringResource(id = R.string.add_task))
            }
        }
    ) { paddingValues ->
        val loading by viewModel.dataLoading.observeAsState(initial = false)
        val items by viewModel.items.observeAsState(initial = emptyList())
        val filteringLabel by viewModel.currentFilteringLabel.observeAsState(R.string.label_all)
        val noTasksLabel by viewModel.noTasksLabel.observeAsState(initial = R.string.no_tasks_all)
        val noTasksIconRes by viewModel.noTaskIconRes.observeAsState(R.drawable.logo_no_fill)

        TasksContent(
            loading = loading,
            tasks = items,
            currentFilteringLabel = filteringLabel,
            noTasksLabel = noTasksLabel,
            noTasksIconRes = noTasksIconRes,
            onRefresh = viewModel::refresh,
            onTaskClick = onTaskClick,
            onTaskCheckedChange = viewModel::completeTask,
            modifier = Modifier.padding(paddingValues)
        )
    }
}

@Composable
private fun TasksContent(
    loading: Boolean,
    tasks: List<Task>,
    @StringRes currentFilteringLabel: Int,
    @StringRes noTasksLabel: Int,
    @DrawableRes noTasksIconRes: Int,
    onRefresh: () -> Unit,
    onTaskClick: (Task) -> Unit,
    onTaskCheckedChange: (Task, Boolean) -> Unit,
    modifier: Modifier = Modifier
) {
    LoadingContent(
        loading = loading,
        empty = tasks.isEmpty(),
        emptyContent = { TasksEmptyContent(noTasksLabel, noTasksIconRes, modifier) },
        onRefresh = onRefresh
    ) {
        Column(modifier = modifier.fillMaxSize()) {
            Text(
                text = stringResource(currentFilteringLabel),
                modifier = Modifier.padding(
                    horizontal = dimensionResource(id = R.dimen.list_item_padding),
                    vertical = dimensionResource(id = R.dimen.activity_vertical_margin)
                ),
                style = MaterialTheme.typography.h6
            )
            LazyColumn {
                items(tasks) { task ->
                    TaskItem(
                        task = task,
                        onTaskClick = onTaskClick,
                        onCheckedChange = { onTaskCheckedChange(task, it) }
                    )
                }
            }
        }
    }
}

@Composable
private fun TaskItem(
    task: Task,
    onCheckedChange: (Boolean) -> Unit,
    onTaskClick: (Task) -> Unit
) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier
            .fillMaxWidth()
            .padding(
                horizontal = dimensionResource(id = R.dimen.activity_horizontal_margin),
                vertical = dimensionResource(id = R.dimen.list_item_padding),
            )
            .clickable { onTaskClick(task) }
    ) {
        Checkbox(
            checked = task.isCompleted,
            onCheckedChange = onCheckedChange
        )
        Text(
            text = task.titleForList,
            style = MaterialTheme.typography.h6,
            modifier = Modifier.padding(
                start = dimensionResource(id = R.dimen.activity_horizontal_margin)
            ),
            textDecoration = if (task.isCompleted) {
                TextDecoration.LineThrough
            } else {
                null
            }
        )
    }
}

@Composable
private fun TasksEmptyContent(
    @StringRes noTasksLabel: Int,
    @DrawableRes noTasksIconRes: Int,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Image(
            painter = painterResource(id = noTasksIconRes),
            contentDescription = stringResource(R.string.no_tasks_image_content_description),
            modifier = Modifier.size(96.dp)
        )
        Text(stringResource(id = noTasksLabel))
    }
}

@Preview
@Composable
private fun TasksContentPreview() {
    AppCompatTheme {
        Surface {
            TasksContent(
                loading = false,
                tasks = listOf(
                    Task("Title 1", "Description 1"),
                    Task("Title 2", "Description 2", true),
                    Task("Title 3", "Description 3", true),
                    Task("Title 4", "Description 4"),
                    Task("Title 5", "Description 5", true)
                ),
                currentFilteringLabel = R.string.label_all,
                noTasksLabel = R.string.no_tasks_all,
                noTasksIconRes = R.drawable.logo_no_fill,
                onRefresh = { },
                onTaskClick = { },
                onTaskCheckedChange = { _, _ -> },
            )
        }
    }
}

@Preview
@Composable
private fun TasksContentEmptyPreview() {
    AppCompatTheme {
        Surface {
            TasksContent(
                loading = false,
                tasks = emptyList(),
                currentFilteringLabel = R.string.label_all,
                noTasksLabel = R.string.no_tasks_all,
                noTasksIconRes = R.drawable.logo_no_fill,
                onRefresh = { },
                onTaskClick = { },
                onTaskCheckedChange = { _, _ -> },
            )
        }
    }
}

@Preview
@Composable
private fun TasksEmptyContentPreview() {
    AppCompatTheme {
        Surface {
            TasksEmptyContent(
                noTasksLabel = R.string.no_tasks_all,
                noTasksIconRes = R.drawable.logo_no_fill
            )
        }
    }
}

@Preview
@Composable
private fun TaskItemPreview() {
    AppCompatTheme {
        Surface {
            TaskItem(
                task = Task("Title", "Description"),
                onTaskClick = { },
                onCheckedChange = { }
            )
        }
    }
}

@Preview
@Composable
private fun TaskItemCompletedPreview() {
    AppCompatTheme {
        Surface {
            TaskItem(
                task = Task("Title", "Description", true),
                onTaskClick = { },
                onCheckedChange = { }
            )
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.platform.ViewCompositionStrategy
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.accompanist.appcompattheme.AppCompatTheme
import com.google.android.material.snackbar.Snackbar


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getViewModelFactory() }

    private val args: TasksFragmentArgs by navArgs()

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        setHasOptionsMenu(true)

        return ComposeView(requireContext()).apply {
            
            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
            setContent {
                AppCompatTheme {
                    TasksScreen(
                        viewModel = viewModel,
                        onAddTask = { navigateToAddNewTask() },
                        onTaskClick = { openTaskDetails(it.id) }
                    )
                }
            }
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupSnackbar()
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(viewLifecycleOwner, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                true
            }
            show()
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.distinctUntilChanged
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import kotlinx.coroutines.launch


class TasksViewModel(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _forceUpdate = MutableLiveData<Boolean>(false)

    private val _items: LiveData<List<Task>> = _forceUpdate.switchMap { forceUpdate ->
        if (forceUpdate) {
            _dataLoading.value = true
            viewModelScope.launch {
                tasksRepository.refreshTasks()
                _dataLoading.value = false
            }
        }
        tasksRepository.observeTasks().distinctUntilChanged().switchMap { filterTasks(it) }
    }

    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarText: LiveData<Event<Int>> = _snackbarText

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private var resultMessageShown: Boolean = false

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(getSavedFilterType())
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle.set(TASKS_FILTER_SAVED_STATE_KEY, requestType)

        
        when (requestType) {
            ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
        
        loadTasks(false)
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int,
        @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int,
        tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        if (resultMessageShown) return
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
        resultMessageShown = true
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    private fun filterTasks(tasksResult: Result<List<Task>>): LiveData<List<Task>> {
        
        val result = MutableLiveData<List<Task>>()

        if (tasksResult is Success) {
            isDataLoadingError.value = false
            viewModelScope.launch {
                result.value = filterItems(tasksResult.data, getSavedFilterType())
            }
        } else {
            result.value = emptyList()
            showSnackbarMessage(R.string.loading_tasks_error)
            isDataLoadingError.value = true
        }

        return result
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _forceUpdate.value = forceUpdate
    }

    private fun filterItems(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    fun refresh() {
        _forceUpdate.value = true
    }

    private fun getSavedFilterType(): TasksFilterType {
        return savedStateHandle.get(TASKS_FILTER_SAVED_STATE_KEY) ?: ALL_TASKS
    }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.getOrAwaitValue
import com.example.android.architecture.blueprints.todoapp.observeForTesting
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository, SavedStateHandle())
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() {
        
        mainCoroutineRule.pauseDispatcher()

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isTrue()

            
            mainCoroutineRule.resumeDispatcher()

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).hasSize(3)
        }
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).hasSize(1)
        }
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).hasSize(2)
        }
    }

    @Test
    fun loadTasks_error() {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).isEmpty()

            
            assertSnackbarMessage(tasksViewModel.snackbarText, R.string.loading_tasks_error)
        }
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = mainCoroutineRule.runBlockingTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.loadTasks(true)

        
        val allTasks = tasksViewModel.items.getOrAwaitValue()
        val completedTasks = allTasks.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.completed_tasks_cleared
        )
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.successfully_saved_task_message
        )
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.successfully_added_task_message
        )
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertSnackbarMessage(tasksViewModel.snackbarText, R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.task_marked_complete
        )
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isActive).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.task_marked_active
        )
    }

    @Test
    fun getTasksAddViewVisible() {
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        assertThat(tasksViewModel.tasksAddViewVisible.getOrAwaitValue()).isTrue()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.activity.ComponentActivity
import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.navigation.Navigation.findNavController
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class AddEditTaskScreenTest {

    @get:Rule
    val composeTestRule = createAndroidComposeRule<ComponentActivity>()
    private val activity get() = composeTestRule.activity

    private val repository = FakeRepository()

    @Before
    fun setup() {
        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository),
                        taskId = null,
                        onTaskUpdate = { }
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = (repository.getTasksBlocking(true) as Result.Success).data
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.navigation.Navigation.findNavController
import androidx.navigation.findNavController
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class TasksScreenTest {

    private lateinit var repository: TasksRepository

    @get:Rule
    val composeTestRule = createAndroidComposeRule<TasksActivity>()
    private val activity get() = composeTestRule.activity

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlockingTest {
        ServiceLocator.resetRepository()
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        
        launchScreen()

        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchScreen()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchScreen()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchScreen()

        
        composeTestRule.onNodeWithText("TITLE1").performClick()

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        launchScreen()

        
        composeTestRule.onNodeWithText("TITLE1").performClick()

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchScreen()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchScreen()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchScreen()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchScreen()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertDoesNotExist()
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchScreen()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertIsDisplayed()
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchScreen()

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(R.string.menu_clear)).perform(click())

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        launchScreen()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())

        
        composeTestRule.onNodeWithText("You have no tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        launchScreen()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        
        composeTestRule.onNodeWithText("You have no completed tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        launchScreen()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())

        
        composeTestRule.onNodeWithText("You have no active tasks!").assertIsDisplayed()
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        launchScreen()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()

        
        assertEquals(
            activity.findNavController(R.id.nav_host_fragment).currentDestination?.id,
            R.id.add_edit_task_fragment_dest
        )
    }

    private fun launchScreen() {
        composeTestRule.activityRule.scenario.onActivity {
            findNavController(it, R.id.nav_host_fragment).apply {
                setGraph(R.navigation.nav_graph)
            }
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.internal.runner.junit4.statement.UiThreadStatement.runOnUiThread
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.Matchers.allOf
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private lateinit var repository: TasksRepository

    @get:Rule
    val composeTestRule = createAndroidComposeRule<TasksActivity>()
    private val activity get() = composeTestRule.activity

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        
        runOnUiThread {
            ServiceLocator.createDataBase(getApplicationContext(), inMemory = true)
            repository = ServiceLocator.provideTasksRepository(getApplicationContext())
            repository.deleteAllTasksBlocking()
        }
    }

    @After
    fun reset() {
        runOnUiThread {
            ServiceLocator.resetRepository()
        }
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun editTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText("TITLE1")).perform(click())
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("DESCRIPTION").assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()
        onView(withId(R.id.edit_task_fab)).perform(click())
        findTextField("TITLE1").performTextReplacement("NEW TITLE")
        findTextField("DESCRIPTION").performTextReplacement("NEW DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        onView(withText("NEW TITLE")).check(matches(isDisplayed()))
        
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        onView(withId(R.id.add_task_fab)).perform(click())
        findTextField(R.string.title_hint).performTextInput("TITLE1")
        findTextField(R.string.description_hint).performTextInput("DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText("TITLE2")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "COMPLETED"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(allOf(withId(R.id.complete_checkbox), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "ACTIVE"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(allOf(withId(R.id.complete_checkbox), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "ACT-COMP"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(allOf(withId(R.id.complete_checkbox), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        val taskTitle = "COMP-ACT"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))
        composeTestRule.waitForIdle()

        
        onView(withText(taskTitle)).perform(click())
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(allOf(withId(R.id.complete_checkbox), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }

    @Test
    fun createTask() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        onView(withId(R.id.add_task_fab)).perform(click())
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        onView(withText("title")).check(matches(isDisplayed()))
    }

    private fun findTextField(textId: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(textId))
        )
    }

    private fun findTextField(text: String): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(text)
        )
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.Gravity
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.contrib.NavigationViewActions.navigateTo
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private lateinit var tasksRepository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @get:Rule
    val composeTestRule = createAndroidComposeRule<TasksActivity>()
    private val activity get() = composeTestRule.activity

    @Before
    fun init() {
        tasksRepository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun drawerNavigationFromTasksToStatistics() {
        
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.statistics_fragment_dest))

        
        composeTestRule.onNodeWithText("You have no tasks.").assertIsDisplayed()
        composeTestRule.waitForIdle()

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.tasks_fragment_dest))

        
        onView(withId(R.id.tasks_container_layout)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        
        composeTestRule.activityRule.scenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statistics_fragment_dest)
        }
        composeTestRule.waitForIdle()

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        val task = Task("UI <- button", "Description")
        tasksRepository.saveTaskBlocking(task)
        composeTestRule.waitForIdle()

        
        onView(withText("UI <- button")).perform(click())
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())
        composeTestRule.onNodeWithText("UI <- button").assertIsDisplayed()

        
        onView(
            withContentDescription(
                composeTestRule.activityRule.scenario.getToolbarNavigationContentDescription()
            )
        ).perform(click())
        onView(withId(R.id.tasks_container_layout)).check(matches(isDisplayed()))
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        dataBindingIdlingResource.monitorActivity(composeTestRule.activityRule.scenario)

        val task = Task("Back button", "Description")
        tasksRepository.saveTaskBlocking(task)
        composeTestRule.waitForIdle()

        
        onView(withText("Back button")).perform(click())
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        pressBack()
        composeTestRule.onNodeWithText("Back button").assertIsDisplayed()

        
        pressBack()
        onView(withId(R.id.tasks_container_layout)).check(matches(isDisplayed()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.graphics.Paint
import android.widget.TextView
import androidx.databinding.BindingAdapter
import androidx.recyclerview.widget.RecyclerView
import com.example.android.architecture.blueprints.todoapp.data.Task


@BindingAdapter("app:items")
fun setItems(listView: RecyclerView, items: List<Task>?) {
    items?.let {
        (listView.adapter as TasksAdapter).submitList(items)
    }
}

@BindingAdapter("app:completedTask")
fun setStyle(textView: TextView, enabled: Boolean) {
    if (enabled) {
        textView.paintFlags = textView.paintFlags or Paint.STRIKE_THRU_TEXT_FLAG
    } else {
        textView.paintFlags = textView.paintFlags and Paint.STRIKE_THRU_TEXT_FLAG.inv()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getViewModelFactory() }

    private val args: TasksFragmentArgs by navArgs()

    private lateinit var viewDataBinding: TasksFragBinding

    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()
    }

    private fun setupNavigation() {
        viewModel.openTaskEvent.observe(
            viewLifecycleOwner,
            EventObserver {
                openTaskDetails(it)
            }
        )
        viewModel.newTaskEvent.observe(
            viewLifecycleOwner,
            EventObserver {
                navigateToAddNewTask()
            }
        )
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(viewLifecycleOwner, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                true
            }
            show()
        }
    }

    
    private fun setupFab() {
        requireView().findViewById<FloatingActionButton>(R.id.add_task_fab)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.distinctUntilChanged
import androidx.lifecycle.switchMap
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import kotlinx.coroutines.launch


class TasksViewModel(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _forceUpdate = MutableLiveData<Boolean>(false)

    private val _items: LiveData<List<Task>> = _forceUpdate.switchMap { forceUpdate ->
        if (forceUpdate) {
            _dataLoading.value = true
            viewModelScope.launch {
                tasksRepository.refreshTasks()
                _dataLoading.value = false
            }
        }
        tasksRepository.observeTasks().distinctUntilChanged().switchMap { filterTasks(it) }
    }

    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarText: LiveData<Event<Int>> = _snackbarText

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    private var resultMessageShown: Boolean = false

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(getSavedFilterType())
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle.set(TASKS_FILTER_SAVED_STATE_KEY, requestType)

        
        when (requestType) {
            ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
        
        loadTasks(false)
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int,
        @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int,
        tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        if (resultMessageShown) return
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
        resultMessageShown = true
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    private fun filterTasks(tasksResult: Result<List<Task>>): LiveData<List<Task>> {
        
        val result = MutableLiveData<List<Task>>()

        if (tasksResult is Success) {
            isDataLoadingError.value = false
            viewModelScope.launch {
                result.value = filterItems(tasksResult.data, getSavedFilterType())
            }
        } else {
            result.value = emptyList()
            showSnackbarMessage(R.string.loading_tasks_error)
            isDataLoadingError.value = true
        }

        return result
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _forceUpdate.value = forceUpdate
    }

    private fun filterItems(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    fun refresh() {
        _forceUpdate.value = true
    }

    private fun getSavedFilterType(): TasksFilterType {
        return savedStateHandle.get(TASKS_FILTER_SAVED_STATE_KEY) ?: ALL_TASKS
    }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TaskItemBinding
import com.example.android.architecture.blueprints.todoapp.tasks.TasksAdapter.ViewHolder


class TasksAdapter(private val viewModel: TasksViewModel) :
    ListAdapter<Task, ViewHolder>(TaskDiffCallback()) {

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val item = getItem(position)

        holder.bind(viewModel, item)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        return ViewHolder.from(parent)
    }

    class ViewHolder private constructor(val binding: TaskItemBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(viewModel: TasksViewModel, item: Task) {

            binding.viewmodel = viewModel
            binding.task = item
            binding.executePendingBindings()
        }

        companion object {
            fun from(parent: ViewGroup): ViewHolder {
                val layoutInflater = LayoutInflater.from(parent.context)
                val binding = TaskItemBinding.inflate(layoutInflater, parent, false)

                return ViewHolder(binding)
            }
        }
    }
}


class TaskDiffCallback : DiffUtil.ItemCallback<Task>() {
    override fun areItemsTheSame(oldItem: Task, newItem: Task): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: Task, newItem: Task): Boolean {
        return oldItem == newItem
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertLiveDataEventTriggered
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.getOrAwaitValue
import com.example.android.architecture.blueprints.todoapp.observeForTesting
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository, SavedStateHandle())
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() {
        
        mainCoroutineRule.pauseDispatcher()

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isTrue()

            
            mainCoroutineRule.resumeDispatcher()

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).hasSize(3)
        }
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).hasSize(1)
        }
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).hasSize(2)
        }
    }

    @Test
    fun loadTasks_error() {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.loadTasks(true)
        
        tasksViewModel.items.observeForTesting {

            
            assertThat(tasksViewModel.dataLoading.getOrAwaitValue()).isFalse()

            
            assertThat(tasksViewModel.items.getOrAwaitValue()).isEmpty()

            
            assertSnackbarMessage(tasksViewModel.snackbarText, R.string.loading_tasks_error)
        }
    }

    @Test
    fun clickOnFab_showsAddTaskUi() {
        
        tasksViewModel.addNewTask()

        
        val value = tasksViewModel.newTaskEvent.getOrAwaitValue()
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun clickOnOpenTask_setsEvent() {
        
        val taskId = "42"
        tasksViewModel.openTask(taskId)

        
        assertLiveDataEventTriggered(tasksViewModel.openTaskEvent, taskId)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = mainCoroutineRule.runBlockingTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.loadTasks(true)

        
        val allTasks = tasksViewModel.items.getOrAwaitValue()
        val completedTasks = allTasks.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.completed_tasks_cleared
        )
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.successfully_saved_task_message
        )
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.successfully_added_task_message
        )
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertSnackbarMessage(tasksViewModel.snackbarText, R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.task_marked_complete
        )
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isActive).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.task_marked_active
        )
    }

    @Test
    fun getTasksAddViewVisible() {
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        assertThat(tasksViewModel.tasksAddViewVisible.getOrAwaitValue()).isTrue()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.activity.ComponentActivity
import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.navigation.Navigation.findNavController
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import com.google.accompanist.appcompattheme.AppCompatTheme
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class AddEditTaskScreenTest {

    @get:Rule
    val composeTestRule = createAndroidComposeRule<ComponentActivity>()

    private val activity by lazy { composeTestRule.activity }
    private val repository = FakeRepository()

    @Before
    fun setup() {
        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository),
                        taskId = null,
                        onTaskUpdate = { }
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = (repository.getTasksBlocking(true) as Result.Success).data
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.View
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.Navigation
import androidx.navigation.testing.TestNavHostController
import androidx.recyclerview.widget.RecyclerView
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ActivityScenario.launch
import androidx.test.core.app.ApplicationProvider
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.id
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import junit.framework.Assert.assertEquals
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Matcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
@ExperimentalCoroutinesApi
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlockingTest {
        ServiceLocator.resetRepository()
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        
        launchActivity()

        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchActivity()

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        launchActivity()

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launchActivity()

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launchActivity()

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(doesNotExist())
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launchActivity()

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(matches(isDisplayed()))
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launchActivity()

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(R.string.menu_clear)).perform(click())

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())

        
        onView(withText("You have no tasks!")).check(matches(isDisplayed()))
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        
        onView(withText("You have no completed tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        launchActivity()

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())

        
        onView(withText("You have no active tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = TestNavHostController(ApplicationProvider.getApplicationContext())
        scenario.onFragment {
            navController.setGraph(R.navigation.nav_graph)
            navController.setCurrentDestination(R.id.tasks_fragment_dest)
            Navigation.setViewNavController(it.requireView(), navController)
        }

        
        onView(withId(R.id.add_task_fab)).perform(click())

        
        assertEquals(navController.currentDestination?.id, id.add_edit_task_fragment_dest)
    }

    private fun launchActivity(): ActivityScenario<TasksActivity>? {
        val activityScenario = launch(TasksActivity::class.java)
        activityScenario.onActivity { activity ->
            
            (activity.findViewById(R.id.tasks_list) as RecyclerView).itemAnimator = null
        }
        return activityScenario
    }

    private fun checkboxWithText(text: String): Matcher<View> {
        return allOf(withId(R.id.complete_checkbox), hasSibling(withText(text)))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import kotlinx.coroutines.launch


class StatisticsViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _error = MutableLiveData<Boolean>()
    val error: LiveData<Boolean> = _error

    
    private val _empty = MutableLiveData<Boolean>()
    val empty: LiveData<Boolean> = _empty

    private val _activeTasksPercent = MutableLiveData<Float>()
    val activeTasksPercent: LiveData<Float> = _activeTasksPercent

    private val _completedTasksPercent = MutableLiveData<Float>()
    val completedTasksPercent: LiveData<Float> = _completedTasksPercent

    private var activeTasks = 0

    private var completedTasks = 0

    fun start() {
        _dataLoading.value = true

        
        
        EspressoIdlingResource.increment() 

        viewModelScope.launch {
            tasksRepository.getTasks().let { result ->
                if (result is Success) {
                    _error.value = false
                    computeStats(result.data)
                } else {
                    _error.value = true
                    activeTasks = 0
                    completedTasks = 0
                    computeStats(null)
                }
            }
        }
    }

    
    private fun computeStats(tasks: List<Task>?) {
        getActiveAndCompletedStats(tasks).let {
            _activeTasksPercent.value = it.activeTasksPercent
            _completedTasksPercent.value = it.completedTasksPercent
        }
        _empty.value = tasks.isNullOrEmpty()
        _dataLoading.value = false
        EspressoIdlingResource.decrement() 
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.Matchers.allOf
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private lateinit var repository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.deleteAllTasksBlocking()
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun createTask() {
        
        

        
        

        
        
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("TITLE1")).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(withText("TITLE1")))
        onView(withId(R.id.task_detail_description)).check(matches(withText("DESCRIPTION")))
        onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))

        
        onView(withId(R.id.fab_edit_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(replaceText("NEW TITLE"))
        onView(withId(R.id.add_task_description)).perform(replaceText("NEW DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("NEW TITLE")).check(matches(isDisplayed()))
        
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE1"), closeSoftKeyboard())
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("TITLE2")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMPLETED"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACTIVE"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACT-COMP"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMP-ACT"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }

    @Test
    fun createTask_solution() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("title"), closeSoftKeyboard())
        onView(withId(R.id.add_task_description)).perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("title")).check(matches(isDisplayed()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.contrib.NavigationViewActions.navigateTo
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private lateinit var tasksRepository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        tasksRepository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun drawerNavigationFromTasksToStatistics() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.statisticsFragment))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.tasksFragment))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        val task = Task("UI <- button", "Description")
        tasksRepository.saveTaskBlocking(task)

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("UI <- button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        val task = Task("Back button", "Description")
        tasksRepository.saveTaskBlocking(task)

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("Back button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        pressBack()
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        pressBack()
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class StatisticsViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _error = MutableLiveData<Boolean>()
    val error: LiveData<Boolean> = _error

    
    private val _empty = MutableLiveData<Boolean>()
    val empty: LiveData<Boolean> = _empty

    private val _activeTasksPercent = MutableLiveData<Float>()
    val activeTasksPercent: LiveData<Float> = _activeTasksPercent

    private val _completedTasksPercent = MutableLiveData<Float>()
    val completedTasksPercent: LiveData<Float> = _completedTasksPercent

    private var activeTasks = 0

    private var completedTasks = 0

    fun start() {
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTasks().let { result ->
                if (result is Success) {
                    _error.value = false
                    computeStats(result.data)
                } else {
                    _error.value = true
                    activeTasks = 0
                    completedTasks = 0
                    computeStats(null)
                }
            }
        }
    }

    
    private fun computeStats(tasks: List<Task>?) {
        getActiveAndCompletedStats(tasks).let {
            _activeTasksPercent.value = it.activeTasksPercent
            _completedTasksPercent.value = it.completedTasksPercent
        }
        _empty.value = tasks.isNullOrEmpty()
        _dataLoading.value = false
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.Matchers.allOf
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private lateinit var repository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.deleteAllTasksBlocking()
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun createTask() {
        
        

        
        

        
        
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("TITLE1")).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(withText("TITLE1")))
        onView(withId(R.id.task_detail_description)).check(matches(withText("DESCRIPTION")))
        onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))

        
        onView(withId(R.id.fab_edit_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(replaceText("NEW TITLE"))
        onView(withId(R.id.add_task_description)).perform(replaceText("NEW DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("NEW TITLE")).check(matches(isDisplayed()))
        
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE1"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("TITLE2")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMPLETED"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACTIVE"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACT-COMP"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMP-ACT"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }

    @Test
    fun createTask_solution() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("title"))
        onView(withId(R.id.add_task_description)).perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("title")).check(matches(isDisplayed()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.contrib.NavigationViewActions.navigateTo
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private lateinit var tasksRepository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        tasksRepository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun drawNavigationFromTasksToStatistics() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.statisticsFragment))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.tasksFragment))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        val task = Task("UI <- button", "Description")
        tasksRepository.saveTaskBlocking(task)

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("UI <- button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        val task = Task("Back button", "Description")
        tasksRepository.saveTaskBlocking(task)

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("Back button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        pressBack()
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        pressBack()
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Intent
import android.os.Bundle
import android.view.MenuItem
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.GravityCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.lifecycle.Observer
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskActivity
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsActivity
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailActivity
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.replaceFragmentInActivity
import com.example.android.architecture.blueprints.todoapp.util.setupActionBar
import com.google.android.material.navigation.NavigationView


class TasksActivity : AppCompatActivity(), TaskItemNavigator, TasksNavigator {

    private lateinit var drawerLayout: DrawerLayout

    private lateinit var viewModel: TasksViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.tasks_act)

        setupActionBar(R.id.toolbar) {
            setHomeAsUpIndicator(R.drawable.ic_menu)
            setDisplayHomeAsUpEnabled(true)
        }

        setupNavigationDrawer()

        setupViewFragment()

        viewModel = obtainViewModel().apply {
            openTaskEvent.observe(this@TasksActivity, Observer<Event<String>> { event ->
                event.getContentIfNotHandled()?.let {
                    openTaskDetails(it)

                }
            })
            
            newTaskEvent.observe(this@TasksActivity, Observer<Event<Unit>> { event ->
                event.getContentIfNotHandled()?.let {
                    this@TasksActivity.addNewTask()
                }
            })
        }
        viewModel.loadTasks(true)
    }

    private fun setupViewFragment() {
        supportFragmentManager.findFragmentById(R.id.contentFrame)
            ?: replaceFragmentInActivity(TasksFragment.newInstance(), R.id.contentFrame)
    }

    private fun setupNavigationDrawer() {
        drawerLayout = (findViewById<DrawerLayout>(R.id.drawer_layout))
            .apply {
                setStatusBarBackground(R.color.colorPrimaryDark)
            }
        setupDrawerContent(findViewById(R.id.nav_view))
    }

    override fun onOptionsItemSelected(item: MenuItem) =
            when (item.itemId) {
                android.R.id.home -> {
                    
                    drawerLayout.openDrawer(GravityCompat.START)
                    true
                }
                else -> super.onOptionsItemSelected(item)
            }

    private fun setupDrawerContent(navigationView: NavigationView) {
        navigationView.setNavigationItemSelectedListener { menuItem ->
            when (menuItem.itemId) {
                R.id.list_navigation_menu_item -> {
                    
                }
                R.id.statistics_navigation_menu_item -> {
                    val intent = Intent(this@TasksActivity, StatisticsActivity::class.java).apply {
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
                    }
                    startActivity(intent)
                }
            }
            
            menuItem.isChecked = true
            drawerLayout.closeDrawers()
            true
        }
    }

    public override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        viewModel.handleActivityResult(requestCode, resultCode)
    }

    override fun openTaskDetails(taskId: String) {
        val intent = Intent(this, TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, taskId)
        }
        startActivityForResult(intent, AddEditTaskActivity.REQUEST_CODE)

    }

    override fun addNewTask() {
        val intent = Intent(this, AddEditTaskActivity::class.java)
        startActivityForResult(intent, AddEditTaskActivity.REQUEST_CODE)
    }

    fun obtainViewModel(): TasksViewModel = obtainViewModel(TasksViewModel::class.java)
}
<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith

import org.robolectric.annotation.Config


@RunWith(AndroidJUnit4::class)
@Ignore("blocked on robolectric issue #4810")
class TasksSingleScreenTest {

    @Before
    fun clearTaskRepository() {
        
        ServiceLocator.provideTasksRepository(ApplicationProvider.getApplicationContext()).apply {
            runBlocking {
                deleteAllTasks()
            }
        }
    }

    @Test
    fun displayActiveTask() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION1).apply {
          isCompleted = true
        })

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTest() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun deleteOneOfTwoTests() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION1))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION2))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
        
        onView(withText(TITLE2)).check(matches(isDisplayed()))
    }

    private fun viewAllTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_all)).perform(ViewActions.click())
    }

    private fun viewActiveTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_active)).perform(ViewActions.click())
    }

    private fun viewCompletedTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_completed)).perform(ViewActions.click())
    }

    companion object {

        const val TITLE1 = "TITLE1"
        const val TITLE2 = "TITLE2"
        const val TITLE3 = "TITLE3"

        const val DESCRIPTION1 = "DESCRIPTION1"
        const val DESCRIPTION2 = "DESCRIPTION2"
        const val DESCRIPTION3 = "DESCRIPTION3"
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.content.Intent
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class TaskDetailScreenTest {

    private lateinit var activityScenario : ActivityScenario<TaskDetailActivity>

    @Before
    fun clearTaskRepository() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            runBlocking {
                deleteAllTasks()
            }
        }
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        FakeTasksRemoteDataSource.addTasks(ACTIVE_TASK)

        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, ACTIVE_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
        }
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        FakeTasksRemoteDataSource.addTasks(COMPLETED_TASK)

        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, COMPLETED_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
        }
    }

    @Test
    fun orientationChange_menuAndTaskPersist() {
        FakeTasksRemoteDataSource.addTasks(ACTIVE_TASK)

        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, ACTIVE_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.menu_delete)).check(matches(isDisplayed()))

            it.rotateOrientation()

            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
            
            onView(withId(R.id.menu_delete)).check(matches(isDisplayed()))
        }
    }

    companion object {

        private val TASK_TITLE = "AndroidX Test"

        private val TASK_DESCRIPTION = "Rocks"

        
        private val ACTIVE_TASK = Task(TASK_TITLE, TASK_DESCRIPTION).apply {
            isCompleted = false
        }

        
        private val COMPLETED_TASK = Task(TASK_TITLE, TASK_DESCRIPTION).apply {
            isCompleted = true
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.test.core.app.ActivityScenario
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.filters.LargeTest
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.custom.action.NavigationViewActions.navigateTo
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsActivity
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }

    @Test
    fun clickOnStatisticsNavigationItem_ShowsStatisticsScreen() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view)).perform(navigateTo(R.id.statistics_navigation_menu_item))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))
    }

    @Test
    fun clickOnListNavigationItem_ShowsListScreen() {
        
        val activityScenario = ActivityScenario.launch(StatisticsActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.list_navigation_menu_item))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(StatisticsActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.appcompat.widget.Toolbar
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.filters.SdkSuppress

import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.currentActivity
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksScreenTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    
    @UiThreadTest
    @Before
    fun resetState() = runBlocking {
        (getApplicationContext() as TodoApplication).taskRepository.deleteAllTasks()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    private fun ActivityScenario<TasksActivity>.getToolbarNavigationContentDescription() : String {
        var description = ""
        onActivity {
            description = it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_opensAddTaskUi() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun addTaskToTasksList() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsComplete() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE3, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        FakeTasksRemoteDataSource.addTasks(Task(TITLE3, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        FakeTasksRemoteDataSource.addTasks(Task(TITLE2, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription())).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription())).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION))
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription()))
            .perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        onView(withContentDescription(activityScenario.getToolbarNavigationContentDescription())).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun orientationChange_FilterActivePersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()

        
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun orientationChange_FilterCompletedPersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(string.label_completed)).check(matches(isDisplayed()))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_ChangePersists() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 

        
        currentActivity.rotateOrientation()

        
        onView(withId(R.id.add_task_title)).check(matches(withText(TITLE2)))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_NoDuplicate() {
        
        FakeTasksRemoteDataSource.addTasks(Task(TITLE1, DESCRIPTION).apply {
            isCompleted = true
        })
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        activityScenario.onActivity {
            it.rotateOrientation()
        }

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(DESCRIPTION),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewAllTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewCompletedTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        viewActiveTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Intent
import android.os.Bundle
import android.view.MenuItem
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.GravityCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.lifecycle.Observer
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskActivity
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsActivity
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailActivity
import com.example.android.architecture.blueprints.todoapp.util.obtainViewModel
import com.example.android.architecture.blueprints.todoapp.util.replaceFragmentInActivity
import com.example.android.architecture.blueprints.todoapp.util.setupActionBar
import com.google.android.material.navigation.NavigationView


class TasksActivity : AppCompatActivity(), TaskItemNavigator, TasksNavigator {

    private lateinit var drawerLayout: DrawerLayout

    private lateinit var viewModel: TasksViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.tasks_act)

        setupActionBar(R.id.toolbar) {
            setHomeAsUpIndicator(R.drawable.ic_menu)
            setDisplayHomeAsUpEnabled(true)
        }

        setupNavigationDrawer()

        setupViewFragment()

        viewModel = obtainViewModel().apply {
            openTaskEvent.observe(this@TasksActivity, Observer<Event<String>> { event ->
                event.getContentIfNotHandled()?.let {
                    openTaskDetails(it)

                }
            })
            
            newTaskEvent.observe(this@TasksActivity, Observer<Event<Unit>> { event ->
                event.getContentIfNotHandled()?.let {
                    this@TasksActivity.addNewTask()
                }
            })
        }
    }

    private fun setupViewFragment() {
        supportFragmentManager.findFragmentById(R.id.contentFrame)
            ?: replaceFragmentInActivity(TasksFragment.newInstance(), R.id.contentFrame)
    }

    private fun setupNavigationDrawer() {
        drawerLayout = (findViewById<DrawerLayout>(R.id.drawer_layout))
            .apply {
                setStatusBarBackground(R.color.colorPrimaryDark)
            }
        setupDrawerContent(findViewById(R.id.nav_view))
    }

    override fun onOptionsItemSelected(item: MenuItem) =
            when (item.itemId) {
                android.R.id.home -> {
                    
                    drawerLayout.openDrawer(GravityCompat.START)
                    true
                }
                else -> super.onOptionsItemSelected(item)
            }

    private fun setupDrawerContent(navigationView: NavigationView) {
        navigationView.setNavigationItemSelectedListener { menuItem ->
            when (menuItem.itemId) {
                R.id.list_navigation_menu_item -> {
                    
                }
                R.id.statistics_navigation_menu_item -> {
                    val intent = Intent(this@TasksActivity, StatisticsActivity::class.java).apply {
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
                    }
                    startActivity(intent)
                }
            }
            
            menuItem.isChecked = true
            drawerLayout.closeDrawers()
            true
        }
    }

    public override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        viewModel.handleActivityResult(requestCode, resultCode)
    }

    override fun openTaskDetails(taskId: String) {
        val intent = Intent(this, TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, taskId)
        }
        startActivityForResult(intent, AddEditTaskActivity.REQUEST_CODE)

    }

    override fun addNewTask() {
        val intent = Intent(this, AddEditTaskActivity::class.java)
        startActivityForResult(intent, AddEditTaskActivity.REQUEST_CODE)
    }

    fun obtainViewModel(): TasksViewModel = obtainViewModel(TasksViewModel::class.java)
}
<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.content.Intent
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class TaskDetailScreenTest {

    private lateinit var activityScenario : ActivityScenario<TaskDetailActivity>

    @Before
    fun clearTaskRepository() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            runBlocking {
                deleteAllTasks()
            }
        }
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        FakeTasksRemoteDataSource.addTasks(ACTIVE_TASK)

        
        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, ACTIVE_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
        }
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        FakeTasksRemoteDataSource.addTasks(COMPLETED_TASK)

        
        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, COMPLETED_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
        }
    }

    @Test
    fun orientationChange_menuAndTaskPersist() {
        FakeTasksRemoteDataSource.addTasks(ACTIVE_TASK)

        
        val startIntent = Intent(getApplicationContext(),
            TaskDetailActivity::class.java).apply {
            putExtra(TaskDetailActivity.EXTRA_TASK_ID, ACTIVE_TASK.id)
        }

        activityScenario = ActivityScenario.launch(startIntent)

        activityScenario.onActivity {
            
            onView(withId(R.id.menu_delete)).check(matches(isDisplayed()))

            it.rotateOrientation()

            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText(TASK_TITLE)))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText(TASK_DESCRIPTION)))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
            
            onView(withId(R.id.menu_delete)).check(matches(isDisplayed()))
        }
    }

    companion object {

        private val TASK_TITLE = "AndroidX Test"

        private val TASK_DESCRIPTION = "Rocks"

        
        private val ACTIVE_TASK = Task(TASK_TITLE, TASK_DESCRIPTION).apply {
            isCompleted = false
        }

        
        private val COMPLETED_TASK = Task(TASK_TITLE, TASK_DESCRIPTION).apply {
            isCompleted = true
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.Gravity
import androidx.drawerlayout.widget.DrawerLayout
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.filters.LargeTest
import androidx.test.rule.ActivityTestRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.custom.action.NavigationViewActions.navigateTo
import com.example.android.architecture.blueprints.todoapp.getToolbarNavigationContentDescription
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    
    @get:Rule var activityTestRule = ActivityTestRule(TasksActivity::class.java)

    @Test
    fun clickOnStatisticsNavigationItem_ShowsStatisticsScreen() {
        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view)).perform(navigateTo(R.id.statistics_navigation_menu_item))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))
    }

    @Test
    fun clickOnListNavigationItem_ShowsListScreen() {
        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.statistics_navigation_menu_item))

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.list_navigation_menu_item))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun clickOnAndroidHomeIcon_OpensNavigation() {
        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityTestRule.activity
                    .getToolbarNavigationContentDescription(R.id.toolbar)
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.filters.SdkSuppress
import androidx.test.rule.ActivityTestRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.currentActivity
import com.example.android.architecture.blueprints.todoapp.getToolbarNavigationContentDescription
import com.example.android.architecture.blueprints.todoapp.util.rotateOrientation
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksScreenTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val DESCRIPTION = "DESCR"

    
    @Rule @JvmField var tasksActivityTestRule =
        ActivityTestRule<TasksActivity>(TasksActivity::class.java)

    
    @UiThreadTest
    @Before
    fun resetState() = runBlocking {
        (getApplicationContext() as TodoApplication).taskRepository.deleteAllTasks()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    private val toolbarNavigationContentDescription: String
        get() = tasksActivityTestRule.activity.getToolbarNavigationContentDescription(R.id.toolbar)

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_opensAddTaskUi() {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun addTaskToTasksList() {
        createTask(TITLE1, DESCRIPTION)

        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsComplete() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsActive() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)
        clickCheckBoxForTask(TITLE1)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun showAllTasks() {
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    @Test
    fun showActiveTasks() {
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    @Test
    fun showCompletedTasks() {
        
        createTask(TITLE1, DESCRIPTION)
        clickCheckBoxForTask(TITLE1)
        createTask(TITLE2, DESCRIPTION)
        clickCheckBoxForTask(TITLE2)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    @Test
    fun clearCompletedTasks() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)
        clickCheckBoxForTask(TITLE1)
        createTask(TITLE2, DESCRIPTION)
        clickCheckBoxForTask(TITLE2)

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        onView(withItemText(TITLE2)).check(matches(not(isDisplayed())))
    }

    @Test
    fun createOneTask_deleteTask() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(toolbarNavigationContentDescription)).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)
        clickCheckBoxForTask(TITLE1)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(toolbarNavigationContentDescription)).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsAcompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(toolbarNavigationContentDescription)).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)
        clickCheckBoxForTask(TITLE1)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withContentDescription(toolbarNavigationContentDescription)).perform(click())

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun orientationChange_FilterActivePersists() {

        
        createTask(TITLE1, DESCRIPTION)
        clickCheckBoxForTask(TITLE1)

        
        viewActiveTasks()

        
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        
        tasksActivityTestRule.activity.rotateOrientation()

        
        onView(withText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun orientationChange_FilterCompletedPersists() {

        
        createTask(TITLE1, DESCRIPTION)
        clickCheckBoxForTask(TITLE1)

        
        viewCompletedTasks()

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        
        tasksActivityTestRule.activity.rotateOrientation()

        
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(string.label_completed)).check(matches(isDisplayed()))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_ChangePersists() {
        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 

        
        currentActivity.rotateOrientation()

        
        onView(withId(R.id.add_task_title)).check(matches(withText(TITLE2)))
    }

    
    @Test
    @SdkSuppress(minSdkVersion = 21)
    fun orientationChange_DuringEdit_NoDuplicate() {
        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        currentActivity.rotateOrientation()

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(TITLE2), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(DESCRIPTION),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())

        
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        
        viewAllTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(isDisplayed()))
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        
        viewCompletedTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        
        viewActiveTasks()

        
        onView(withId(R.id.noTasksAdd)).check(matches(not(isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_edit_task_done)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }

    private fun getText(stringId: Int) =
        tasksActivityTestRule.activity.resources.getString(stringId)
}
<code block>

package com.example.android.architecture.blueprints.todoapp.util



import androidx.fragment.app.Fragment
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.ViewModelFactory

fun Fragment.getViewModelFactory(): ViewModelFactory {
    val repository = (requireContext().applicationContext as TodoApplication).taskRepository
    return ViewModelFactory(repository)
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val viewModel by viewModels<StatisticsViewModel> { getViewModelFactory() }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = DataBindingUtil.inflate(
            inflater, R.layout.statistics_frag, container,
            false
        )
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.viewmodel = viewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        viewModel.start()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarText: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdatedEvent = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdatedEvent

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        if (_dataLoading.value == true) {
            return
        }

        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }

        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value = Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription).isEmpty) {
            _snackbarText.value = Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, taskCompleted, currentTaskId)
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) = viewModelScope.launch {
        tasksRepository.saveTask(newTask)
        _taskUpdatedEvent.value = Event(Unit)
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdatedEvent.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    private val args: AddEditTaskFragmentArgs by navArgs()

    private val viewModel by viewModels<AddEditTaskViewModel> {
        getViewModelFactory()
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            this.viewmodel = viewModel
        }
        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupSnackbar()
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        viewModel.start(args.taskId)
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
    }

    private fun setupNavigation() {
        viewModel.taskUpdatedEvent.observe(this, EventObserver {
            val action = AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
            findNavController().navigate(action)
        })
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getViewModelFactory() }

    private val args: TasksFragmentArgs by navArgs()

    private lateinit var viewDataBinding: TasksFragBinding

    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()

        
        
        viewModel.loadTasks(true)
    }

    private fun setupNavigation() {
        viewModel.openTaskEvent.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewModel.newTaskEvent.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                viewModel.loadTasks(false)
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarText: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
        
        loadTasks(false)
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                val tasksResult = tasksRepository.getTasks(forceUpdate)

                if (tasksResult is Success) {
                    val tasks = tasksResult.data

                    val tasksToShow = ArrayList<Task>()
                    
                    for (task in tasks) {
                        when (_currentFiltering) {
                            TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                            TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                                tasksToShow.add(task)
                            }
                            TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                                tasksToShow.add(task)
                            }
                        }
                    }
                    isDataLoadingError.value = false
                    _items.value = ArrayList(tasksToShow)
                } else {
                    isDataLoadingError.value = false
                    _items.value = emptyList()
                    showSnackbarMessage(R.string.loading_tasks_error)
                }

                _dataLoading.value = false
            }
        }
    }

    fun refresh() {
        loadTasks(true)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getViewModelFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {
    private lateinit var viewDataBinding: TaskdetailFragBinding

    private val args: TaskDetailFragmentArgs by navArgs()

    private val viewModel by viewModels<TaskDetailViewModel> { getViewModelFactory() }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        view?.setupSnackbar(this, viewModel.snackbarText, Snackbar.LENGTH_SHORT)
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }

    private fun setupNavigation() {
        viewModel.deleteTaskEvent.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToTasksFragment(DELETE_RESULT_OK)
            findNavController().navigate(action)
        })
        viewModel.editTaskEvent.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToAddEditTaskFragment(
                    args.taskId,
                    resources.getString(R.string.edit_task)
                )
            findNavController().navigate(action)
        })
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.fab_edit_task)?.setOnClickListener {
            viewModel.editTask()
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = viewModel
        }
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner

        viewModel.start(args.taskId)

        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewModel.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _task = MutableLiveData<Task>()
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskEvent = MutableLiveData<Event<Unit>>()
    val editTaskEvent: LiveData<Event<Unit>> = _editTaskEvent

    private val _deleteTaskEvent = MutableLiveData<Event<Unit>>()
    val deleteTaskEvent: LiveData<Event<Unit>> = _deleteTaskEvent

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarText: LiveData<Event<Int>> = _snackbarText

    private val taskId: String?
        get() = _task.value?.id

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }


    fun deleteTask() = viewModelScope.launch {
        taskId?.let {
            tasksRepository.deleteTask(it)
            _deleteTaskEvent.value = Event(Unit)
        }
    }

    fun editTask() {
        _editTaskEvent.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = _task.value ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun start(taskId: String?, forceRefresh: Boolean = false) {
        if (_isDataAvailable.value == true && !forceRefresh || _dataLoading.value == true) {
            return
        }

        
        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                if (taskId != null) {
                    tasksRepository.getTask(taskId, false).let { result ->
                        if (result is Success) {
                            onTaskLoaded(result.data)
                        } else {
                            onDataNotAvailable(result)
                        }
                    }
                }
                _dataLoading.value = false
            }
        }
    }

    private fun setTask(task: Task?) {
        this._task.value = task
        _isDataAvailable.value = task != null
    }

    private fun onTaskLoaded(task: Task) {
        setTask(task)
    }

    private fun onDataNotAvailable(result: Result<Task>) {
        _task.value = null
        _isDataAvailable.value = false
    }

    fun refresh() {
        taskId?.let { start(it, true) }
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil.getValue
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class AddEditTaskViewModelTest {

    
    private lateinit var addEditTaskViewModel: AddEditTaskViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    private val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()

        
        addEditTaskViewModel = AddEditTaskViewModel(tasksRepository)
    }

    @Test
    fun saveNewTaskToRepository_showsSuccessMessageUi() {
        val newTitle = "New Task Title"
        val newDescription = "Some Task Description"
        (addEditTaskViewModel).apply {
            title.value = newTitle
            description.value = newDescription
        }
        addEditTaskViewModel.saveTask()

        val newTask = tasksRepository.tasksServiceData.values.first()

        
        assertThat(newTask.title).isEqualTo(newTitle)
        assertThat(newTask.description).isEqualTo(newDescription)
    }

    @Test
    fun loadTasks_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isFalse()
    }

    @Test
    fun loadTasks_taskShown() {
        
        tasksRepository.addTasks(task)

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(getValue(addEditTaskViewModel.title)).isEqualTo(task.title)
        assertThat(getValue(addEditTaskViewModel.description)).isEqualTo(task.description)
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isFalse()
    }

    @Test
    fun saveNewTaskToRepository_emptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_nullTitle_error() {
        saveTaskAndAssertSnackbarError(null, "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescription_error() {
        saveTaskAndAssertSnackbarError("Title", "")
    }

    @Test
    fun saveNewTaskToRepository_nullDescription_error() {
        saveTaskAndAssertSnackbarError("Title", null)
    }

    @Test
    fun saveNewTaskToRepository_nullDescriptionNullTitle_error() {
        saveTaskAndAssertSnackbarError(null, null)
    }

    @Test
    fun saveNewTaskToRepository_emptyDescriptionEmptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "")
    }

    private fun saveTaskAndAssertSnackbarError(title: String?, description: String?) {
        (addEditTaskViewModel).apply {
            this.title.value = title
            this.description.value = description
        }

        
        addEditTaskViewModel.saveTask()

        
        assertSnackbarMessage(addEditTaskViewModel.snackbarText, string.empty_task_message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertLiveDataEventTriggered
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository)
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() {
        
        mainCoroutineRule.pauseDispatcher()

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(2)
    }

    @Test
    fun loadTasks_error() {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).isEmpty()

        
        assertSnackbarMessage(tasksViewModel.snackbarText, R.string.loading_tasks_error)
    }

    @Test
    fun clickOnFab_showsAddTaskUi() {
        
        tasksViewModel.addNewTask()

        
        val value = LiveDataTestUtil.getValue(tasksViewModel.newTaskEvent)
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun clickOnOpenTask_setsEvent() {
        
        val taskId = "42"
        tasksViewModel.openTask(taskId)

        
        assertLiveDataEventTriggered(tasksViewModel.openTaskEvent, taskId)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = mainCoroutineRule.runBlockingTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.loadTasks(true)

        
        val allTasks = LiveDataTestUtil.getValue(tasksViewModel.items)
        val completedTasks = allTasks.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.completed_tasks_cleared
        )
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.successfully_saved_task_message
        )
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.successfully_added_task_message
        )
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.successfully_deleted_task_message
        )
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.task_marked_complete
        )
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isActive).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarText, R.string.task_marked_active
        )
    }

    @Test
    fun getTasksAddViewVisible() {
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.tasksAddViewVisible)).isTrue()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil.getValue
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(tasksRepository)
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() {
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.task).title).isEqualTo(task.title)
        assertThat(getValue(taskDetailViewModel.task).description)
            .isEqualTo(task.description)
    }

    @Test
    fun completeTask() {
        taskDetailViewModel.start(task.id)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isFalse()

        
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()
        assertSnackbarMessage(taskDetailViewModel.snackbarText, R.string.task_marked_complete)
    }

    @Test
    fun activateTask() {
        task.isCompleted = true

        taskDetailViewModel.start(task.id)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        taskDetailViewModel.setCompleted(false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isFalse()
        assertSnackbarMessage(taskDetailViewModel.snackbarText, R.string.task_marked_active)

    }

    @Test
    fun taskDetailViewModel_repositoryError() {
        
        tasksRepository.setReturnError(true)

        
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.isDataAvailable)).isFalse()
    }

    @Test
    fun updateSnackbar_nullValue() {
        
        val snackbarText = taskDetailViewModel.snackbarText.value

        
        assertThat(snackbarText).isNull()
    }

    @Test
    fun clickOnEditTask_SetsEvent() {
        
        taskDetailViewModel.editTask()

        
        val value = getValue(taskDetailViewModel.editTaskEvent)
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun deleteTask() {
        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isTrue()
        taskDetailViewModel.start(task.id)

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(getValue(taskDetailViewModel.dataLoading)).isFalse()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.util



import androidx.fragment.app.Fragment
import com.example.android.architecture.blueprints.todoapp.TodoApplication
import com.example.android.architecture.blueprints.todoapp.ViewModelFactory

fun Fragment.getVmFactory(): ViewModelFactory {
    val repository = (requireContext().applicationContext as TodoApplication).taskRepository
    return ViewModelFactory(repository)
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val statisticsViewModel by viewModels<StatisticsViewModel> { getVmFactory() }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = DataBindingUtil.inflate(
            inflater, R.layout.statistics_frag, container,
            false
        )
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.viewmodel = statisticsViewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        statisticsViewModel.start()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdated = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdated

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        if (_dataLoading.value == true) {
            return
        }

        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }

        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value = Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription).isEmpty) {
            _snackbarText.value = Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, taskCompleted, currentTaskId)
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) = viewModelScope.launch {
        tasksRepository.saveTask(newTask)
        _taskUpdated.value = Event(Unit)
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdated.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    private val args: AddEditTaskFragmentArgs by navArgs()

    private val viewModel by viewModels<AddEditTaskViewModel> { getVmFactory() }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            this.viewmodel = viewModel
        }
        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupSnackbar()
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        viewModel.start(args.taskId)
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarMessage, Snackbar.LENGTH_SHORT)
    }

    private fun setupNavigation() {
        viewModel.taskUpdatedEvent.observe(this, EventObserver {
            val action = AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
            findNavController().navigate(action)
        })
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getVmFactory() }

    private val args: TasksFragmentArgs by navArgs()

    private lateinit var viewDataBinding: TasksFragBinding

    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewModel.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()

        
        
        viewModel.loadTasks(true)
    }

    private fun setupNavigation() {
        viewModel.openTaskEvent.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewModel.newTaskEvent.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        view?.setupSnackbar(this, viewModel.snackbarMessage, Snackbar.LENGTH_SHORT)
        arguments?.let {
            viewModel.showEditResultMessage(args.userMessage)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewModel.setFiltering(
                    when (it.itemId) {
                        R.id.active -> TasksFilterType.ACTIVE_TASKS
                        R.id.completed -> TasksFilterType.COMPLETED_TASKS
                        else -> TasksFilterType.ALL_TASKS
                    }
                )
                viewModel.loadTasks(false)
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(
                null,
                resources.getString(R.string.add_task)
            )
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true
                )
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false
                )
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false
                )
            }
        }
    }

    private fun setFilter(
        @StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
        @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean
    ) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
        
        loadTasks(false)
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                val tasksResult = tasksRepository.getTasks(forceUpdate)

                if (tasksResult is Success) {
                    val tasks = tasksResult.data

                    val tasksToShow = ArrayList<Task>()
                    
                    for (task in tasks) {
                        when (_currentFiltering) {
                            TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                            TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                                tasksToShow.add(task)
                            }
                            TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                                tasksToShow.add(task)
                            }
                        }
                    }
                    isDataLoadingError.value = false
                    _items.value = ArrayList(tasksToShow)
                } else {
                    isDataLoadingError.value = false
                    _items.value = emptyList()
                    showSnackbarMessage(R.string.loading_tasks_error)
                }

                _dataLoading.value = false
            }
        }
    }

    fun refresh() {
        loadTasks(true)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.tasks.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {
    private lateinit var viewDataBinding: TaskdetailFragBinding

    private val args: TaskDetailFragmentArgs by navArgs()

    private val viewModel by viewModels<TaskDetailViewModel> { getVmFactory() }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        view?.setupSnackbar(this, viewModel.snackbarMessage, Snackbar.LENGTH_SHORT)
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }

    private fun setupNavigation() {
        viewModel.deleteTaskCommand.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToTasksFragment(DELETE_RESULT_OK)
            findNavController().navigate(action)
        })
        viewModel.editTaskCommand.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToAddEditTaskFragment(
                    args.taskId,
                    resources.getString(R.string.edit_task)
                )
            findNavController().navigate(action)
        })
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.fab_edit_task)?.setOnClickListener {
            viewModel.editTask()
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = viewModel
        }
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner

        viewModel.start(args.taskId)

        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewModel.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _task = MutableLiveData<Task>()
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskCommand = MutableLiveData<Event<Unit>>()
    val editTaskCommand: LiveData<Event<Unit>> = _editTaskCommand

    private val _deleteTaskCommand = MutableLiveData<Event<Unit>>()
    val deleteTaskCommand: LiveData<Event<Unit>> = _deleteTaskCommand

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val taskId: String?
        get() = _task.value?.id

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }


    fun deleteTask() = viewModelScope.launch {
        taskId?.let {
            tasksRepository.deleteTask(it)
            _deleteTaskCommand.value = Event(Unit)
        }
    }

    fun editTask() {
        _editTaskCommand.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = _task.value ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun start(taskId: String?, forceRefresh: Boolean = false) {
        if (_isDataAvailable.value == true && !forceRefresh || _dataLoading.value == true) {
            return
        }

        
        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                if (taskId != null) {
                    tasksRepository.getTask(taskId, false).let { result ->
                        if (result is Success) {
                            onTaskLoaded(result.data)
                        } else {
                            onDataNotAvailable(result)
                        }
                    }
                }
                _dataLoading.value = false
            }
        }
    }

    private fun setTask(task: Task?) {
        this._task.value = task
        _isDataAvailable.value = task != null
    }

    private fun onTaskLoaded(task: Task) {
        setTask(task)
    }

    private fun onDataNotAvailable(result: Result<Task>) {
        _task.value = null
        _isDataAvailable.value = false
    }

    fun refresh() {
        taskId?.let { start(it, true) }
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil.getValue
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class AddEditTaskViewModelTest {

    
    private lateinit var addEditTaskViewModel: AddEditTaskViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    private val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()

        
        addEditTaskViewModel = AddEditTaskViewModel(tasksRepository)
    }

    @Test
    fun saveNewTaskToRepository_showsSuccessMessageUi() {
        val newTitle = "New Task Title"
        val newDescription = "Some Task Description"
        (addEditTaskViewModel).apply {
            title.value = newTitle
            description.value = newDescription
        }
        addEditTaskViewModel.saveTask()

        val newTask = tasksRepository.tasksServiceData.values.first()

        
        assertThat(newTask.title).isEqualTo(newTitle)
        assertThat(newTask.description).isEqualTo(newDescription)
    }

    @Test
    fun loadTasks_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isFalse()
    }

    @Test
    fun loadTasks_taskShown() {
        
        tasksRepository.addTasks(task)

        
        addEditTaskViewModel.start(task.id)

        
        assertThat(getValue(addEditTaskViewModel.title)).isEqualTo(task.title)
        assertThat(getValue(addEditTaskViewModel.description)).isEqualTo(task.description)
        assertThat(getValue(addEditTaskViewModel.dataLoading)).isFalse()
    }

    @Test
    fun saveNewTaskToRepository_emptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_nullTitle_error() {
        saveTaskAndAssertSnackbarError(null, "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescription_error() {
        saveTaskAndAssertSnackbarError("Title", "")
    }

    @Test
    fun saveNewTaskToRepository_nullDescription_error() {
        saveTaskAndAssertSnackbarError("Title", null)
    }

    @Test
    fun saveNewTaskToRepository_nullDescriptionNullTitle_error() {
        saveTaskAndAssertSnackbarError(null, null)
    }

    @Test
    fun saveNewTaskToRepository_emptyDescriptionEmptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "")
    }

    private fun saveTaskAndAssertSnackbarError(title: String?, description: String?) {
        (addEditTaskViewModel).apply {
            this.title.value = title
            this.description.value = description
        }

        
        addEditTaskViewModel.saveTask()

        
        assertSnackbarMessage(addEditTaskViewModel.snackbarMessage, string.empty_task_message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertLiveDataEventTriggered
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository)
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() {
        
        mainCoroutineRule.pauseDispatcher()

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).hasSize(2)
    }

    @Test
    fun loadTasks_error() {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.loadTasks(true)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.dataLoading)).isFalse()

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.items)).isEmpty()

        
        assertSnackbarMessage(tasksViewModel.snackbarMessage, R.string.loading_tasks_error)
    }

    @Test
    fun clickOnFab_showsAddTaskUi() {
        
        tasksViewModel.addNewTask()

        
        val value = LiveDataTestUtil.getValue(tasksViewModel.newTaskEvent)
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun clickOnOpenTask_setsEvent() {
        
        val taskId = "42"
        tasksViewModel.openTask(taskId)

        
        assertLiveDataEventTriggered(tasksViewModel.openTaskEvent, taskId)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = mainCoroutineRule.runBlockingTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.loadTasks(true)

        
        val allTasks = LiveDataTestUtil.getValue(tasksViewModel.items)
        val completedTasks = allTasks.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.completed_tasks_cleared
        )
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_saved_task_message
        )
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_added_task_message
        )
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_deleted_task_message
        )
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_complete
        )
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isActive).isTrue()

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_active
        )
    }

    @Test
    fun getTasksAddViewVisible() {
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        assertThat(LiveDataTestUtil.getValue(tasksViewModel.tasksAddViewVisible)).isTrue()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil.getValue
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var mainCoroutineRule = MainCoroutineRule()

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(tasksRepository)
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() {
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.task).title).isEqualTo(task.title)
        assertThat(getValue(taskDetailViewModel.task).description)
            .isEqualTo(task.description)
    }

    @Test
    fun completeTask() {
        taskDetailViewModel.start(task.id)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isFalse()

        
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_complete)
    }

    @Test
    fun activateTask() {
        task.isCompleted = true

        taskDetailViewModel.start(task.id)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isTrue()

        
        taskDetailViewModel.setCompleted(false)

        
        assertThat(tasksRepository.tasksServiceData[task.id]?.isCompleted).isFalse()
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_active)

    }

    @Test
    fun taskDetailViewModel_repositoryError() {
        
        tasksRepository.setReturnError(true)

        
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.isDataAvailable)).isFalse()
    }

    @Test
    fun updateSnackbar_nullValue() {
        
        val snackbarText = taskDetailViewModel.snackbarMessage.value

        
        assertThat(snackbarText).isNull()
    }

    @Test
    fun clickOnEditTask_SetsEvent() {
        
        taskDetailViewModel.editTask()

        
        val value = getValue(taskDetailViewModel.editTaskCommand)
        assertThat(value.getContentIfNotHandled()).isNotNull()
    }

    @Test
    fun deleteTask() {
        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isTrue()
        taskDetailViewModel.start(task.id)

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.tasksServiceData.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() {
        
        mainCoroutineRule.pauseDispatcher()

        
        taskDetailViewModel.start(task.id)

        
        assertThat(getValue(taskDetailViewModel.dataLoading)).isTrue()

        
        mainCoroutineRule.resumeDispatcher()

        
        assertThat(getValue(taskDetailViewModel.dataLoading)).isFalse()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
class StatisticsFragmentTest {

    @After
    fun cleanupDb() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            runBlocking {
                deleteAllTasks()
            }
        }
    }

    @Test
    fun tasks_showsNonEmptyMessage() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            saveTaskBlocking(Task("Title1", "Description1", false))
            saveTaskBlocking(Task("Title2", "Description2", true))
        }

        launchFragmentInContainer<StatisticsFragment>(Bundle(), R.style.AppTheme)
        val expectedActiveTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_active_tasks, 1)
        val expectedCompletedTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_completed_tasks, 1)
        
        onView(withId(R.id.stats_active_text)).check(matches(isDisplayed()))
        onView(withId(R.id.stats_active_text)).check(matches(withText(expectedActiveTaskText)))
        onView(withId(R.id.stats_completed_text)).check(matches(isDisplayed()))
        onView(withId(R.id.stats_completed_text)).check(matches(withText(expectedCompletedTaskText)))
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.assertThat
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class AddEditTaskFragmentTest {

    @Before
    @After
    fun clearDb() = runBlocking {
        ServiceLocator.provideTasksRepository(getApplicationContext()).deleteAllTasks()
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun validTask_isSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        val scenario = launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.add_task_title))
          .perform(replaceText("title")) 
        onView(withId(R.id.add_task_description)).perform(
          replaceText("description")) 
        onView(withId(R.id.fab_save_task)).perform(click())

        
        
        
        val tasks = (ServiceLocator.provideTasksRepository(getApplicationContext())
                        .getTasksBlocking(true) as Result.Success).data
        assertThat(tasks.size, `is`(1))
        
        assertThat(tasks[0], notNullValue())
        assertThat(tasks[0].title, `is`("title"))
        assertThat(tasks[0].description, `is`("description"))

        verify(navController).navigate(
            AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK))
    }

}
<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import android.view.View
import android.widget.ListView
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import androidx.test.filters.SmallTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun setup() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
              isDescendantOfA(isAssignableFrom(ListView::class.java)),
              withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        verify(navController).navigate(
          TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
            null, getApplicationContext<Context>().getString(R.string.add_task)))
    }

    @Test
    @MediumTest
    fun displayTask_whenRepositoryHasData() {
        
        val repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.saveTaskBlocking(Task("title", "description"))

        
        launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)

        
        onView(withItemText("title")).check(matches(isDisplayed()))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun deleteOneTest() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun deleteOneOfTwoTests() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION2))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
        
        onView(withText(TITLE2)).check(matches(isDisplayed()))
    }

    private fun viewAllTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_all)).perform(ViewActions.click())
    }

    private fun viewActiveTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_active)).perform(ViewActions.click())
    }

    private fun viewCompletedTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_completed)).perform(ViewActions.click())
    }

    companion object {

        const val TITLE1 = "TITLE1"
        const val TITLE2 = "TITLE2"

        const val DESCRIPTION1 = "DESCRIPTION1"
        const val DESCRIPTION2 = "DESCRIPTION2"
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
class TaskDetailFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun cleanupDb() = runBlocking {
        repository.deleteAllTasks()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        
        val activeTask = Task("Active Task", "AndroidX Rocks", false)
        repository.saveTaskBlocking(activeTask)

        
        val bundle = TaskDetailFragmentArgs(activeTask.id).toBundle();
        val scenario = launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.Theme_AppCompat)

        
        
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_title)).check(matches(withText("Active Task")))
        onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
        
        onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        
        val completedTask = Task("Completed Task", "AndroidX Rocks", true)
        repository.saveTaskBlocking(completedTask)

        
        val bundle = TaskDetailFragmentArgs(completedTask.id).toBundle();
        val scenario = launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.Theme_AppCompat)

        
        
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_title)).check(matches(withText("Completed Task")))
        onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
        
        onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    private lateinit var repository: TasksRepository

    
    @UiThreadTest
    @Before
    fun resetState() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        runBlocking {
            repository.deleteAllTasks()
        }
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun createTask() {
        
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title))
          .perform(typeText("title"))
        onView(withId(R.id.add_task_description))
          .perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText("You have no TO-DOs!")).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewCompletedTasks()

        
        onView(withText("You have no completed TO-DOs!")).check(matches((isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewActiveTasks()

        
        onView(withText("You have no active TO-DOs!")).check(matches((isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class StatisticsScreenTest {

    @After
    fun cleanupDb() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            runBlocking {
                deleteAllTasks()
            }
        }
    }

    @Test
    fun tasks_showsNonEmptyMessage() {
        
        ServiceLocator.provideTasksRepository(getApplicationContext()).apply {
            runBlocking {
                saveTask(Task("Title1", "Description1", false))
                saveTask(Task("Title2", "Description2", true))
            }
        }

        val scenario = launchFragmentInContainer<StatisticsFragment>(Bundle(), R.style.Theme_AppCompat)
        val expectedActiveTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_active_tasks, 1)
        val expectedCompletedTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_completed_tasks, 1)
        scenario.onFragment {
            
            onView(withId(R.id.stats_active_text)).check(matches(isDisplayed()))
            onView(withId(R.id.stats_active_text)).check(matches(withText(expectedActiveTaskText)))
            onView(withId(R.id.stats_completed_text)).check(matches(isDisplayed()))
            onView(withId(R.id.stats_completed_text)).check(matches(withText(expectedCompletedTaskText)))
        }
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.assertThat
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.notNullValue
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class AddEditTaskScreenTest {

    @Before
    @After
    fun clearDb() = runBlocking {
        ServiceLocator.provideTasksRepository(getApplicationContext()).deleteAllTasks()
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun validTask_isSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        val scenario = launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.add_task_title))
          .perform(replaceText("title")) 
        onView(withId(R.id.add_task_description)).perform(
          replaceText("description")) 
        onView(withId(R.id.fab_save_task)).perform(click())

        
        
        
        val tasks = (ServiceLocator.provideTasksRepository(getApplicationContext())
                        .getTasksBlocking(true) as Result.Success).data
        assertThat(tasks.size, `is`(1))
        
        assertThat(tasks[0], notNullValue())
        assertThat(tasks[0].title, `is`("title"))
        assertThat(tasks[0].description, `is`("description"))

        verify(navController).navigate(
            AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK))
    }

}
<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import android.view.View
import android.widget.ListView
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import androidx.test.filters.SmallTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.Before
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@RunWith(AndroidJUnit4::class)
@SmallTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class TasksSingleScreenTest {

    private lateinit var repository: TasksRepository

    @Before
    fun setup() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
              isDescendantOfA(isAssignableFrom(ListView::class.java)),
              withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        verify(navController).navigate(
          TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
            null, getApplicationContext<Context>().getString(R.string.add_task)))
    }

    @Test
    @MediumTest
    fun displayTask_whenRepositoryHasData() {
        
        val repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.saveTaskBlocking(Task("title", "description"))

        
        launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)

        
        onView(withItemText("title")).check(matches(isDisplayed()))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withText(TITLE1)).check(matches(isDisplayed()))

        viewActiveTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))

        viewCompletedTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun deleteOneTest() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
    }

    @Test
    @Ignore("blocked on robolectric/4862")
    fun deleteOneOfTwoTests() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION1))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION2))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(ViewActions.click())

        
        onView(withId(R.id.menu_delete)).perform(ViewActions.click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(not(isDisplayed())))
        
        onView(withText(TITLE2)).check(matches(isDisplayed()))
    }

    private fun viewAllTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_all)).perform(ViewActions.click())
    }

    private fun viewActiveTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_active)).perform(ViewActions.click())
    }

    private fun viewCompletedTasks() {
        onView(ViewMatchers.withId(R.id.menu_filter)).perform(ViewActions.click())
        onView(withText(R.string.nav_completed)).perform(ViewActions.click())
    }

    companion object {

        const val TITLE1 = "TITLE1"
        const val TITLE2 = "TITLE2"

        const val DESCRIPTION1 = "DESCRIPTION1"
        const val DESCRIPTION2 = "DESCRIPTION2"
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
class TaskDetailScreenTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun cleanupDb() = runBlocking {
        repository.deleteAllTasks()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        
        val activeTask = Task("Active Task", "AndroidX Rocks", false)
        repository.saveTaskBlocking(activeTask)

        
        val bundle = TaskDetailFragmentArgs(activeTask.id).toBundle();
        val scenario = launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.Theme_AppCompat)

        
        scenario.onFragment {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText("Active Task")))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
        }
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        
        val completedTask = Task("Completed Task", "AndroidX Rocks", true)
        repository.saveTaskBlocking(completedTask)

        
        val bundle = TaskDetailFragmentArgs(completedTask.id).toBundle();
        val scenario = launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.Theme_AppCompat)

        
        scenario.onFragment {
            
            onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_title)).check(matches(withText("Completed Task")))
            onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
            
            onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
            onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksScreenTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    private lateinit var repository: TasksRepository

    
    @UiThreadTest
    @Before
    fun resetState() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        runBlocking {
            repository.deleteAllTasks()
        }
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun createTask() {
        
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title))
          .perform(typeText("title"))
        onView(withId(R.id.add_task_description))
          .perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText("You have no TO-DOs!")).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewCompletedTasks()

        
        onView(withText("You have no completed TO-DOs!")).check(matches((isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewActiveTasks()

        
        onView(withText("You have no active TO-DOs!")).check(matches((isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun createTask(title: String, description: String): Task

    suspend fun updateTask(taskId: String, title: String, description: String)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.LocalTask
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkTask
import com.example.android.architecture.blueprints.todoapp.data.source.network.TaskStatus




fun Task.toLocalModel() = LocalTask(
    id = id,
    title = title,
    description = description,
    isCompleted = isCompleted,
)

fun List<Task>.toLocalModels() = map(Task::toLocalModel)


fun LocalTask.toExternalModel() = Task(
    id = id,
    title = title,
    description = description,
    isCompleted = isCompleted,
)




@JvmName("taskEntitiesToExternalModels")
fun List<LocalTask>.toExternalModels() = map(LocalTask::toExternalModel)


fun NetworkTask.toTaskEntity() = LocalTask(
    id = id,
    title = title,
    description = shortDescription,
    isCompleted = (status == TaskStatus.COMPLETE),
)

@JvmName("networkTasksToTaskEntities")
fun List<NetworkTask>.toTaskEntities() = map(NetworkTask::toTaskEntity)


fun LocalTask.toNetworkModel() = NetworkTask(
    id = id,
    title = title,
    shortDescription = description,
    status = if (isCompleted) { TaskStatus.COMPLETE } else { TaskStatus.ACTIVE }
)


fun Task.toNetworkModel() = toLocalModel().toNetworkModel()

@JvmName("tasksToNetworkTasks")
fun List<Task>.toNetworkModels() = map(Task::toNetworkModel)


fun NetworkTask.toExternalModel() = toTaskEntity().toExternalModel()

@JvmName("networkTasksToTasks")
fun List<NetworkTask>.toExternalModels() = map(NetworkTask::toExternalModel)

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch


class DefaultTasksRepository(
    private val tasksNetworkDataSource: NetworkDataSource,
    private val tasksDao: TasksDao,
) : TasksRepository {

    override suspend fun createTask(title: String, description: String): Task {
        val task = Task(title = title, description = description)

        coroutineScope {
            launch { tasksNetworkDataSource.saveTask(task.toNetworkModel()) }
            launch {
                tasksDao.insertTask(task.toLocalModel())
            }
        }
        return task
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {

        val task = getTask(taskId)?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        coroutineScope {
            launch { tasksNetworkDataSource.saveTask(task.toNetworkModel()) }
            launch {
                tasksDao.insertTask(task.toLocalModel())
            }
        }
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            updateTasksFromRemoteDataSource()
        }
        return tasksDao.getTasks().map { it.toExternalModel() }
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return tasksDao.observeTasks().map { tasks ->
            tasks.map { task ->
                task.toExternalModel()
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksNetworkDataSource.loadTasks()

        
        tasksDao.deleteTasks()
        remoteTasks.forEach { task ->
            tasksDao.insertTask(task.toTaskEntity())
        }
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return tasksDao.observeTaskById(taskId).map { it.toExternalModel() }
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksNetworkDataSource.getTask(taskId)

        if (remoteTask == null) {
            tasksDao.deleteTaskById(taskId)
        } else {
            tasksDao.insertTask(
                remoteTask.toTaskEntity()
            )
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksDao.getTaskById(taskId)?.toExternalModel()
    }

    override suspend fun completeTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.completeTask(taskId) }
            launch { tasksDao.updateCompleted(taskId = taskId, completed = true) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.activateTask(taskId) }
            launch { tasksDao.updateCompleted(taskId = taskId, completed = false) }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksNetworkDataSource.clearCompletedTasks() }
            launch { tasksDao.deleteCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        coroutineScope {
            launch { tasksNetworkDataSource.deleteAllTasks() }
            launch { tasksDao.deleteTasks() }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.deleteTask(taskId) }
            launch { tasksDao.deleteTaskById(taskId) }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network


interface NetworkDataSource {

    suspend fun loadTasks(): List<NetworkTask>

    suspend fun getTask(taskId: String): NetworkTask?

    suspend fun saveTask(task: NetworkTask)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network

import kotlinx.coroutines.delay


object TasksNetworkDataSource : NetworkDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, NetworkTask>(2)

    init {
        addTask(
            id = "PISA",
            title = "Build tower in Pisa",
            shortDescription = "Ground looks good, no foundation work required."
        )
        addTask(
            id = "TACOMA",
            title = "Finish bridge in Tacoma",
            shortDescription = "Found awesome girders at half the cost!"
        )
    }

    override suspend fun loadTasks(): List<NetworkTask> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun getTask(taskId: String): NetworkTask? {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        return TASKS_SERVICE_DATA[taskId]
    }

    private fun addTask(id: String, title: String, shortDescription: String) {
        val newTask = NetworkTask(id = id, title = title, shortDescription = shortDescription)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: NetworkTask) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(status = TaskStatus.COMPLETE))
        }
    }

    override suspend fun activateTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(status = TaskStatus.ACTIVE))
        }
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            it.status == TaskStatus.COMPLETE
        } as LinkedHashMap<String, NetworkTask>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network


data class NetworkTask(
    val id: String,
    val title: String,
    val shortDescription: String,
    val priority: Int? = null,
    val status: TaskStatus = TaskStatus.ACTIVE
)

enum class TaskStatus {
    ACTIVE,
    COMPLETE
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.network.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.network.TasksNetworkDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class RemoteTasksDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTasksRepository(
        @RemoteTasksDataSource remoteDataSource: NetworkDataSource,
        database: ToDoDatabase,
    ): TasksRepository {
        return DefaultTasksRepository(remoteDataSource, database.taskDao())
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @RemoteTasksDataSource
    @Provides
    fun provideTasksRemoteDataSource(): NetworkDataSource = TasksNetworkDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        tasksRepository.getTasksStream()
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            tasksRepository.refreshTasks()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<List<Task>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Error -> {
                
                StatisticsUiState(isEmpty = true, isLoading = false)
            }
            is Async.Success -> {
                val stats = getActiveAndCompletedStats(taskLoad.data)
                StatisticsUiState(
                    isEmpty = taskLoad.data.isEmpty(),
                    activeTasksPercent = stats.activeTasksPercent,
                    completedTasksPercent = stats.completedTasksPercent,
                    isLoading = false
                )
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch


data class AddEditTaskUiState(
    val title: String = "",
    val description: String = "",
    val isTaskCompleted: Boolean = false,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskSaved: Boolean = false
)


@HiltViewModel
class AddEditTaskViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val taskId: String? = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]

    
    
    
    private val _uiState = MutableStateFlow(AddEditTaskUiState())
    val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

    init {
        if (taskId != null) {
            loadTask(taskId)
        }
    }

    
    fun saveTask() {
        if (uiState.value.title.isEmpty() || uiState.value.description.isEmpty()) {
            _uiState.update {
                it.copy(userMessage = R.string.empty_task_message)
            }
            return
        }

        if (taskId == null) {
            createNewTask()
        } else {
            updateTask()
        }
    }

    fun snackbarMessageShown() {
        _uiState.update {
            it.copy(userMessage = null)
        }
    }

    fun updateTitle(newTitle: String) {
        _uiState.update {
            it.copy(title = newTitle)
        }
    }

    fun updateDescription(newDescription: String) {
        _uiState.update {
            it.copy(description = newDescription)
        }
    }

    private fun createNewTask() = viewModelScope.launch {
        tasksRepository.createTask(uiState.value.title, uiState.value.description)
        _uiState.update {
            it.copy(isTaskSaved = true)
        }
    }

    private fun updateTask() {
        if (taskId == null) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.updateTask(
                taskId,
                title = uiState.value.title,
                description = uiState.value.description,
            )
            _uiState.update {
                it.copy(isTaskSaved = true)
            }
        }
    }

    private fun loadTask(taskId: String) {
        _uiState.update {
            it.copy(isLoading = true)
        }
        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { task ->
                if (task != null) {
                    _uiState.update {
                        it.copy(
                            title = task.title,
                            description = task.description,
                            isTaskCompleted = task.isCompleted,
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(isLoading = false)
                    }
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(tasksRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TaskDetailUiState(
    val task: Task? = null,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskDeleted: Boolean = false
)


@HiltViewModel
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    val taskId: String = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]!!

    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _isTaskDeleted = MutableStateFlow(false)
    private val _taskAsync = tasksRepository.getTaskStream(taskId)
        .map { handleTask(it) }
        .catch { emit(Async.Error(R.string.loading_task_error)) }

    val uiState: StateFlow<TaskDetailUiState> = combine(
        _userMessage, _isLoading, _isTaskDeleted, _taskAsync
    ) { userMessage, isLoading, isTaskDeleted, taskAsync ->
        when (taskAsync) {
            Async.Loading -> {
                TaskDetailUiState(isLoading = true)
            }
            is Async.Error -> {
                TaskDetailUiState(
                    userMessage = taskAsync.errorMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
            is Async.Success -> {
                TaskDetailUiState(
                    task = taskAsync.data,
                    isLoading = isLoading,
                    userMessage = userMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TaskDetailUiState(isLoading = true)
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted.value = true
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = uiState.value.task ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTask(taskId)
            _isLoading.value = false
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    private fun handleTask(task: Task?): Async<Task?> {
        if (task == null) {
            return Async.Error(R.string.task_not_found)
        }
        return Async.Success(task)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.source.local.FakeTasksDao
import com.example.android.architecture.blueprints.todoapp.data.source.network.FakeNetworkDataSource
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task(title = "Title1", description = "Description1")
    private val task2 = Task(title = "Title2", description = "Description2")
    private val task3 = Task(title = "Title3", description = "Description3")
    private val newTask = Task(title = "Title new", description = "Description new")
    private val networkTasks = listOf(task1, task2).toNetworkModels().sortedBy { it.id }
    private val localTasks = listOf(task3.toLocalModel()).sortedBy { it.id }

    private val newTasks = listOf(newTask).sortedBy { it.id }
    private lateinit var tasksNetworkDataSource: FakeNetworkDataSource
    private lateinit var tasksLocalDataSource: FakeTasksDao

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksNetworkDataSource = FakeNetworkDataSource(networkTasks.toMutableList())
        tasksLocalDataSource = FakeTasksDao(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksNetworkDataSource, tasksLocalDataSource
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptyRemoteSource = FakeNetworkDataSource()
        val emptyLocalSource = FakeTasksDao()

        val tasksRepository = DefaultTasksRepository(
            emptyRemoteSource, emptyLocalSource
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(networkTasks.toExternalModels())
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksNetworkDataSource.tasks).doesNotContain(newTask.toNetworkModel())
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask.toLocalModel())

        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksNetworkDataSource.tasks).contains(newTask.toNetworkModel())
        assertThat(tasksLocalDataSource.tasks?.contains(newTask.toLocalModel()))
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        tasksNetworkDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksNetworkDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks.toExternalModels())
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        tasksNetworkDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = tasksRepository.getTasks(true)

        assertThat(newTasks).isEqualTo(networkTasks.toExternalModels())
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks?.toExternalModels())
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksLocalDataSource.tasks = mutableListOf(task1.toLocalModel())
        val initial = tasksRepository.getTask(task1.id)

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksNetworkDataSource.tasks = mutableListOf(task1.toNetworkModel())
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        tasksNetworkDataSource.tasks = mutableListOf(task2.toNetworkModel())

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        tasksNetworkDataSource.tasks = mutableListOf(
            completedTask.toNetworkModel(),
            task2.toNetworkModel()
        )
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class StatisticsViewModelTest {

    
    private lateinit var statisticsViewModel: StatisticsViewModel

    
    private lateinit var tasksRepository: FakeTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupStatisticsViewModel() {
        tasksRepository = FakeTasksRepository()
        statisticsViewModel = StatisticsViewModel(tasksRepository)
    }

    @Test
    fun loadEmptyTasksFromRepository_EmptyResults() = runTest {
        

        
        val uiState = statisticsViewModel.uiState.first()
        assertThat(uiState.isEmpty).isTrue()
    }

    @Test
    fun loadNonEmptyTasksFromRepository_NonEmptyResults() = runTest {
        
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        val task4 = Task("Title4", "Description4", true)
        tasksRepository.addTasks(task1, task2, task3, task4)

        
        val uiState = statisticsViewModel.uiState.first()
        assertThat(uiState.isEmpty).isFalse()
        assertThat(uiState.activeTasksPercent).isEqualTo(25f)
        assertThat(uiState.completedTasksPercent).isEqualTo(75f)
        assertThat(uiState.isLoading).isEqualTo(false)
    }

    @Test
    fun loadTasks_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            statisticsViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class AddEditTaskViewModelTest {

    
    private lateinit var addEditTaskViewModel: AddEditTaskViewModel

    
    private lateinit var tasksRepository: FakeTasksRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeTasksRepository().apply {
            addTasks(task)
        }
    }

    @Test
    fun saveNewTaskToRepository_showsSuccessMessageUi() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        val newTitle = "New Task Title"
        val newDescription = "Some Task Description"
        addEditTaskViewModel.apply {
            updateTitle(newTitle)
            updateDescription(newDescription)
        }
        addEditTaskViewModel.saveTask()

        val newTask = tasksRepository.savedTasks.value.values.first()

        
        assertThat(newTask.title).isEqualTo(newTitle)
        assertThat(newTask.description).isEqualTo(newDescription)
    }

    @Test
    fun loadTasks_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        
        assertThat(addEditTaskViewModel.uiState.value.isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(addEditTaskViewModel.uiState.value.isLoading).isFalse()
    }

    @Test
    fun loadTasks_taskShown() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        
        tasksRepository.addTasks(task)

        
        val uiState = addEditTaskViewModel.uiState.value
        assertThat(uiState.title).isEqualTo(task.title)
        assertThat(uiState.description).isEqualTo(task.description)
        assertThat(uiState.isLoading).isFalse()
    }

    @Test
    fun saveNewTaskToRepository_emptyTitle_error() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        saveTaskAndAssertUserMessage("", "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescription_error() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        saveTaskAndAssertUserMessage("Title", "")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescriptionEmptyTitle_error() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        saveTaskAndAssertUserMessage("", "")
    }

    private fun saveTaskAndAssertUserMessage(title: String, description: String) {
        addEditTaskViewModel.apply {
            updateTitle(title)
            updateDescription(description)
        }

        
        addEditTaskViewModel.saveTask()

        assertThat(
            addEditTaskViewModel.uiState.value.userMessage
        ).isEqualTo(string.empty_task_message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeTasksRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository, SavedStateHandle())
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(2)
    }

    @Test
    fun loadTasks_error() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).isEmpty()
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_tasks_error)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = runTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.refresh()

        
        val allTasks = tasksViewModel.uiState.first().items
        val completedTasks = allTasks?.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.completed_tasks_cleared)
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_saved_task_message)
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_added_task_message)
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isActive).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeTasksRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeTasksRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() = runTest {
        val uiState = taskDetailViewModel.uiState.first()
        
        assertThat(uiState.task?.title).isEqualTo(task.title)
        assertThat(uiState.task?.description).isEqualTo(task.description)
    }

    @Test
    fun completeTask() = runTest {
        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isFalse()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask() = runTest {
        tasksRepository.deleteAllTasks()
        tasksRepository.addTasks(task.copy(isCompleted = true))

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(false)

        
        val newTask = tasksRepository.getTask(task.id)
        assertTrue((newTask?.isActive) ?: false)
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }

    @Test
    fun taskDetailViewModel_repositoryError() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_task_error)
    }

    @Test
    fun taskDetailViewModel_taskNotFound() = runTest {
        
        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "nonexistent_id"))
        )

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_not_found)
    }

    @Test
    fun deleteTask() = runTest {
        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isTrue()

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            taskDetailViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
@HiltAndroidTest
@ExperimentalCoroutinesApi
class StatisticsScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun tasks_showsNonEmptyMessage() = runTest {
        
        repository.apply {
            createTask("Title1", "Description1")
            createTask("Title2", "Description2").also {
                completeTask(it.id)
            }
        }

        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    StatisticsScreen(
                        openDrawer = { },
                        viewModel = StatisticsViewModel(repository)
                    )
                }
            }
        }

        val expectedActiveTaskText = activity.getString(R.string.statistics_active_tasks, 50.0f)
        val expectedCompletedTaskText = activity
            .getString(R.string.statistics_completed_tasks, 50.0f)

        
        composeTestRule.onNodeWithText(expectedActiveTaskText).assertIsDisplayed()
        composeTestRule.onNodeWithText(expectedCompletedTaskText).assertIsDisplayed()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
@HiltAndroidTest
@ExperimentalCoroutinesApi
class AddEditTaskScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()

        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository, SavedStateHandle()),
                        topBarTitle = R.string.add_task,
                        onTaskUpdate = { },
                        onBack = { },
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() = runTest {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = repository.getTasks(true)
        assertEquals(1, tasks.size)
        assertEquals("title", tasks[0].title)
        assertEquals("description", tasks[0].description)
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
@OptIn(ExperimentalCoroutinesApi::class)
class TasksTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun editTask() = runTest {
        val originalTaskTitle = "TITLE1"
        repository.createTask(originalTaskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText("DESCRIPTION").assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.edit_task)).assertIsDisplayed()
        findTextField(originalTaskTitle).performTextReplacement("NEW TITLE")
        findTextField("DESCRIPTION").performTextReplacement("NEW DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("NEW TITLE").assertIsDisplayed()
        
        composeTestRule.onNodeWithText(originalTaskTitle).assertDoesNotExist()
    }

    @Test
    fun createOneTask_deleteTask() {
        setContent()

        val taskTitle = "TITLE1"
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput(taskTitle)
        findTextField(R.string.description_hint).performTextInput("DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()

        
        composeTestRule.onNodeWithText(taskTitle).performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.nav_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertDoesNotExist()
    }

    @Test
    fun createTwoTasks_deleteOneTask() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION")
            createTask("TITLE2", "DESCRIPTION")
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).performClick()
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() = runTest {
        
        val taskTitle = "COMPLETED"
        repository.createTask(taskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() = runTest {
        
        val taskTitle = "ACTIVE"
        repository.apply {
            createTask(taskTitle, "DESCRIPTION").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() = runTest {
        
        val taskTitle = "ACT-COMP"
        repository.createTask(taskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() = runTest {
        
        val taskTitle = "COMP-ACT"
        repository.apply {
            createTask(taskTitle, "DESCRIPTION").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun createTask() {
        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("title").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun findTextField(textId: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(textId))
        )
    }

    private fun findTextField(text: String): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(text)
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onAllNodesWithText
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.test.espresso.Espresso.pressBack
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
class AppNavigationTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var tasksRepository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun drawerNavigationFromTasksToStatistics() {
        setContent()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_no_tasks))
            .assertIsDisplayed()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.no_tasks_all))
            .assertIsDisplayed()
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsDisplayed()
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        openDrawer()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()

        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        assertTrue(
            composeTestRule.onAllNodesWithText(activity.getString(R.string.statistics_title))
                .fetchSemanticsNodes().isNotEmpty()
        )
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() = runTest {
        val taskName = "UI <- button"
        tasksRepository.createTask(taskName, "Description")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .assertIsDisplayed()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    @Test
    fun taskDetailScreen_doubleBackButton() = runTest {
        val taskName = "Back button"
        tasksRepository.createTask(taskName, "Description")

        setContent()

        
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        pressBack()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        pressBack()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun openDrawer() {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.open_drawer))
            .performClick()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.StringRes
import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith



@RunWith(AndroidJUnit4::class)
@MediumTest


@HiltAndroidTest
@OptIn(ExperimentalCoroutinesApi::class)
class TasksScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun displayTask_whenRepositoryHasData() = runTest {
        
        repository.createTask("TITLE1", "DESCRIPTION1")

        
        setContent()

        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun displayActiveTask() = runTest {
        repository.createTask("TITLE1", "DESCRIPTION1")

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_completed)

        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun displayCompletedTask() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1").also { completeTask(it.id) }
        }

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()

        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsComplete() = runTest {
        repository.createTask("TITLE1", "DESCRIPTION1")

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsActive() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun showAllTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
    }

    @Test
    fun showActiveTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2")
            createTask("TITLE3", "DESCRIPTION3").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertDoesNotExist()
    }

    @Test
    fun showCompletedTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
            createTask("TITLE3", "DESCRIPTION3").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertIsDisplayed()
    }

    @Test
    fun clearCompletedTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_more))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).performClick()

        openFilterAndSelectOption(R.string.nav_all)
        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_all)

        
        composeTestRule.onNodeWithText("You have no tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_completed)
        
        composeTestRule.onNodeWithText("You have no completed tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_active)
        
        composeTestRule.onNodeWithText("You have no active tasks!").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TasksScreen(
                        viewModel = TasksViewModel(repository, SavedStateHandle()),
                        userMessage = R.string.successfully_added_task_message,
                        onUserMessageDisplayed = { },
                        onAddTask = { },
                        onTaskClick = { },
                        openDrawer = { }
                    )
                }
            }
        }
    }

    private fun openFilterAndSelectOption(@StringRes option: Int) {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(option)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(option)).performClick()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
@HiltAndroidTest
@ExperimentalCoroutinesApi
class TaskDetailScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() = runTest {
        
        val activeTask = repository.createTask(
            title = "Active Task",
            description = "AndroidX Rocks"
        )

        
        setContent(activeTask)

        
        
        composeTestRule.onNodeWithText("Active Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() = runTest {
        
        val completedTask = repository.createTask("Completed Task", "AndroidX Rocks")
        repository.completeTask(completedTask.id)

        
        setContent(completedTask)

        
        
        composeTestRule.onNodeWithText("Completed Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    private fun setContent(activeTask: Task) {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TaskDetailScreen(
                        viewModel = TaskDetailViewModel(
                            repository,
                            SavedStateHandle(mapOf("taskId" to activeTask.id))
                        ),
                        onEditTask = {  },
                        onBack = { },
                        onDeleteTask = { },
                    )
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import androidx.annotation.VisibleForTesting
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeTasksRepository : TasksRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override suspend fun createTask(title: String, description: String): Task {
        return Task(title = title, description = description).also {
            saveTask(it)
        }
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val updatedTask = _savedTasks.value[taskId]?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        saveTask(updatedTask)
    }

    private fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.network

class FakeNetworkDataSource(
    var tasks: MutableList<NetworkTask>? = mutableListOf()
) : NetworkDataSource {
    override suspend fun loadTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTask(taskId: String) = tasks?.firstOrNull { it.id == taskId }

    override suspend fun saveTask(task: NetworkTask) {
        tasks?.add(task)
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(status = TaskStatus.COMPLETE))
        }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(status = TaskStatus.ACTIVE))
        }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.status == TaskStatus.COMPLETE }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.local

import kotlinx.coroutines.flow.Flow

class FakeTasksDao(var tasks: MutableList<LocalTask>? = mutableListOf()) : TasksDao {

    override suspend fun getTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTaskById(taskId: String): LocalTask? =
        tasks?.firstOrNull { it.id == taskId }

    override suspend fun insertTask(task: LocalTask) {
        tasks?.add(task)
    }

    override suspend fun updateTask(task: LocalTask): Int {
        tasks?.apply {
            val didTaskExist = removeIf { it.id == task.id }
            if (didTaskExist) {
                if (add(task)) {
                    return 1
                }
            }
        }
        return 0
    }

    override suspend fun updateCompleted(taskId: String, completed: Boolean) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = completed }
    }

    override suspend fun deleteTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTaskById(taskId: String): Int {
        val wasDeleted = tasks?.removeIf { it.id == taskId } ?: false
        return if (wasDeleted) 1 else 0
    }

    override suspend fun deleteCompletedTasks(): Int {
        tasks?.apply {
            val originalSize = size
            if (removeIf { it.isCompleted }) {
                return originalSize - size
            }
        }
        return 0
    }

    override fun observeTasks(): Flow<List<LocalTask>> {
        TODO("Not implemented")
    }

    override fun observeTaskById(taskId: String): Flow<LocalTask> {
        TODO("Not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.TasksRepository
import dagger.Module
import dagger.Provides
import dagger.hilt.components.SingletonComponent
import dagger.hilt.testing.TestInstallIn
import javax.inject.Singleton

@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
object RepositoryTestModule {

    @Singleton
    @Provides
    fun provideTasksRepository(): TasksRepository {
        return FakeTasksRepository()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data

import com.example.android.architecture.blueprints.todoapp.data.source.local.LocalTask
import com.example.android.architecture.blueprints.todoapp.data.source.remote.NetworkTask
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TaskStatus




fun Task.toLocalModel() = LocalTask(
    id = id,
    title = title,
    description = description,
    isCompleted = isCompleted,
)

fun List<Task>.toLocalModels() = map(Task::toLocalModel)


fun LocalTask.toExternalModel() = Task(
    id = id,
    title = title,
    description = description,
    isCompleted = isCompleted,
)




@JvmName("taskEntitiesToExternalModels")
fun List<LocalTask>.toExternalModels() = map(LocalTask::toExternalModel)


fun NetworkTask.toTaskEntity() = LocalTask(
    id = id,
    title = title,
    description = shortDescription,
    isCompleted = (status == TaskStatus.COMPLETE),
)

@JvmName("networkTasksToTaskEntities")
fun List<NetworkTask>.toTaskEntities() = map(NetworkTask::toTaskEntity)


fun LocalTask.toNetworkModel() = NetworkTask(
    id = id,
    title = title,
    shortDescription = description,
    status = if (isCompleted) { TaskStatus.COMPLETE } else { TaskStatus.ACTIVE }
)


fun Task.toNetworkModel() = toLocalModel().toNetworkModel()

@JvmName("tasksToNetworkTasks")
fun List<Task>.toNetworkModels() = map(Task::toNetworkModel)


fun NetworkTask.toExternalModel() = toTaskEntity().toExternalModel()

@JvmName("networkTasksToTasks")
fun List<NetworkTask>.toExternalModels() = map(NetworkTask::toExternalModel)

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow


interface TasksRepository {

    fun getTasksStream(): Flow<List<Task>>

    suspend fun getTasks(forceUpdate: Boolean = false): List<Task>

    suspend fun refreshTasks()

    fun getTaskStream(taskId: String): Flow<Task?>

    suspend fun getTask(taskId: String, forceUpdate: Boolean = false): Task?

    suspend fun refreshTask(taskId: String)

    suspend fun createTask(title: String, description: String): Task

    suspend fun updateTask(taskId: String, title: String, description: String)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.source.remote.NetworkTask


interface NetworkDataSource {

    suspend fun loadTasks(): List<NetworkTask>

    suspend fun getTask(taskId: String): NetworkTask?

    suspend fun saveTask(task: NetworkTask)

    suspend fun completeTask(taskId: String)

    suspend fun activateTask(taskId: String)

    suspend fun clearCompletedTasks()

    suspend fun deleteAllTasks()

    suspend fun deleteTask(taskId: String)
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksDao
import com.example.android.architecture.blueprints.todoapp.data.toExternalModel
import com.example.android.architecture.blueprints.todoapp.data.toLocalModel
import com.example.android.architecture.blueprints.todoapp.data.toNetworkModel
import com.example.android.architecture.blueprints.todoapp.data.toTaskEntity
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch


class DefaultTasksRepository(
    private val tasksNetworkDataSource: NetworkDataSource,
    private val tasksDao: TasksDao,
) : TasksRepository {

    override suspend fun createTask(title: String, description: String): Task {
        val task = Task(title = title, description = description)

        coroutineScope {
            launch { tasksNetworkDataSource.saveTask(task.toNetworkModel()) }
            launch {
                tasksDao.insertTask(task.toLocalModel())
            }
        }
        return task
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {

        val task = getTask(taskId)?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        coroutineScope {
            launch { tasksNetworkDataSource.saveTask(task.toNetworkModel()) }
            launch {
                tasksDao.insertTask(task.toLocalModel())
            }
        }
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (forceUpdate) {
            updateTasksFromRemoteDataSource()
        }
        return tasksDao.getTasks().map { it.toExternalModel() }
    }

    override suspend fun refreshTasks() {
        updateTasksFromRemoteDataSource()
    }

    override fun getTasksStream(): Flow<List<Task>> {
        return tasksDao.observeTasks().map { tasks ->
            tasks.map { task ->
                task.toExternalModel()
            }
        }
    }

    override suspend fun refreshTask(taskId: String) {
        updateTaskFromRemoteDataSource(taskId)
    }

    private suspend fun updateTasksFromRemoteDataSource() {
        val remoteTasks = tasksNetworkDataSource.loadTasks()

        
        tasksDao.deleteTasks()
        remoteTasks.forEach { task ->
            tasksDao.insertTask(task.toTaskEntity())
        }
    }

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return tasksDao.observeTaskById(taskId).map { it.toExternalModel() }
    }

    private suspend fun updateTaskFromRemoteDataSource(taskId: String) {
        val remoteTask = tasksNetworkDataSource.getTask(taskId)

        if (remoteTask == null) {
            tasksDao.deleteTaskById(taskId)
        } else {
            tasksDao.insertTask(
                remoteTask.toTaskEntity()
            )
        }
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (forceUpdate) {
            updateTaskFromRemoteDataSource(taskId)
        }
        return tasksDao.getTaskById(taskId)?.toExternalModel()
    }

    override suspend fun completeTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.completeTask(taskId) }
            launch { tasksDao.updateCompleted(taskId = taskId, completed = true) }
        }
    }

    override suspend fun activateTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.activateTask(taskId) }
            launch { tasksDao.updateCompleted(taskId = taskId, completed = false) }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksNetworkDataSource.clearCompletedTasks() }
            launch { tasksDao.deleteCompletedTasks() }
        }
    }

    override suspend fun deleteAllTasks() {
        coroutineScope {
            launch { tasksNetworkDataSource.deleteAllTasks() }
            launch { tasksDao.deleteTasks() }
        }
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksNetworkDataSource.deleteTask(taskId) }
            launch { tasksDao.deleteTaskById(taskId) }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.source.NetworkDataSource
import kotlinx.coroutines.delay


object TasksNetworkDataSource : NetworkDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, NetworkTask>(2)

    init {
        addTask(
            id = "PISA",
            title = "Build tower in Pisa",
            shortDescription = "Ground looks good, no foundation work required."
        )
        addTask(
            id = "TACOMA",
            title = "Finish bridge in Tacoma",
            shortDescription = "Found awesome girders at half the cost!"
        )
    }

    override suspend fun loadTasks(): List<NetworkTask> {
        
        val tasks = TASKS_SERVICE_DATA.values.toList()
        delay(SERVICE_LATENCY_IN_MILLIS)
        return tasks
    }

    override suspend fun getTask(taskId: String): NetworkTask? {
        
        delay(SERVICE_LATENCY_IN_MILLIS)
        return TASKS_SERVICE_DATA[taskId]
    }

    private fun addTask(id: String, title: String, shortDescription: String) {
        val newTask = NetworkTask(id = id, title = title, shortDescription = shortDescription)
        TASKS_SERVICE_DATA[newTask.id] = newTask
    }

    override suspend fun saveTask(task: NetworkTask) {
        TASKS_SERVICE_DATA[task.id] = task
    }

    override suspend fun completeTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(status = TaskStatus.COMPLETE))
        }
    }

    override suspend fun activateTask(taskId: String) {
        TASKS_SERVICE_DATA[taskId]?.let {
            saveTask(it.copy(status = TaskStatus.ACTIVE))
        }
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            it.status == TaskStatus.COMPLETE
        } as LinkedHashMap<String, NetworkTask>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source.remote


data class NetworkTask(
    val id: String,
    val title: String,
    val shortDescription: String,
    val priority: Int? = null,
    val status: TaskStatus = TaskStatus.ACTIVE
)

enum class TaskStatus {
    ACTIVE,
    COMPLETE
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.NetworkDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksNetworkDataSource
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class RemoteTasksDataSource

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {

    @Singleton
    @Provides
    fun provideTasksRepository(
        @RemoteTasksDataSource remoteDataSource: NetworkDataSource,
        database: ToDoDatabase,
    ): TasksRepository {
        return DefaultTasksRepository(remoteDataSource, database.taskDao())
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {

    @Singleton
    @RemoteTasksDataSource
    @Provides
    fun provideTasksRemoteDataSource(): NetworkDataSource = TasksNetworkDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Singleton
    @Provides
    fun provideDataBase(@ApplicationContext context: Context): ToDoDatabase {
        return Room.databaseBuilder(
            context.applicationContext,
            ToDoDatabase::class.java,
            "Tasks.db"
        ).build()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class StatisticsUiState(
    val isEmpty: Boolean = false,
    val isLoading: Boolean = false,
    val activeTasksPercent: Float = 0f,
    val completedTasksPercent: Float = 0f
)


@HiltViewModel
class StatisticsViewModel @Inject constructor(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    val uiState: StateFlow<StatisticsUiState> =
        tasksRepository.getTasksStream()
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }
            .map { taskAsync -> produceStatisticsUiState(taskAsync) }
            .stateIn(
                scope = viewModelScope,
                started = WhileUiSubscribed,
                initialValue = StatisticsUiState(isLoading = true)
            )

    fun refresh() {
        viewModelScope.launch {
            tasksRepository.refreshTasks()
        }
    }

    private fun produceStatisticsUiState(taskLoad: Async<List<Task>>) =
        when (taskLoad) {
            Async.Loading -> {
                StatisticsUiState(isLoading = true, isEmpty = true)
            }
            is Async.Error -> {
                
                StatisticsUiState(isEmpty = true, isLoading = false)
            }
            is Async.Success -> {
                val stats = getActiveAndCompletedStats(taskLoad.data)
                StatisticsUiState(
                    isEmpty = taskLoad.data.isEmpty(),
                    activeTasksPercent = stats.activeTasksPercent,
                    completedTasksPercent = stats.completedTasksPercent,
                    isLoading = false
                )
            }
        }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch


data class AddEditTaskUiState(
    val title: String = "",
    val description: String = "",
    val isTaskCompleted: Boolean = false,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskSaved: Boolean = false
)


@HiltViewModel
class AddEditTaskViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val taskId: String? = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]

    
    
    
    private val _uiState = MutableStateFlow(AddEditTaskUiState())
    val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

    init {
        if (taskId != null) {
            loadTask(taskId)
        }
    }

    
    fun saveTask() {
        if (uiState.value.title.isEmpty() || uiState.value.description.isEmpty()) {
            _uiState.update {
                it.copy(userMessage = R.string.empty_task_message)
            }
            return
        }

        if (taskId == null) {
            createNewTask()
        } else {
            updateTask()
        }
    }

    fun snackbarMessageShown() {
        _uiState.update {
            it.copy(userMessage = null)
        }
    }

    fun updateTitle(newTitle: String) {
        _uiState.update {
            it.copy(title = newTitle)
        }
    }

    fun updateDescription(newDescription: String) {
        _uiState.update {
            it.copy(description = newDescription)
        }
    }

    private fun createNewTask() = viewModelScope.launch {
        tasksRepository.createTask(uiState.value.title, uiState.value.description)
        _uiState.update {
            it.copy(isTaskSaved = true)
        }
    }

    private fun updateTask() {
        if (taskId == null) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.updateTask(
                taskId,
                title = uiState.value.title,
                description = uiState.value.description,
            )
            _uiState.update {
                it.copy(isTaskSaved = true)
            }
        }
    }

    private fun loadTask(taskId: String) {
        _uiState.update {
            it.copy(isLoading = true)
        }
        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { task ->
                if (task != null) {
                    _uiState.update {
                        it.copy(
                            title = task.title,
                            description = task.description,
                            isTaskCompleted = task.isCompleted,
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(isLoading = false)
                    }
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ACTIVE_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.ALL_TASKS
import com.example.android.architecture.blueprints.todoapp.tasks.TasksFilterType.COMPLETED_TASKS
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TasksUiState(
    val items: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val filteringUiInfo: FilteringUiInfo = FilteringUiInfo(),
    val userMessage: Int? = null
)


@HiltViewModel
class TasksViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _savedFilterType =
        savedStateHandle.getStateFlow(TASKS_FILTER_SAVED_STATE_KEY, ALL_TASKS)

    private val _filterUiInfo = _savedFilterType.map { getFilterUiInfo(it) }.distinctUntilChanged()
    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _filteredTasksAsync =
        combine(tasksRepository.getTasksStream(), _savedFilterType) { tasks, type ->
            filterTasks(tasks, type)
        }
            .map { Async.Success(it) }
            .catch<Async<List<Task>>> { emit(Async.Error(R.string.loading_tasks_error)) }

    val uiState: StateFlow<TasksUiState> = combine(
        _filterUiInfo, _isLoading, _userMessage, _filteredTasksAsync
    ) { filterUiInfo, isLoading, userMessage, tasksAsync ->
        when (tasksAsync) {
            Async.Loading -> {
                TasksUiState(isLoading = true)
            }
            is Async.Error -> {
                TasksUiState(userMessage = tasksAsync.errorMessage)
            }
            is Async.Success -> {
                TasksUiState(
                    items = tasksAsync.data,
                    filteringUiInfo = filterUiInfo,
                    isLoading = isLoading,
                    userMessage = userMessage
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TasksUiState(isLoading = true)
        )

    fun setFiltering(requestType: TasksFilterType) {
        savedStateHandle[TASKS_FILTER_SAVED_STATE_KEY] = requestType
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            showSnackbarMessage(R.string.completed_tasks_cleared)
            refresh()
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_saved_task_message)
            ADD_EDIT_RESULT_OK -> showSnackbarMessage(R.string.successfully_added_task_message)
            DELETE_RESULT_OK -> showSnackbarMessage(R.string.successfully_deleted_task_message)
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTasks()
            _isLoading.value = false
        }
    }

    private fun filterTasks(tasks: List<Task>, filteringType: TasksFilterType): List<Task> {
        val tasksToShow = ArrayList<Task>()
        
        for (task in tasks) {
            when (filteringType) {
                ALL_TASKS -> tasksToShow.add(task)
                ACTIVE_TASKS -> if (task.isActive) {
                    tasksToShow.add(task)
                }
                COMPLETED_TASKS -> if (task.isCompleted) {
                    tasksToShow.add(task)
                }
            }
        }
        return tasksToShow
    }

    private fun getFilterUiInfo(requestType: TasksFilterType): FilteringUiInfo =
        when (requestType) {
            ALL_TASKS -> {
                FilteringUiInfo(
                    R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill
                )
            }
            ACTIVE_TASKS -> {
                FilteringUiInfo(
                    R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp
                )
            }
            COMPLETED_TASKS -> {
                FilteringUiInfo(
                    R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp
                )
            }
        }
}


const val TASKS_FILTER_SAVED_STATE_KEY = "TASKS_FILTER_SAVED_STATE_KEY"

data class FilteringUiInfo(
    val currentFilteringLabel: Int = R.string.label_all,
    val noTasksLabel: Int = R.string.no_tasks_all,
    val noTaskIconRes: Int = R.drawable.logo_no_fill,
)

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.Async
import com.example.android.architecture.blueprints.todoapp.util.WhileUiSubscribed
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch


data class TaskDetailUiState(
    val task: Task? = null,
    val isLoading: Boolean = false,
    val userMessage: Int? = null,
    val isTaskDeleted: Boolean = false
)


@HiltViewModel
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    val taskId: String = savedStateHandle[TodoDestinationsArgs.TASK_ID_ARG]!!

    private val _userMessage: MutableStateFlow<Int?> = MutableStateFlow(null)
    private val _isLoading = MutableStateFlow(false)
    private val _isTaskDeleted = MutableStateFlow(false)
    private val _taskAsync = tasksRepository.getTaskStream(taskId)
        .map { handleTask(it) }
        .catch { emit(Async.Error(R.string.loading_task_error)) }

    val uiState: StateFlow<TaskDetailUiState> = combine(
        _userMessage, _isLoading, _isTaskDeleted, _taskAsync
    ) { userMessage, isLoading, isTaskDeleted, taskAsync ->
        when (taskAsync) {
            Async.Loading -> {
                TaskDetailUiState(isLoading = true)
            }
            is Async.Error -> {
                TaskDetailUiState(
                    userMessage = taskAsync.errorMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
            is Async.Success -> {
                TaskDetailUiState(
                    task = taskAsync.data,
                    isLoading = isLoading,
                    userMessage = userMessage,
                    isTaskDeleted = isTaskDeleted
                )
            }
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = WhileUiSubscribed,
            initialValue = TaskDetailUiState(isLoading = true)
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted.value = true
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = uiState.value.task ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task.id)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task.id)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun refresh() {
        _isLoading.value = true
        viewModelScope.launch {
            tasksRepository.refreshTask(taskId)
            _isLoading.value = false
        }
    }

    fun snackbarMessageShown() {
        _userMessage.value = null
    }

    private fun showSnackbarMessage(message: Int) {
        _userMessage.value = message
    }

    private fun handleTask(task: Task?): Async<Task?> {
        if (task == null) {
            return Async.Error(R.string.task_not_found)
        }
        return Async.Success(task)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.toExternalModels
import com.example.android.architecture.blueprints.todoapp.data.toLocalModel
import com.example.android.architecture.blueprints.todoapp.data.toNetworkModel
import com.example.android.architecture.blueprints.todoapp.data.toNetworkModels
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class DefaultTasksRepositoryTest {

    private val task1 = Task(title = "Title1", description = "Description1")
    private val task2 = Task(title = "Title2", description = "Description2")
    private val task3 = Task(title = "Title3", description = "Description3")
    private val newTask = Task(title = "Title new", description = "Description new")
    private val networkTasks = listOf(task1, task2).toNetworkModels().sortedBy { it.id }
    private val localTasks = listOf(task3.toLocalModel()).sortedBy { it.id }

    private val newTasks = listOf(newTask).sortedBy { it.id }
    private lateinit var tasksNetworkDataSource: FakeNetworkDataSource
    private lateinit var tasksLocalDataSource: FakeTasksDao

    
    private lateinit var tasksRepository: DefaultTasksRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @ExperimentalCoroutinesApi
    @Before
    fun createRepository() {
        tasksNetworkDataSource = FakeNetworkDataSource(networkTasks.toMutableList())
        tasksLocalDataSource = FakeTasksDao(localTasks.toMutableList())
        
        tasksRepository = DefaultTasksRepository(
            tasksNetworkDataSource, tasksLocalDataSource
        )
    }

    @ExperimentalCoroutinesApi
    @Test
    fun getTasks_emptyRepositoryAndUninitializedCache() = runTest {
        val emptyRemoteSource = FakeNetworkDataSource()
        val emptyLocalSource = FakeTasksDao()

        val tasksRepository = DefaultTasksRepository(
            emptyRemoteSource, emptyLocalSource
        )

        assertThat(tasksRepository.getTasks().size).isEqualTo(0)
    }

    @Test
    fun getTasks_repositoryCachesAfterFirstApiCall() = runTest {
        
        val initial = tasksRepository.getTasks(forceUpdate = true)

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val second = tasksRepository.getTasks()

        
        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTasks_requestsAllTasksFromRemoteDataSource() = runTest {
        
        val tasks = tasksRepository.getTasks(true)

        
        assertThat(tasks).isEqualTo(networkTasks.toExternalModels())
    }

    @Test
    fun saveTask_savesToLocalAndRemote() = runTest {
        
        assertThat(tasksNetworkDataSource.tasks).doesNotContain(newTask.toNetworkModel())
        assertThat(tasksLocalDataSource.tasks).doesNotContain(newTask.toLocalModel())

        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksNetworkDataSource.tasks).contains(newTask.toNetworkModel())
        assertThat(tasksLocalDataSource.tasks?.contains(newTask.toLocalModel()))
    }

    @Test
    fun getTasks_WithDirtyCache_tasksAreRetrievedFromRemote() = runTest {
        
        val tasks = tasksRepository.getTasks()

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val cachedTasks = tasksRepository.getTasks()
        assertThat(cachedTasks).isEqualTo(tasks)

        
        val refreshedTasks = tasksRepository.getTasks(true)

        
        assertThat(refreshedTasks).isEqualTo(newTasks)
    }

    @Test(expected = Exception::class)
    fun getTasks_WithDirtyCache_remoteUnavailable_throwsException() = runTest {
        
        tasksNetworkDataSource.tasks = null

        
        tasksRepository.getTasks(true)

        
    }

    @Test
    fun getTasks_WithRemoteDataSourceUnavailable_tasksAreRetrievedFromLocal() =
        runTest {
            
            tasksNetworkDataSource.tasks = null

            
            assertThat(tasksRepository.getTasks()).isEqualTo(localTasks.toExternalModels())
        }

    @Test(expected = Exception::class)
    fun getTasks_WithBothDataSourcesUnavailable_throwsError() = runTest {
        
        tasksNetworkDataSource.tasks = null
        tasksLocalDataSource.tasks = null

        
        tasksRepository.getTasks()
    }

    @Test
    fun getTasks_refreshesLocalDataSource() = runTest {
        val initialLocal = tasksLocalDataSource.tasks

        
        val newTasks = tasksRepository.getTasks(true)

        assertThat(newTasks).isEqualTo(networkTasks.toExternalModels())
        assertThat(newTasks).isEqualTo(tasksLocalDataSource.tasks?.toExternalModels())
        assertThat(tasksLocalDataSource.tasks).isEqualTo(initialLocal)
    }

    @Test
    fun completeTask_completesTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isFalse()

        
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isCompleted).isTrue()
    }

    @Test
    fun completeTask_activeTaskToServiceAPIUpdatesCache() = runTest {
        
        val newTask = tasksRepository.createTask(newTask.title, newTask.description)
        tasksRepository.completeTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isFalse()

        
        tasksRepository.activateTask(newTask.id)

        
        assertThat(tasksRepository.getTask(newTask.id)?.isActive).isTrue()
    }

    @Test
    fun getTask_repositoryCachesAfterFirstApiCall() = runTest {
        
        tasksLocalDataSource.tasks = mutableListOf(task1.toLocalModel())
        val initial = tasksRepository.getTask(task1.id)

        
        tasksNetworkDataSource.tasks = newTasks.toNetworkModels().toMutableList()

        
        val second = tasksRepository.getTask(task1.id)

        
        assertThat(second).isEqualTo(initial)
    }

    @Test
    fun getTask_forceRefresh() = runTest {
        
        tasksNetworkDataSource.tasks = mutableListOf(task1.toNetworkModel())
        val task1FirstTime = tasksRepository.getTask(task1.id, forceUpdate = true)
        assertThat(task1FirstTime?.id).isEqualTo(task1.id)

        
        tasksNetworkDataSource.tasks = mutableListOf(task2.toNetworkModel())

        
        val task1SecondTime = tasksRepository.getTask(task1.id, true)
        val task2SecondTime = tasksRepository.getTask(task2.id, true)

        
        assertThat(task1SecondTime).isNull()
        assertThat(task2SecondTime?.id).isEqualTo(task2.id)
    }

    @Test
    fun clearCompletedTasks() = runTest {
        val completedTask = task1.copy(isCompleted = true)
        tasksNetworkDataSource.tasks = mutableListOf(
            completedTask.toNetworkModel(),
            task2.toNetworkModel()
        )
        tasksRepository.clearCompletedTasks()

        val tasks = tasksRepository.getTasks(true)

        assertThat(tasks).hasSize(1)
        assertThat(tasks).contains(task2)
        assertThat(tasks).doesNotContain(completedTask)
    }

    @Test
    fun deleteAllTasks() = runTest {
        val initialTasks = tasksRepository.getTasks()

        
        assertThat(initialTasks.size).isEqualTo(1)

        
        tasksRepository.deleteAllTasks()

        
        val afterDeleteTasks = tasksRepository.getTasks()
        assertThat(afterDeleteTasks).isEmpty()
    }

    @Test
    fun deleteSingleTask() = runTest {
        val initialTasksSize = tasksRepository.getTasks(true).size

        
        tasksRepository.deleteTask(task1.id)

        
        val afterDeleteTasks = tasksRepository.getTasks(true)

        
        assertThat(afterDeleteTasks.size).isEqualTo(initialTasksSize - 1)
        assertThat(afterDeleteTasks).doesNotContain(task1)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class StatisticsViewModelTest {

    
    private lateinit var statisticsViewModel: StatisticsViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupStatisticsViewModel() {
        tasksRepository = FakeRepository()
        statisticsViewModel = StatisticsViewModel(tasksRepository)
    }

    @Test
    fun loadEmptyTasksFromRepository_EmptyResults() = runTest {
        

        
        val uiState = statisticsViewModel.uiState.first()
        assertThat(uiState.isEmpty).isTrue()
    }

    @Test
    fun loadNonEmptyTasksFromRepository_NonEmptyResults() = runTest {
        
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        val task4 = Task("Title4", "Description4", true)
        tasksRepository.addTasks(task1, task2, task3, task4)

        
        val uiState = statisticsViewModel.uiState.first()
        assertThat(uiState.isEmpty).isFalse()
        assertThat(uiState.activeTasksPercent).isEqualTo(25f)
        assertThat(uiState.completedTasksPercent).isEqualTo(75f)
        assertThat(uiState.isLoading).isEqualTo(false)
    }

    @Test
    fun loadTasks_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            statisticsViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class AddEditTaskViewModelTest {

    
    private lateinit var addEditTaskViewModel: AddEditTaskViewModel

    
    private lateinit var tasksRepository: FakeRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository().apply {
            addTasks(task)
        }
    }

    @Test
    fun saveNewTaskToRepository_showsSuccessMessageUi() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        val newTitle = "New Task Title"
        val newDescription = "Some Task Description"
        addEditTaskViewModel.apply {
            updateTitle(newTitle)
            updateDescription(newDescription)
        }
        addEditTaskViewModel.saveTask()

        val newTask = tasksRepository.savedTasks.value.values.first()

        
        assertThat(newTask.title).isEqualTo(newTitle)
        assertThat(newTask.description).isEqualTo(newDescription)
    }

    @Test
    fun loadTasks_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        
        assertThat(addEditTaskViewModel.uiState.value.isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(addEditTaskViewModel.uiState.value.isLoading).isFalse()
    }

    @Test
    fun loadTasks_taskShown() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        
        tasksRepository.addTasks(task)

        
        val uiState = addEditTaskViewModel.uiState.value
        assertThat(uiState.title).isEqualTo(task.title)
        assertThat(uiState.description).isEqualTo(task.description)
        assertThat(uiState.isLoading).isFalse()
    }

    @Test
    fun saveNewTaskToRepository_emptyTitle_error() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        saveTaskAndAssertUserMessage("", "Some Task Description")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescription_error() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        saveTaskAndAssertUserMessage("Title", "")
    }

    @Test
    fun saveNewTaskToRepository_emptyDescriptionEmptyTitle_error() {
        addEditTaskViewModel = AddEditTaskViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )

        saveTaskAndAssertUserMessage("", "")
    }

    private fun saveTaskAndAssertUserMessage(title: String, description: String) {
        addEditTaskViewModel.apply {
            updateTitle(title)
            updateDescription(description)
        }

        
        addEditTaskViewModel.saveTask()

        assertThat(
            addEditTaskViewModel.uiState.value.userMessage
        ).isEqualTo(string.empty_task_message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2", true)
        val task3 = Task("Title3", "Description3", true)
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository, SavedStateHandle())
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() = runTest {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).hasSize(2)
    }

    @Test
    fun loadTasks_error() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        tasksViewModel.refresh()

        
        assertThat(tasksViewModel.uiState.first().isLoading).isFalse()

        
        assertThat(tasksViewModel.uiState.first().items).isEmpty()
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_tasks_error)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = runTest {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.refresh()

        
        val allTasks = tasksViewModel.uiState.first().items
        val completedTasks = allTasks?.filter { it.isCompleted }

        
        assertThat(completedTasks).isEmpty()

        
        assertThat(allTasks).hasSize(1)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.completed_tasks_cleared)
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_saved_task_message)
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_added_task_message)
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() = runTest {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() = runTest {
        
        val task = Task("Title", "Description", true)
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isActive).isTrue()

        
        assertThat(tasksViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.lifecycle.SavedStateHandle
import com.example.android.architecture.blueprints.todoapp.MainCoroutineRule
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoDestinationsArgs
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ExperimentalCoroutinesApi
class TaskDetailViewModelTest {

    
    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository
    private val task = Task(title = "Title1", description = "Description1", id = "0")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "0"))
        )
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() = runTest {
        val uiState = taskDetailViewModel.uiState.first()
        
        assertThat(uiState.task?.title).isEqualTo(task.title)
        assertThat(uiState.task?.description).isEqualTo(task.description)
    }

    @Test
    fun completeTask() = runTest {
        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isFalse()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(true)

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_complete)
    }

    @Test
    fun activateTask() = runTest {
        tasksRepository.deleteAllTasks()
        tasksRepository.addTasks(task.copy(isCompleted = true))

        
        assertThat(tasksRepository.savedTasks.value[task.id]?.isCompleted).isTrue()

        
        assertThat(taskDetailViewModel.uiState.first().task?.id).isEqualTo("0")
        taskDetailViewModel.setCompleted(false)

        
        val newTask = tasksRepository.getTask(task.id)
        assertTrue((newTask?.isActive) ?: false)
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_marked_active)
    }

    @Test
    fun taskDetailViewModel_repositoryError() = runTest {
        
        tasksRepository.setShouldThrowError(true)

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.loading_task_error)
    }

    @Test
    fun taskDetailViewModel_taskNotFound() = runTest {
        
        taskDetailViewModel = TaskDetailViewModel(
            tasksRepository,
            SavedStateHandle(mapOf(TodoDestinationsArgs.TASK_ID_ARG to "nonexistent_id"))
        )

        
        assertThat(taskDetailViewModel.uiState.value.task).isNull()
        assertThat(taskDetailViewModel.uiState.first().userMessage)
            .isEqualTo(R.string.task_not_found)
    }

    @Test
    fun deleteTask() = runTest {
        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isTrue()

        
        taskDetailViewModel.deleteTask()

        assertThat(tasksRepository.savedTasks.value.containsValue(task)).isFalse()
    }

    @Test
    fun loadTask_loading() = runTest {
        
        Dispatchers.setMain(StandardTestDispatcher())

        var isLoading: Boolean? = true
        val job = launch {
            taskDetailViewModel.uiState.collect {
                isLoading = it.isLoading
            }
        }

        
        assertThat(isLoading).isTrue()

        
        advanceUntilIdle()

        
        assertThat(isLoading).isFalse()
        job.cancel()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
@HiltAndroidTest
@ExperimentalCoroutinesApi
class StatisticsScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun tasks_showsNonEmptyMessage() = runTest {
        
        repository.apply {
            createTask("Title1", "Description1")
            createTask("Title2", "Description2").also {
                completeTask(it.id)
            }
        }

        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    StatisticsScreen(
                        openDrawer = { },
                        viewModel = StatisticsViewModel(repository)
                    )
                }
            }
        }

        val expectedActiveTaskText = activity.getString(R.string.statistics_active_tasks, 50.0f)
        val expectedCompletedTaskText = activity
            .getString(R.string.statistics_completed_tasks, 50.0f)

        
        composeTestRule.onNodeWithText(expectedActiveTaskText).assertIsDisplayed()
        composeTestRule.onNodeWithText(expectedCompletedTaskText).assertIsDisplayed()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.compose.material.Surface
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
@HiltAndroidTest
@ExperimentalCoroutinesApi
class AddEditTaskScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()

        
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    AddEditTaskScreen(
                        viewModel = AddEditTaskViewModel(repository, SavedStateHandle()),
                        topBarTitle = R.string.add_task,
                        onTaskUpdate = { },
                        onBack = { },
                    )
                }
            }
        }
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        findTextField(R.string.title_hint).performTextClearance()
        findTextField(R.string.description_hint).performTextClearance()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule
            .onNodeWithText(activity.getString(R.string.empty_task_message))
            .assertIsDisplayed()
    }

    @Test
    fun validTask_isSaved() = runTest {
        
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        val tasks = repository.getTasks(true)
        assertEquals(1, tasks.size)
        assertEquals("title", tasks[0].title)
        assertEquals("description", tasks[0].description)
    }

    private fun findTextField(text: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(text))
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.SemanticsNodeInteraction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
@OptIn(ExperimentalCoroutinesApi::class)
class TasksTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun editTask() = runTest {
        val originalTaskTitle = "TITLE1"
        repository.createTask(originalTaskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        composeTestRule.onNodeWithText(originalTaskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText("DESCRIPTION").assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.edit_task)).assertIsDisplayed()
        findTextField(originalTaskTitle).performTextReplacement("NEW TITLE")
        findTextField("DESCRIPTION").performTextReplacement("NEW DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("NEW TITLE").assertIsDisplayed()
        
        composeTestRule.onNodeWithText(originalTaskTitle).assertDoesNotExist()
    }

    @Test
    fun createOneTask_deleteTask() {
        setContent()

        val taskTitle = "TITLE1"
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput(taskTitle)
        findTextField(R.string.description_hint).performTextInput("DESCRIPTION")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()

        
        composeTestRule.onNodeWithText(taskTitle).performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.task_details))
            .assertIsDisplayed()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.nav_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertDoesNotExist()
    }

    @Test
    fun createTwoTasks_deleteOneTask() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION")
            createTask("TITLE2", "DESCRIPTION")
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_delete_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).performClick()
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() = runTest {
        
        val taskTitle = "COMPLETED"
        repository.createTask(taskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() = runTest {
        
        val taskTitle = "ACTIVE"
        repository.apply {
            createTask(taskTitle, "DESCRIPTION").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() = runTest {
        
        val taskTitle = "ACT-COMP"
        repository.createTask(taskTitle, "DESCRIPTION")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()

        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() = runTest {
        
        val taskTitle = "COMP-ACT"
        repository.apply {
            createTask(taskTitle, "DESCRIPTION").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskTitle).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()
        
        composeTestRule.onNode(isToggleable()).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    @Test
    fun createTask() {
        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.add_task))
            .performClick()
        findTextField(R.string.title_hint).performTextInput("title")
        findTextField(R.string.description_hint).performTextInput("description")
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.cd_save_task))
            .performClick()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText("title").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun findTextField(textId: Int): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(activity.getString(textId))
        )
    }

    private fun findTextField(text: String): SemanticsNodeInteraction {
        return composeTestRule.onNode(
            hasSetTextAction() and hasText(text)
        )
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onAllNodesWithText
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.test.espresso.Espresso.pressBack
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.TodoNavGraph
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
@HiltAndroidTest
class AppNavigationTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    
    @get:Rule(order = 1)
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @get:Rule(order = 2)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var tasksRepository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun drawerNavigationFromTasksToStatistics() {
        setContent()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_no_tasks))
            .assertIsDisplayed()

        openDrawer()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).performClick()
        
        composeTestRule.onNodeWithText(activity.getString(R.string.no_tasks_all))
            .assertIsDisplayed()
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title))
            .assertIsDisplayed()
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        setContent()

        
        openDrawer()
        composeTestRule.onNodeWithText(activity.getString(R.string.statistics_title)).performClick()

        composeTestRule.onNodeWithText(activity.getString(R.string.list_title))
            .assertIsNotDisplayed()

        openDrawer()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.list_title)).assertIsDisplayed()
        assertTrue(
            composeTestRule.onAllNodesWithText(activity.getString(R.string.statistics_title))
                .fetchSemanticsNodes().isNotEmpty()
        )
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() = runTest {
        val taskName = "UI <- button"
        tasksRepository.createTask(taskName, "Description")

        setContent()

        
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .assertIsDisplayed()
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_back))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    @Test
    fun taskDetailScreen_doubleBackButton() = runTest {
        val taskName = "Back button"
        tasksRepository.createTask(taskName, "Description")

        setContent()

        
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()
        composeTestRule.onNodeWithText(taskName).performClick()
        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.edit_task))
            .performClick()

        
        pressBack()
        composeTestRule.onNodeWithText(taskName).assertIsDisplayed()

        
        pressBack()
        composeTestRule.onNodeWithText(activity.getString(R.string.label_all)).assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                TodoNavGraph()
            }
        }
    }

    private fun openDrawer() {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.open_drawer))
            .performClick()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.StringRes
import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith



@RunWith(AndroidJUnit4::class)
@MediumTest


@HiltAndroidTest
@OptIn(ExperimentalCoroutinesApi::class)
class TasksScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()
    private val activity get() = composeTestRule.activity

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun init() {
        hiltRule.inject()
    }

    @Test
    fun displayTask_whenRepositoryHasData() = runTest {
        
        repository.createTask("TITLE1", "DESCRIPTION1")

        
        setContent()

        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun displayActiveTask() = runTest {
        repository.createTask("TITLE1", "DESCRIPTION1")

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_completed)

        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun displayCompletedTask() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1").also { completeTask(it.id) }
        }

        setContent()

        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()

        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()

        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsComplete() = runTest {
        repository.createTask("TITLE1", "DESCRIPTION1")

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
    }

    @Test
    fun markTaskAsActive() = runTest {
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNode(isToggleable()).performClick()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
    }

    @Test
    fun showAllTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_all)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
    }

    @Test
    fun showActiveTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2")
            createTask("TITLE3", "DESCRIPTION3").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_active)
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertDoesNotExist()
    }

    @Test
    fun showCompletedTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
            createTask("TITLE3", "DESCRIPTION3").also { completeTask(it.id) }
        }

        setContent()

        
        openFilterAndSelectOption(R.string.nav_completed)
        composeTestRule.onNodeWithText("TITLE1").assertDoesNotExist()
        composeTestRule.onNodeWithText("TITLE2").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE3").assertIsDisplayed()
    }

    @Test
    fun clearCompletedTasks() = runTest {
        
        repository.apply {
            createTask("TITLE1", "DESCRIPTION1")
            createTask("TITLE2", "DESCRIPTION2").also { completeTask(it.id) }
        }

        setContent()

        
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_more))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(R.string.menu_clear)).performClick()

        openFilterAndSelectOption(R.string.nav_all)
        
        composeTestRule.onNodeWithText("TITLE1").assertIsDisplayed()
        composeTestRule.onNodeWithText("TITLE2").assertDoesNotExist()
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_all)

        
        composeTestRule.onNodeWithText("You have no tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_completed)
        
        composeTestRule.onNodeWithText("You have no completed tasks!").assertIsDisplayed()
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        setContent()

        openFilterAndSelectOption(R.string.nav_active)
        
        composeTestRule.onNodeWithText("You have no active tasks!").assertIsDisplayed()
    }

    private fun setContent() {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TasksScreen(
                        viewModel = TasksViewModel(repository, SavedStateHandle()),
                        userMessage = R.string.successfully_added_task_message,
                        onUserMessageDisplayed = { },
                        onAddTask = { },
                        onTaskClick = { },
                        openDrawer = { }
                    )
                }
            }
        }
    }

    private fun openFilterAndSelectOption(@StringRes option: Int) {
        composeTestRule.onNodeWithContentDescription(activity.getString(R.string.menu_filter))
            .performClick()
        composeTestRule.onNodeWithText(activity.getString(option)).assertIsDisplayed()
        composeTestRule.onNodeWithText(activity.getString(option)).performClick()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.compose.material.Surface
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.isToggleable
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithText
import androidx.lifecycle.SavedStateHandle
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.HiltTestActivity
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.google.accompanist.appcompattheme.AppCompatTheme
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import javax.inject.Inject
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
@HiltAndroidTest
@ExperimentalCoroutinesApi
class TaskDetailScreenTest {

    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)

    @get:Rule(order = 1)
    val composeTestRule = createAndroidComposeRule<HiltTestActivity>()

    @Inject
    lateinit var repository: TasksRepository

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() = runTest {
        
        val activeTask = repository.createTask(
            title = "Active Task",
            description = "AndroidX Rocks"
        )

        
        setContent(activeTask)

        
        
        composeTestRule.onNodeWithText("Active Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOff()
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() = runTest {
        
        val completedTask = repository.createTask("Completed Task", "AndroidX Rocks")
        repository.completeTask(completedTask.id)

        
        setContent(completedTask)

        
        
        composeTestRule.onNodeWithText("Completed Task").assertIsDisplayed()
        composeTestRule.onNodeWithText("AndroidX Rocks").assertIsDisplayed()
        
        composeTestRule.onNode(isToggleable()).assertIsOn()
    }

    private fun setContent(activeTask: Task) {
        composeTestRule.setContent {
            AppCompatTheme {
                Surface {
                    TaskDetailScreen(
                        viewModel = TaskDetailViewModel(
                            repository,
                            SavedStateHandle(mapOf("taskId" to activeTask.id))
                        ),
                        onEditTask = {  },
                        onBack = { },
                        onDeleteTask = { },
                    )
                }
            }
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.source.local.LocalTask
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksDao
import kotlinx.coroutines.flow.Flow

class FakeTasksDao(var tasks: MutableList<LocalTask>? = mutableListOf()) : TasksDao {

    override suspend fun getTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTaskById(taskId: String): LocalTask? =
        tasks?.firstOrNull { it.id == taskId }

    override suspend fun insertTask(task: LocalTask) {
        tasks?.add(task)
    }

    override suspend fun updateTask(task: LocalTask): Int {
        tasks?.apply {
            val didTaskExist = removeIf { it.id == task.id }
            if (didTaskExist) {
                if (add(task)) {
                    return 1
                }
            }
        }
        return 0
    }

    override suspend fun updateCompleted(taskId: String, completed: Boolean) {
        tasks?.firstOrNull { it.id == taskId }?.let { it.isCompleted = completed }
    }

    override suspend fun deleteTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTaskById(taskId: String): Int {
        val wasDeleted = tasks?.removeIf { it.id == taskId } ?: false
        return if (wasDeleted) 1 else 0
    }

    override suspend fun deleteCompletedTasks(): Int {
        tasks?.apply {
            val originalSize = size
            if (removeIf { it.isCompleted }) {
                return originalSize - size
            }
        }
        return 0
    }

    override fun observeTasks(): Flow<List<LocalTask>> {
        TODO("Not implemented")
    }

    override fun observeTaskById(taskId: String): Flow<LocalTask> {
        TODO("Not implemented")
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.source.remote.NetworkTask
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TaskStatus

class FakeNetworkDataSource(
    var tasks: MutableList<NetworkTask>? = mutableListOf()
) : NetworkDataSource {
    override suspend fun loadTasks() = tasks ?: throw Exception("Task list is null")

    override suspend fun getTask(taskId: String) = tasks?.firstOrNull { it.id == taskId }

    override suspend fun saveTask(task: NetworkTask) {
        tasks?.add(task)
    }

    override suspend fun completeTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(status = TaskStatus.COMPLETE))
        }
    }

    override suspend fun activateTask(taskId: String) {
        tasks?.firstOrNull { it.id == taskId }?.let {
            deleteTask(it.id)
            saveTask(it.copy(status = TaskStatus.ACTIVE))
        }
    }

    override suspend fun clearCompletedTasks() {
        tasks?.removeIf { it.status == TaskStatus.COMPLETE }
    }

    override suspend fun deleteAllTasks() {
        tasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        tasks?.removeIf { it.id == taskId }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Task
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update


class FakeRepository : TasksRepository {

    private var shouldThrowError = false

    private val _savedTasks = MutableStateFlow(LinkedHashMap<String, Task>())
    val savedTasks: StateFlow<LinkedHashMap<String, Task>> = _savedTasks.asStateFlow()

    private val observableTasks: Flow<List<Task>> = savedTasks.map {
        if (shouldThrowError) {
            throw Exception("Test exception")
        } else {
            it.values.toList()
        }
    }

    fun setShouldThrowError(value: Boolean) {
        shouldThrowError = value
    }

    override suspend fun refreshTasks() {
        
    }

    override suspend fun refreshTask(taskId: String) {
        refreshTasks()
    }

    override suspend fun createTask(title: String, description: String): Task {
        return Task(title = title, description = description).also {
            saveTask(it)
        }
    }

    override fun getTasksStream(): Flow<List<Task>> = observableTasks

    override fun getTaskStream(taskId: String): Flow<Task?> {
        return observableTasks.map { tasks ->
            return@map tasks.firstOrNull { it.id == taskId }
        }
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Task? {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return savedTasks.value[taskId]
    }

    override suspend fun getTasks(forceUpdate: Boolean): List<Task> {
        if (shouldThrowError) {
            throw Exception("Test exception")
        }
        return observableTasks.first()
    }

    override suspend fun updateTask(taskId: String, title: String, description: String) {
        val updatedTask = _savedTasks.value[taskId]?.copy(
            title = title,
            description = description
        ) ?: throw Exception("Task (id $taskId) not found")

        saveTask(updatedTask)
    }

    private fun saveTask(task: Task) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks[task.id] = task
            newTasks
        }
    }

    override suspend fun completeTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = true))
        }
    }

    override suspend fun activateTask(taskId: String) {
        _savedTasks.value[taskId]?.let {
            saveTask(it.copy(isCompleted = false))
        }
    }

    override suspend fun clearCompletedTasks() {
        _savedTasks.update { tasks ->
            tasks.filterValues {
                !it.isCompleted
            } as LinkedHashMap<String, Task>
        }
    }

    override suspend fun deleteTask(taskId: String) {
        _savedTasks.update { tasks ->
            val newTasks = LinkedHashMap<String, Task>(tasks)
            newTasks.remove(taskId)
            newTasks
        }
    }

    override suspend fun deleteAllTasks() {
        _savedTasks.update {
            LinkedHashMap()
        }
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        _savedTasks.update { oldTasks ->
            val newTasks = LinkedHashMap<String, Task>(oldTasks)
            for (task in tasks) {
                newTasks[task.id] = task
            }
            newTasks
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.di

import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import dagger.Module
import dagger.Provides
import dagger.hilt.components.SingletonComponent
import dagger.hilt.testing.TestInstallIn
import javax.inject.Singleton

@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
object RepositoryTestModule {

    @Singleton
    @Provides
    fun provideTasksRepository(): TasksRepository {
        return FakeRepository()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksRepository {

    private var cachedTasks: ConcurrentMap<String, Task>? = null

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {

        EspressoIdlingResource.increment() 

        return withContext(ioDispatcher) {
            
            if (!forceUpdate) {
                cachedTasks?.let { cachedTasks ->
                    EspressoIdlingResource.decrement() 
                    return@withContext Success(cachedTasks.values.sortedBy { it.id })
                }
            }

            val newTasks = fetchTasksFromRemoteOrLocal(forceUpdate)

            
            (newTasks as? Success)?.let { refreshCache(it.data) }

            EspressoIdlingResource.decrement() 

            cachedTasks?.values?.let { tasks ->
                return@withContext Result.Success(tasks.sortedBy { it.id })
            }

            (newTasks as? Success)?.let {
                if (it.data.isEmpty()) {
                    return@withContext Result.Success(it.data)
                }
            }

            return@withContext Result.Error(Exception("Illegal state"))
        }
    }

    private suspend fun fetchTasksFromRemoteOrLocal(forceUpdate: Boolean): Result<List<Task>> {
        
        val remoteTasks = tasksRemoteDataSource.getTasks()
        when (remoteTasks) {
            is Result.Error -> Timber.w("Remote data source fetch failed")
            is Result.Success -> {
                refreshLocalDataSource(remoteTasks.data)
                return remoteTasks
            }
            else -> throw IllegalStateException()
        }

        
        if (forceUpdate) {
            return Result.Error(Exception("Can't force refresh: remote data source is unavailable"))
        }

        
        val localTasks = tasksLocalDataSource.getTasks()
        if (localTasks is Result.Success) return localTasks
        return Result.Error(Exception("Error fetching from remote and local"))
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {

        EspressoIdlingResource.increment() 

        return withContext(ioDispatcher) {
            
            if (!forceUpdate) {
                getTaskWithId(taskId)?.let {
                    EspressoIdlingResource.decrement() 
                    return@withContext Success(it)
                }
            }

            val newTask = fetchTaskFromRemoteOrLocal(taskId, forceUpdate)

            
            (newTask as? Success)?.let { cacheTask(it.data) }

            EspressoIdlingResource.decrement() 

            return@withContext newTask
        }
    }

    private suspend fun fetchTaskFromRemoteOrLocal(
        taskId: String,
        forceUpdate: Boolean
    ): Result<Task> {
        
        val remoteTask = tasksRemoteDataSource.getTask(taskId)
        when (remoteTask) {
            is Result.Error -> Timber.w("Remote data source fetch failed")
            is Result.Success -> {
                refreshLocalDataSource(remoteTask.data)
                return remoteTask
            }
            else -> throw IllegalStateException()
        }

        
        if (forceUpdate) {
            return Result.Error(Exception("Refresh failed"))
        }

        
        val localTasks = tasksLocalDataSource.getTask(taskId)
        if (localTasks is Result.Success) return localTasks
        return Result.Error(Exception("Error fetching from remote and local"))
    }

    override suspend fun saveTask(task: Task) {
        
        cacheAndPerform(task) {
            coroutineScope {
                launch { tasksRemoteDataSource.saveTask(it) }
                launch { tasksLocalDataSource.saveTask(it) }
            }
        }
    }

    override suspend fun completeTask(task: Task) {
        
        cacheAndPerform(task) {
            it.isCompleted = true
            coroutineScope {
                launch { tasksRemoteDataSource.completeTask(it) }
                launch { tasksLocalDataSource.completeTask(it) }
            }
        }
    }

    override suspend fun completeTask(taskId: String) {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let {
                completeTask(it)
            }
        }
    }

    override suspend fun activateTask(task: Task) = withContext(ioDispatcher) {
        
        cacheAndPerform(task) {
            it.isCompleted = false
            coroutineScope {
                launch { tasksRemoteDataSource.activateTask(it) }
                launch { tasksLocalDataSource.activateTask(it) }
            }

        }
    }

    override suspend fun activateTask(taskId: String)  {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let {
                activateTask(it)
            }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
        withContext(ioDispatcher) {
            cachedTasks?.entries?.removeAll { it.value.isCompleted }
        }
    }

    override suspend fun deleteAllTasks() {
        withContext(ioDispatcher) {
            coroutineScope {
                launch { tasksRemoteDataSource.deleteAllTasks() }
                launch { tasksLocalDataSource.deleteAllTasks() }
            }
        }
        cachedTasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }

        cachedTasks?.remove(taskId)
        Unit 
    }

    private fun refreshCache(tasks: List<Task>) {
        cachedTasks?.clear()
        tasks.sortedBy { it.id }.forEach {
            cacheAndPerform(it) {}
        }
    }

    private suspend fun refreshLocalDataSource(tasks: List<Task>) {
        tasksLocalDataSource.deleteAllTasks()
        for (task in tasks) {
            tasksLocalDataSource.saveTask(task)
        }
    }

    private suspend fun refreshLocalDataSource(task: Task) {
        tasksLocalDataSource.saveTask(task)
    }

    private fun getTaskWithId(id: String) = cachedTasks?.get(id)

    private fun cacheTask(task: Task): Task {
        val cachedTask = Task(task.title, task.description, task.isCompleted, task.id)
        
        if (cachedTasks == null) {
            cachedTasks = ConcurrentHashMap()
        }
        cachedTasks?.put(cachedTask.id, cachedTask)
        return cachedTask
    }

    private inline fun cacheAndPerform(task: Task, perform: (Task) -> Unit) {
        val cachedTask = cacheTask(task)
        perform(cachedTask)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.google.common.collect.Lists
import kotlinx.coroutines.delay


object TasksRemoteDataSource : TasksDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 2000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, Task>(2)

    init {
        addTask("Build tower in Pisa", "Ground looks good, no foundation work required.")
        addTask("Finish bridge in Tacoma", "Found awesome girders at half the cost!")
    }

    
    override suspend fun getTasks(): Result<List<Task>> {
        
        val tasks = Lists.newArrayList(TASKS_SERVICE_DATA.values)
        delay(SERVICE_LATENCY_IN_MILLIS)
        return Success(tasks)
    }

    
    override suspend fun getTask(taskId: String): Result<Task> {

        
        delay(SERVICE_LATENCY_IN_MILLIS)
        TASKS_SERVICE_DATA[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Task not found"))
    }

    private fun addTask(title: String, description: String) {
        val newTask = Task(title, description)
        TASKS_SERVICE_DATA.put(newTask.id, newTask)
    }
    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA.put(task.id, task)
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        TASKS_SERVICE_DATA.put(task.id, completedTask)
    }

    override suspend fun completeTask(taskId: String) {
        
        
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        TASKS_SERVICE_DATA.put(task.id, activeTask)
    }

    override suspend fun activateTask(taskId: String) {
        
        
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_saved_task_message)
            )
            ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_added_task_message)
            )
            DELETE_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_deleted_task_message)
            )
        }

    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) {

        _dataLoading.value = true

        
        
        EspressoIdlingResource.increment() 

        viewModelScope.launch {
            val tasksResult = tasksRepository.getTasks(forceUpdate)

            if (tasksResult is Success) {
                val tasks = tasksResult.data

                val tasksToShow = ArrayList<Task>()
                
                for (task in tasks) {
                    when (_currentFiltering) {
                        TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                        TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                            tasksToShow.add(task)
                        }
                        TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                            tasksToShow.add(task)
                        }
                    }
                }
                isDataLoadingError.value = false
                _items.value = ArrayList(tasksToShow)
            } else {
                isDataLoadingError.value = false
                _items.value = emptyList()
                _snackbarText.value = Event(R.string.loading_tasks_error)
            }

            EspressoIdlingResource.decrement() 
            _dataLoading.value = false
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.util


import android.view.View
import androidx.databinding.DataBindingUtil
import androidx.databinding.ViewDataBinding
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.fragment.app.testing.FragmentScenario
import androidx.test.core.app.ActivityScenario
import androidx.test.espresso.IdlingResource
import java.util.UUID


class DataBindingIdlingResource : IdlingResource {
    
    private val idlingCallbacks = mutableListOf<IdlingResource.ResourceCallback>()
    
    
    private val id = UUID.randomUUID().toString()
    
    
    private var wasNotIdle = false

    lateinit var activity: FragmentActivity

    override fun getName() = "DataBinding $id"

    override fun isIdleNow(): Boolean {
        val idle = !getBindings().any { it.hasPendingBindings() }
        @Suppress("LiftReturnOrAssignment")
        if (idle) {
            if (wasNotIdle) {
                
                idlingCallbacks.forEach { it.onTransitionToIdle() }
            }
            wasNotIdle = false
        } else {
            wasNotIdle = true
            
            activity.findViewById<View>(android.R.id.content).postDelayed({
                isIdleNow
            }, 16)
        }
        return idle
    }

    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback) {
        idlingCallbacks.add(callback)
    }

    
    private fun getBindings(): List<ViewDataBinding> {
        val fragments = (activity as? FragmentActivity)
            ?.supportFragmentManager
            ?.fragments

        val bindings =
            fragments?.mapNotNull {
                it.view?.getBinding()
            } ?: emptyList()
        val childrenBindings = fragments?.flatMap { it.childFragmentManager.fragments }
            ?.mapNotNull { it.view?.getBinding() } ?: emptyList()

        return bindings + childrenBindings
    }
}

private fun View.getBinding(): ViewDataBinding? = DataBindingUtil.getBinding(this)


fun DataBindingIdlingResource.monitorActivity(
activityScenario: ActivityScenario<out FragmentActivity>
) {
    activityScenario.onActivity {
        this.activity = it
    }
}


fun DataBindingIdlingResource.monitorFragment(fragmentScenario: FragmentScenario<out Fragment>) {
    fragmentScenario.onFragment {
        this.activity = it.requireActivity()
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.succeeded
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.`is`
import org.junit.After
import org.junit.Assert.assertThat
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
class TasksLocalDataSourceTest {

    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),
            ToDoDatabase::class.java)
            .allowMainThreadQueries()
            .build()

        localDataSource = TasksLocalDataSource(database.taskDao())
    }

    @After
    fun cleanUp() {
        database.close()
    }

    @Test
    fun saveTask_retrievesTask() = runBlocking {
        
        val newTask = Task("title", "description", true)
        localDataSource.saveTask(newTask)

        
        val result = localDataSource.getTask(newTask.id)

        
        assertThat(result.succeeded, `is`(true))
        result as Result.Success
        assertThat(result.data.title, `is`("title"))
        assertThat(result.data.description, `is`("description"))
        assertThat(result.data.isCompleted, `is`(true))
    }

    @Test
    fun completeTask_retrievedTaskIsComplete() = runBlocking {
        
        val newTask = Task("title")
        localDataSource.saveTask(newTask)

        
        localDataSource.completeTask(newTask)
        val result = localDataSource.getTask(newTask.id)

        
        assertThat(result.succeeded, `is`(true))
        result as Result.Success
        assertThat(result.data.title, `is`(newTask.title))
        assertThat(result.data.isCompleted, `is`(true))
    }

    @Test
    fun activateTask_retrievedTaskIsActive() = runBlocking {
        
        val newTask = Task("Some title", "Some description", true)
        localDataSource.saveTask(newTask)

        localDataSource.activateTask(newTask)

        
        val result = localDataSource.getTask(newTask.id)

        assertThat(result.succeeded, `is`(true))
        result as Result.Success

        assertThat(result.data.title, `is`("Some title"))
        assertThat(result.data.isCompleted, `is`(false))
    }

    @Test
    fun clearCompletedTask_taskNotRetrievable() = runBlocking {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title2")
        val newTask3 = Task("title3")
        localDataSource.saveTask(newTask1)
        localDataSource.completeTask(newTask1)
        localDataSource.saveTask(newTask2)
        localDataSource.completeTask(newTask2)
        localDataSource.saveTask(newTask3)
        
        localDataSource.clearCompletedTasks()

        
        assertThat(localDataSource.getTask(newTask1.id).succeeded, `is`(false))
        assertThat(localDataSource.getTask(newTask2.id).succeeded, `is`(false))

        val result3 = localDataSource.getTask(newTask3.id)

        assertThat(result3.succeeded, `is`(true))
        result3 as Result.Success

        assertThat(result3.data, `is`(newTask3))
    }

    @Test
    fun deleteAllTasks_emptyListOfRetrievedTask() = runBlocking {
        
        val newTask = Task("title")

        localDataSource.saveTask(newTask)

        
        localDataSource.deleteAllTasks()

        
        val result = localDataSource.getTasks() as Result.Success
        assertThat(result.data.isEmpty(), `is`(true))

    }

    @Test
    fun getTasks_retrieveSavedTasks() = runBlocking {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title")

        localDataSource.saveTask(newTask1)
        localDataSource.saveTask(newTask2)
        
        val results = localDataSource.getTasks() as Result.Success<List<Task>>
        val tasks = results.data
        assertThat(tasks.size, `is`(2))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.monitorFragment
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
class StatisticsFragmentTest {
    private lateinit var repository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun tasks_showsNonEmptyMessage() {
        
        repository.apply {
            saveTaskBlocking(Task("Title1", "Description1", false))
            saveTaskBlocking(Task("Title2", "Description2", true))
        }

        val scenario = launchFragmentInContainer<StatisticsFragment>(Bundle(), R.style.AppTheme)
        dataBindingIdlingResource.monitorFragment(scenario)

        val expectedActiveTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_active_tasks, 50.0f)
        val expectedCompletedTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_completed_tasks, 50.0f)
        
        onView(withId(R.id.stats_active_text)).check(matches(isDisplayed()))
        onView(withId(R.id.stats_active_text)).check(matches(withText(expectedActiveTaskText)))
        onView(withId(R.id.stats_completed_text)).check(matches(isDisplayed()))
        onView(withId(R.id.stats_completed_text)).check(matches(withText(expectedCompletedTaskText)))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import kotlinx.coroutines.ObsoleteCoroutinesApi
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@ObsoleteCoroutinesApi
@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class AddEditTaskFragmentTest {
    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetRepository()
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun validTask_isSaved() {
        
        val navController = mock(NavController::class.java)
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description)).perform(replaceText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        val tasks = (repository.getTasksBlocking(true) as Result.Success).data
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    @Test
    fun validTask_navigatesBack() {
        
        val navController = mock(NavController::class.java)
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description)).perform(replaceText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        verify(navController).navigate(
            AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK))
    }

    private fun launchFragment(navController: NavController?) {
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        val scenario = launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }
    }

}

<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import android.view.View
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ActivityScenario.launch
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Matcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetRepository()
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        verify(navController).navigate(
          TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
            null, getApplicationContext<Context>().getString(R.string.add_task)))
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        
        launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launch(TasksActivity::class.java)

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launch(TasksActivity::class.java)

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(doesNotExist())
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(matches(isDisplayed()))
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launch(TasksActivity::class.java)

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(R.string.menu_clear)).perform(click())

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())

        
        onView(withText("You have no tasks!")).check(matches(isDisplayed()))
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        
        onView(withText("You have no completed tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())

        
        onView(withText("You have no active tasks!")).check(matches((isDisplayed())))
    }

    private fun checkboxWithText(text: String) : Matcher<View> {
        return allOf(withId(R.id.complete), hasSibling(withText(text)))
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
class TaskDetailFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = FakeRepository()
        ServiceLocator.tasksRepository = repository
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetRepository()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        
        val activeTask = Task("Active Task", "AndroidX Rocks", false)
        repository.saveTaskBlocking(activeTask)

        
        val bundle = TaskDetailFragmentArgs(activeTask.id).toBundle()
        launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.AppTheme)

        
        
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_title)).check(matches(withText("Active Task")))
        onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
        
        onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        
        val completedTask = Task("Completed Task", "AndroidX Rocks", true)
        repository.saveTaskBlocking(completedTask)

        
        val bundle = TaskDetailFragmentArgs(completedTask.id).toBundle()
        launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.AppTheme)

        
        
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_title)).check(matches(withText("Completed Task")))
        onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
        
        onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import android.content.Context
import androidx.annotation.VisibleForTesting
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource
import kotlinx.coroutines.runBlocking


object ServiceLocator {

    private val lock = Any()
    private var database: ToDoDatabase? = null
    @Volatile var tasksRepository: TasksRepository? = null
        @VisibleForTesting set

    fun provideTasksRepository(context: Context): TasksRepository {
        synchronized(this) {
            return tasksRepository ?:
                tasksRepository ?: createTasksRepository(context)
        }
    }

    private fun createTasksRepository(context: Context): TasksRepository {
        database = Room.databaseBuilder(context.applicationContext,
            ToDoDatabase::class.java, "Tasks.db")
            .build()

        return DefaultTasksRepository(
            TasksRemoteDataSource,
            TasksLocalDataSource(database!!.taskDao())
        )
    }

    @VisibleForTesting
    fun resetRepository() {
        synchronized(lock) {
            runBlocking {
                TasksRemoteDataSource.deleteAllTasks()
            }
            
            database?.apply {
                clearAllTables()
                close()
            }
            tasksRepository = null
        }
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp

import android.content.Context
import androidx.annotation.VisibleForTesting
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import kotlinx.coroutines.runBlocking


object ServiceLocator {

    private val lock = Any()
    private var database: ToDoDatabase? = null
    @Volatile var tasksRepository: TasksRepository? = null
        @VisibleForTesting set

    fun provideTasksRepository(context: Context): TasksRepository {
        synchronized(this) {
            return tasksRepository ?:
                tasksRepository ?: createTasksRepository(context)
        }
    }

    private fun createTasksRepository(context: Context): TasksRepository {
        database = Room.databaseBuilder(context.applicationContext,
            ToDoDatabase::class.java, "Tasks.db")
            .build()

        return DefaultTasksRepository(
            FakeTasksRemoteDataSource,
            TasksLocalDataSource(database!!.taskDao())
        )
    }

    @VisibleForTesting
    fun resetRepository() {
        synchronized(lock) {
            runBlocking {
                FakeTasksRemoteDataSource.deleteAllTasks()
            }
            
            database?.apply {
                clearAllTables()
                close()
            }
            tasksRepository = null
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.Matchers.allOf
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private lateinit var repository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.deleteAllTasksBlocking()
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun createTask() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("title"))
        onView(withId(R.id.add_task_description)).perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task("TITLE1", DESCRIPTION))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("TITLE1")).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(withText("TITLE1")))
        onView(withId(R.id.task_detail_description)).check(matches(withText("DESCRIPTION")))
        onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))

        
        onView(withId(R.id.fab_edit_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(replaceText("NEW TITLE"))
        onView(withId(R.id.add_task_description)).perform(replaceText("NEW DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("NEW TITLE")).check(matches(isDisplayed()))
        
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE1"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("TITLE2")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMPLETED"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACTIVE"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        val taskTitle = "ACT-COMP"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION"))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        val taskTitle = "COMP-ACT"
        repository.saveTaskBlocking(Task(taskTitle, "DESCRIPTION", true))

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText(taskTitle)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(taskTitle))))
            .check(matches(isChecked()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.contrib.NavigationViewActions.navigateTo
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.DataBindingIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.monitorActivity
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private lateinit var tasksRepository: TasksRepository

    
    private val dataBindingIdlingResource = DataBindingIdlingResource()

    @Before
    fun init() {
        tasksRepository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun reset() {
        ServiceLocator.resetRepository()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().register(dataBindingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
        IdlingRegistry.getInstance().unregister(dataBindingIdlingResource)
    }

    @Test
    fun drawNavigationFromTasksToStatistics() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.statisticsFragment))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.tasksFragment))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        val task = Task("UI <- button", "Description")
        tasksRepository.saveTaskBlocking(task)

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("UI <- button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        val task = Task("Back button", "Description")
        tasksRepository.saveTaskBlocking(task)

        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        dataBindingIdlingResource.monitorActivity(activityScenario)

        
        onView(withText("Back button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        pressBack()
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        pressBack()
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap


class DefaultTasksRepository(
    private val tasksRemoteDataSource: TasksDataSource,
    private val tasksLocalDataSource: TasksDataSource,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) : TasksRepository {

    private var cachedTasks: ConcurrentMap<String, Task>? = null

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> =
        withContext(ioDispatcher) {
            
            if (!forceUpdate) {
                cachedTasks?.let { cachedTasks ->
                    return@withContext Success(cachedTasks.values.sortedBy { it.id })
                }
            }

            EspressoIdlingResource.increment() 

            val newTasks = fetchTasksFromRemoteOrLocal(forceUpdate)

            
            (newTasks as? Success)?.let { refreshCache(it.data) }

            EspressoIdlingResource.decrement() 

            cachedTasks?.values?.let { tasks ->
                return@withContext Result.Success(tasks.sortedBy { it.id })
            }

            (newTasks as? Success)?.let {
                if (it.data.isEmpty()) {
                    return@withContext Result.Success(it.data)
                }
            }

            return@withContext Result.Error(Exception("Illegal state"))
        }

    private suspend fun fetchTasksFromRemoteOrLocal(forceUpdate: Boolean): Result<List<Task>> {
        
        val remoteTasks = tasksRemoteDataSource.getTasks()
        when (remoteTasks) {
            is Result.Error -> Timber.w("Remote data source fetch failed")
            is Result.Success -> {
                refreshLocalDataSource(remoteTasks.data)
                return remoteTasks
            }
            else -> throw IllegalStateException()
        }

        
        if (forceUpdate) {
            return Result.Error(Exception("Can't force refresh: remote data source is unavailable"))
        }

        
        val localTasks = tasksLocalDataSource.getTasks()
        if (localTasks is Result.Success) return localTasks
        return Result.Error(Exception("Error fetching from remote and local"))
    }

    
    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> =
        withContext(ioDispatcher) {
            
            if (!forceUpdate) {
                getTaskWithId(taskId)?.let {
                    return@withContext Success(it)
                }
            }

            EspressoIdlingResource.increment() 

            val newTask = fetchTaskFromRemoteOrLocal(taskId, forceUpdate)

            
            (newTask as? Success)?.let { cacheTask(it.data) }

            EspressoIdlingResource.decrement() 

            return@withContext newTask
    }

    private suspend fun fetchTaskFromRemoteOrLocal(
        taskId: String,
        forceUpdate: Boolean
    ): Result<Task> {
        
        val remoteTask = tasksRemoteDataSource.getTask(taskId)
        when (remoteTask) {
            is Result.Error -> Timber.w("Remote data source fetch failed")
            is Result.Success -> {
                refreshLocalDataSource(remoteTask.data)
                return remoteTask
            }
            else -> throw IllegalStateException()
        }

        
        if (forceUpdate) {
            return Result.Error(Exception("Refresh failed"))
        }

        
        val localTasks = tasksLocalDataSource.getTask(taskId)
        if (localTasks is Result.Success) return localTasks
        return Result.Error(Exception("Error fetching from remote and local"))
    }

    override suspend fun saveTask(task: Task) {
        
        cacheAndPerform(task) {
            coroutineScope {
                launch { tasksRemoteDataSource.saveTask(it) }
                launch { tasksLocalDataSource.saveTask(it) }
            }
        }
    }

    override suspend fun completeTask(task: Task) {
        
        cacheAndPerform(task) {
            it.isCompleted = true
            coroutineScope {
                launch { tasksRemoteDataSource.completeTask(it) }
                launch { tasksLocalDataSource.completeTask(it) }
            }
        }
    }

    override suspend fun completeTask(taskId: String) {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let {
                completeTask(it)
            }
        }
    }

    override suspend fun activateTask(task: Task) = withContext(ioDispatcher) {
        
        cacheAndPerform(task) {
            it.isCompleted = false
            coroutineScope {
                launch { tasksRemoteDataSource.activateTask(it) }
                launch { tasksLocalDataSource.activateTask(it) }
            }

        }
    }

    override suspend fun activateTask(taskId: String)  {
        withContext(ioDispatcher) {
            getTaskWithId(taskId)?.let {
                activateTask(it)
            }
        }
    }

    override suspend fun clearCompletedTasks() {
        coroutineScope {
            launch { tasksRemoteDataSource.clearCompletedTasks() }
            launch { tasksLocalDataSource.clearCompletedTasks() }
        }
        withContext(ioDispatcher) {
            cachedTasks?.entries?.removeAll { it.value.isCompleted }
        }
    }

    override suspend fun deleteAllTasks() {
        withContext(ioDispatcher) {
            coroutineScope {
                launch { tasksRemoteDataSource.deleteAllTasks() }
                launch { tasksLocalDataSource.deleteAllTasks() }
            }
        }
        cachedTasks?.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        coroutineScope {
            launch { tasksRemoteDataSource.deleteTask(taskId) }
            launch { tasksLocalDataSource.deleteTask(taskId) }
        }

        cachedTasks?.remove(taskId)
        Unit 
    }

    private fun refreshCache(tasks: List<Task>) {
        cachedTasks?.clear()
        tasks.sortedBy { it.id }.forEach {
            cacheAndPerform(it) {}
        }
    }

    private suspend fun refreshLocalDataSource(tasks: List<Task>) {
        tasksLocalDataSource.deleteAllTasks()
        for (task in tasks) {
            tasksLocalDataSource.saveTask(task)
        }
    }

    private suspend fun refreshLocalDataSource(task: Task) {
        tasksLocalDataSource.saveTask(task)
    }

    private fun getTaskWithId(id: String) = cachedTasks?.get(id)

    private fun cacheTask(task: Task): Task {
        val cachedTask = Task(task.title, task.description, task.isCompleted, task.id)
        
        if (cachedTasks == null) {
            cachedTasks = ConcurrentHashMap()
        }
        cachedTasks?.put(cachedTask.id, cachedTask)
        return cachedTask
    }

    private inline fun cacheAndPerform(task: Task, perform: (Task) -> Unit) {
        val cachedTask = cacheTask(task)
        perform(cachedTask)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.remote

import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.google.common.collect.Lists
import kotlinx.coroutines.delay


object TasksRemoteDataSource : TasksDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 5000L

    private var TASKS_SERVICE_DATA = LinkedHashMap<String, Task>(2)

    init {
        addTask("Build tower in Pisa", "Ground looks good, no foundation work required.")
        addTask("Finish bridge in Tacoma", "Found awesome girders at half the cost!")
    }

    
    override suspend fun getTasks(): Result<List<Task>> {
        
        val tasks = Lists.newArrayList(TASKS_SERVICE_DATA.values)
        delay(SERVICE_LATENCY_IN_MILLIS)
        return Success(tasks)
    }

    
    override suspend fun getTask(taskId: String): Result<Task> {

        
        delay(SERVICE_LATENCY_IN_MILLIS)
        TASKS_SERVICE_DATA[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Task not found"))
    }

    private fun addTask(title: String, description: String) {
        val newTask = Task(title, description)
        TASKS_SERVICE_DATA.put(newTask.id, newTask)
    }
    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA.put(task.id, task)
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, true, task.id)
        TASKS_SERVICE_DATA.put(task.id, completedTask)
    }

    override suspend fun completeTask(taskId: String) {
        
        
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, false, task.id)
        TASKS_SERVICE_DATA.put(task.id, activeTask)
    }

    override suspend fun activateTask(taskId: String) {
        
        
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_saved_task_message)
            )
            ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_added_task_message)
            )
            DELETE_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_deleted_task_message)
            )
        }

    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) {

        _dataLoading.value = true

        viewModelScope.launch {
            val tasksResult = tasksRepository.getTasks(forceUpdate)

            if (tasksResult is Success) {
                val tasks = tasksResult.data

                val tasksToShow = ArrayList<Task>()
                
                for (task in tasks) {
                    when (_currentFiltering) {
                        TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                        TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                            tasksToShow.add(task)
                        }
                        TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                            tasksToShow.add(task)
                        }
                    }
                }
                isDataLoadingError.value = false
                _items.value = ArrayList(tasksToShow)
            } else {
                isDataLoadingError.value = false
                _items.value = emptyList()
                _snackbarText.value = Event(R.string.loading_tasks_error)
            }

            _dataLoading.value = false
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source.local

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.succeeded
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
class TasksLocalDataSourceTest {

    private lateinit var localDataSource: TasksLocalDataSource
    private lateinit var database: ToDoDatabase

    @Before
    fun setup() {
        
        database = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),
            ToDoDatabase::class.java)
            .allowMainThreadQueries()
            .build()

        localDataSource = TasksLocalDataSource(database.taskDao())
    }

    @After
    fun cleanUp() {
        database.close()
    }

    @Test
    fun saveTask_retrievesTask() = runBlocking {
        
        val newTask = Task("title", "description", true)
        localDataSource.saveTask(newTask)

        
        val result = localDataSource.getTask(newTask.id)

        
        assertThat(result.succeeded).isTrue()
        result as Result.Success
        assertThat(result.data.title).isEqualTo("title")
        assertThat(result.data.description).isEqualTo("description")
        assertThat(result.data.isCompleted).isTrue()
    }

    @Test
    fun completeTask_retrievedTaskIsComplete() = runBlocking {
        
        val newTask = Task("title")
        localDataSource.saveTask(newTask)

        
        localDataSource.completeTask(newTask)
        val result = localDataSource.getTask(newTask.id)

        
        assertThat(result.succeeded).isTrue()
        result as Result.Success
        assertThat(result.data.title).isEqualTo(newTask.title)
        assertThat(result.data.isCompleted).isTrue()
    }

    @Test
    fun activateTask_retrievedTaskIsActive() = runBlocking {
        
        val newTask = Task("Some title", "Some description", true)
        localDataSource.saveTask(newTask)

        localDataSource.activateTask(newTask)

        
        val result = localDataSource.getTask(newTask.id)

        assertThat(result.succeeded).isTrue()
        result as Result.Success

        assertThat(result.data.title).isEqualTo("Some title")
        assertThat(result.data.isCompleted).isFalse()
    }

    @Test
    fun clearCompletedTask_taskNotRetrievable() = runBlocking {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title2")
        val newTask3 = Task("title3")
        localDataSource.saveTask(newTask1)
        localDataSource.completeTask(newTask1)
        localDataSource.saveTask(newTask2)
        localDataSource.completeTask(newTask2)
        localDataSource.saveTask(newTask3)
        
        localDataSource.clearCompletedTasks()

        
        assertThat(localDataSource.getTask(newTask1.id).succeeded).isFalse()
        assertThat(localDataSource.getTask(newTask2.id).succeeded).isFalse()

        val result3 = localDataSource.getTask(newTask3.id)

        assertThat(result3.succeeded).isTrue()
        result3 as Result.Success

        assertThat(result3.data).isEqualTo(newTask3)
    }

    @Test
    fun deleteAllTasks_emptyListOfRetrievedTask() = runBlocking {
        
        val newTask = Task("title")

        localDataSource.saveTask(newTask)

        
        localDataSource.deleteAllTasks()

        
        val result = localDataSource.getTasks() as Result.Success
        assertThat(result.data).isEmpty()

    }

    @Test
    fun getTasks_retrieveSavedTasks() = runBlocking {
        
        val newTask1 = Task("title")
        val newTask2 = Task("title")

        localDataSource.saveTask(newTask1)
        localDataSource.saveTask(newTask2)
        
        val results = localDataSource.getTasks() as Result.Success<List<Task>>
        val tasks = results.data
        assertThat(tasks).hasSize(2)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@MediumTest
class StatisticsFragmentTest {
    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetForTests()
    }

    @Test
    fun tasks_showsNonEmptyMessage() {
        
        repository.apply {
            saveTaskBlocking(Task("Title1", "Description1", false))
            saveTaskBlocking(Task("Title2", "Description2", true))
        }

        launchFragmentInContainer<StatisticsFragment>(Bundle(), R.style.AppTheme)
        val expectedActiveTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_active_tasks, 50.0f)
        val expectedCompletedTaskText = getApplicationContext<Context>()
            .getString(R.string.statistics_completed_tasks, 50.0f)
        
        onView(withId(R.id.stats_active_text)).check(matches(isDisplayed()))
        onView(withId(R.id.stats_active_text)).check(matches(withText(expectedActiveTaskText)))
        onView(withId(R.id.stats_completed_text)).check(matches(isDisplayed()))
        onView(withId(R.id.stats_completed_text)).check(matches(withText(expectedCompletedTaskText)))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.content.Context
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.clearText
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getTasksBlocking
import kotlinx.coroutines.ObsoleteCoroutinesApi
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode


@ObsoleteCoroutinesApi
@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class AddEditTaskFragmentTest {
    private lateinit var repository: TasksRepository

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    @Before
    fun initRepository() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetForTests()
    }

    @Test
    fun emptyTask_isNotSaved() {
        
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)

        
        onView(withId(R.id.add_task_title)).perform(clearText())
        onView(withId(R.id.add_task_description)).perform(clearText())
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).check(matches(isDisplayed()))
    }

    @Test
    fun validTask_isSaved() {
        
        val navController = mock(NavController::class.java)
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description)).perform(replaceText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        val tasks = (repository.getTasksBlocking(true) as Result.Success).data
        assertEquals(tasks.size, 1)
        assertEquals(tasks[0].title, "title")
        assertEquals(tasks[0].description, "description")
    }

    @Test
    fun validTask_navigatesBack() {
        
        val navController = mock(NavController::class.java)
        launchFragment(navController)

        
        onView(withId(R.id.add_task_title)).perform(replaceText("title"))
        onView(withId(R.id.add_task_description)).perform(replaceText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        repository.getTasksBlocking(true)

        
        verify(navController).navigate(
            AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK))
    }

    private fun launchFragment(navController: NavController?) {
        val bundle = AddEditTaskFragmentArgs(null,
            getApplicationContext<Context>().getString(R.string.add_task)).toBundle()
        val scenario = launchFragmentInContainer<AddEditTaskFragment>(bundle, R.style.AppTheme)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }
    }

}

<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import android.view.View
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ActivityScenario.launch
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Matcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetForTests()
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        verify(navController).navigate(
          TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
            null, getApplicationContext<Context>().getString(R.string.add_task)))
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        
        launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        launch(TasksActivity::class.java)

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        launch(TasksActivity::class.java)

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(doesNotExist())
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(matches(isDisplayed()))
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        launch(TasksActivity::class.java)

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(R.string.menu_clear)).perform(click())

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())

        
        onView(withText("You have no tasks!")).check(matches(isDisplayed()))
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        
        onView(withText("You have no completed tasks!")).check(matches((isDisplayed())))
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())

        
        onView(withText("You have no active tasks!")).check(matches((isDisplayed())))
    }

    private fun checkboxWithText(text: String) : Matcher<View> {
        return allOf(withId(R.id.complete), hasSibling(withText(text)))
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import kotlinx.coroutines.runBlocking
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@MediumTest
@RunWith(AndroidJUnit4::class)
class TaskDetailFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun initRepository() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun cleanupDb() = runBlocking {
        ServiceLocator.resetForTests()
    }

    @Test
    fun activeTaskDetails_DisplayedInUi() {
        
        val activeTask = Task("Active Task", "AndroidX Rocks", false)
        repository.saveTaskBlocking(activeTask)

        
        val bundle = TaskDetailFragmentArgs(activeTask.id).toBundle()
        launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.AppTheme)

        
        
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_title)).check(matches(withText("Active Task")))
        onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
        
        onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))
    }

    @Test
    fun completedTaskDetails_DisplayedInUi() {
        
        val completedTask = Task("Completed Task", "AndroidX Rocks", true)
        repository.saveTaskBlocking(completedTask)

        
        val bundle = TaskDetailFragmentArgs(completedTask.id).toBundle()
        launchFragmentInContainer<TaskDetailFragment>(bundle, R.style.AppTheme)

        
        
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_title)).check(matches(withText("Completed Task")))
        onView(withId(R.id.task_detail_description)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_description)).check(matches(withText("AndroidX Rocks")))
        
        onView(withId(R.id.task_detail_complete)).check(matches(isDisplayed()))
        onView(withId(R.id.task_detail_complete)).check(matches(isChecked()))
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import android.content.Context
import androidx.annotation.VisibleForTesting
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import com.example.android.architecture.blueprints.todoapp.data.source.remote.TasksRemoteDataSource


object ServiceLocator {

    @Volatile var tasksRepository: TasksRepository? = null

    fun provideTasksRepository(context: Context): TasksRepository {
        return tasksRepository ?: synchronized(this) {
            tasksRepository ?: createTasksRepository(context)
        }
    }

    private fun createTasksRepository(context: Context): TasksRepository {
        val database= Room.databaseBuilder(context.applicationContext,
            ToDoDatabase::class.java, "Tasks.db")
            .build()
        return DefaultTasksRepository(
            TasksRemoteDataSource,
            TasksLocalDataSource(database.taskDao())
        )
    }

    fun resetForTests() {
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp

import android.content.Context
import androidx.room.Room
import com.example.android.architecture.blueprints.todoapp.data.FakeTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.local.TasksLocalDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.local.ToDoDatabase
import kotlinx.coroutines.runBlocking



object ServiceLocator {

    private val lock = Any()
    private lateinit var database: ToDoDatabase
    private var tasksRepository: TasksRepository? = null

    fun provideTasksRepository(context: Context): TasksRepository {
        synchronized(this) {
            return tasksRepository ?:
                tasksRepository ?: createTasksRepository(context)
        }
    }

    private fun createTasksRepository(context: Context): TasksRepository {
        database = Room.databaseBuilder(context.applicationContext,
            ToDoDatabase::class.java, "Tasks.db")
            .allowMainThreadQueries()
            .build()

        return DefaultTasksRepository(
            FakeTasksRemoteDataSource,
            TasksLocalDataSource(database.taskDao())
        )
    }

    fun resetForTests() {
        synchronized(lock) {
            runBlocking {
                FakeTasksRemoteDataSource.deleteAllTasks()
            }
            
            database.clearAllTables()
            database.close()
            tasksRepository = null
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.Matchers.allOf
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private lateinit var repository: TasksRepository

    @Before
    fun resetState() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun reset() {
        ServiceLocator.resetForTests()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    @Test
    fun createTask() {
        
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title))
          .perform(typeText("title"))
        onView(withId(R.id.add_task_description))
          .perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(withText("TITLE1")))
        onView(withId(R.id.task_detail_description)).check(matches(withText("DESCRIPTION")))
        onView(withId(R.id.task_detail_complete)).check(matches(not(isChecked())))

        
        onView(withId(R.id.fab_edit_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(replaceText("NEW TITLE"))
        onView(withId(R.id.add_task_description)).perform(replaceText("NEW DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("NEW TITLE")).check(matches(isDisplayed()))
        
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE1"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE1"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE2"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("TITLE2")).perform(click())
        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION", true))
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION", true))
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())
        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(isChecked()))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.app.Activity
import android.view.Gravity
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.findNavController
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.contrib.DrawerActions.open
import androidx.test.espresso.contrib.DrawerMatchers.isClosed
import androidx.test.espresso.contrib.DrawerMatchers.isOpen
import androidx.test.espresso.contrib.NavigationViewActions.navigateTo
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withContentDescription
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.filters.LargeTest
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class AppNavigationTest {

    private lateinit var tasksRepository: TasksRepository

    @Before
    fun init() {
        tasksRepository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun reset() {
        ServiceLocator.resetForTests()
    }

    @Test
    fun drawNavigationFromTasksToStatistics() {
        
        ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.statisticsFragment))

        
        onView(withId(R.id.statistics)).check(matches(isDisplayed()))

        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 
            .perform(open()) 

        
        onView(withId(R.id.nav_view))
            .perform(navigateTo(R.id.tasksFragment))

        
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun tasksScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun statsScreen_clickOnAndroidHomeIcon_OpensNavigation() {
        
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        activityScenario.onActivity {
            it.findNavController(R.id.nav_host_fragment).navigate(R.id.statisticsFragment)
        }

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isClosed(Gravity.START))) 

        
        onView(
            withContentDescription(
                activityScenario
                    .getToolbarNavigationContentDescription()
            )
        ).perform(click())

        
        onView(withId(R.id.drawer_layout))
            .check(matches(isOpen(Gravity.START))) 
    }

    @Test
    fun taskDetailScreen_doubleUIBackButton() {
        val task = Task("UI <- button", "Description")
        tasksRepository.saveTaskBlocking(task)

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("UI <- button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        onView(
          withContentDescription(
            activityScenario
              .getToolbarNavigationContentDescription()
          )
        ).perform(click())
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    @Test
    fun taskDetailScreen_doubleBackButton() {
        val task = Task("Back button", "Description")
        tasksRepository.saveTaskBlocking(task)

        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("Back button")).perform(click())
        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        pressBack()
        onView(withId(R.id.task_detail_title)).check(matches(isDisplayed()))

        
        pressBack()
        onView(withId(R.id.tasksContainer)).check(matches(isDisplayed()))
    }

    private fun <T : Activity> ActivityScenario<T>.getToolbarNavigationContentDescription()
        : String {
        var description = ""
        onActivity {
            description =
                it.findViewById<Toolbar>(R.id.toolbar).navigationContentDescription as String
        }
        return description
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskViewModel
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsViewModel
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailViewModel
import com.example.android.architecture.blueprints.todoapp.tasks.TasksViewModel


@Suppress("UNCHECKED_CAST")
class ViewModelFactory constructor(
        private val tasksRepository: TasksRepository
) : ViewModelProvider.NewInstanceFactory() {

    override fun <T : ViewModel> create(modelClass: Class<T>) =
        with(modelClass) {
            when {
                isAssignableFrom(StatisticsViewModel::class.java) ->
                    StatisticsViewModel(tasksRepository)
                isAssignableFrom(TaskDetailViewModel::class.java) ->
                    TaskDetailViewModel(tasksRepository)
                isAssignableFrom(AddEditTaskViewModel::class.java) ->
                    AddEditTaskViewModel(tasksRepository)
                isAssignableFrom(TasksViewModel::class.java) ->
                    TasksViewModel(tasksRepository)
                else ->
                    throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
            }
        } as T
}

<code block>

package com.example.android.architecture.blueprints.todoapp.util



import android.view.View
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ScrollChildSwipeRefreshLayout
import com.google.android.material.snackbar.Snackbar


fun View.showSnackbar(snackbarText: String, timeLength: Int) {
    Snackbar.make(this, snackbarText, timeLength).run {
        addCallback(object: Snackbar.Callback() {
            override fun onShown(sb: Snackbar?) {
                EspressoIdlingResource.increment()
            }

            override fun onDismissed(transientBottomBar: Snackbar?, event: Int) {
                EspressoIdlingResource.decrement()
            }
        })
        show()
    }
}


fun View.setupSnackbar(
    lifecycleOwner: LifecycleOwner,
    snackbarEvent: LiveData<Event<Int>>,
    timeLength: Int
) {

    snackbarEvent.observe(lifecycleOwner, Observer { event ->
        event.getContentIfNotHandled()?.let {
            showSnackbar(context.getString(it), timeLength)
        }
    })
}

fun Fragment.setupRefreshLayout(
    refreshLayout: ScrollChildSwipeRefreshLayout,
    scrollUpChild: View? = null
) {
    refreshLayout.setColorSchemeColors(
        ContextCompat.getColor(requireActivity(), R.color.colorPrimary),
        ContextCompat.getColor(requireActivity(), R.color.colorAccent),
        ContextCompat.getColor(requireActivity(), R.color.colorPrimaryDark)
    )
    
    scrollUpChild?.let {
        refreshLayout.scrollUpChild = it
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch


class StatisticsViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _error = MutableLiveData<Boolean>()
    val error: LiveData<Boolean> = _error

    
    private val _empty = MutableLiveData<Boolean>()
    val empty: LiveData<Boolean> = _empty

    private val _activeTasksPercent = MutableLiveData<Float>()
    val activeTasksPercent: LiveData<Float> = _activeTasksPercent

    private val _completedTasksPercent = MutableLiveData<Float>()
    val completedTasksPercent: LiveData<Float> = _completedTasksPercent

    private var activeTasks = 0

    private var completedTasks = 0

    init {
        start()
    }

    fun start() {
        if (_dataLoading.value == true) {
            return
        }
        _dataLoading.value = true

        wrapEspressoIdlingResource {
            viewModelScope.launch {
                tasksRepository.getTasks().let { result ->
                    if (result is Success) {
                        _error.value = false
                        computeStats(result.data)
                    } else {
                        _error.value = true
                        activeTasks = 0
                        completedTasks = 0
                        computeStats(null)
                    }
                }
            }
        }
    }

    fun refresh() {
        start()
    }

    
    private fun computeStats(tasks: List<Task>?) {
        getActiveAndCompletedStats(tasks).let {
            _activeTasksPercent.value = it.activeTasksPercent
            _completedTasksPercent.value = it.completedTasksPercent
        }
        _empty.value = tasks.isNullOrEmpty()
        _dataLoading.value = false
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val statisticsViewModel by viewModels<StatisticsViewModel> { getVmFactory() }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.statistics_frag, container,
                false)
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.viewmodel = statisticsViewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        statisticsViewModel.start()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> =_dataLoading

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdated = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdated

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        if (_dataLoading.value == true) {
            return
        }

        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }

        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription).isEmpty) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, taskCompleted, currentTaskId)
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) = viewModelScope.launch {
        tasksRepository.saveTask(newTask)
        _taskUpdated.value = Event(Unit)
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdated.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    private val args: AddEditTaskFragmentArgs by navArgs()

    private val viewModel by viewModels<AddEditTaskViewModel> { getVmFactory() }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            this.viewmodel = viewModel
        }
        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupSnackbar()
        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
        viewModel.start(args.taskId)
    }

    private fun setupSnackbar() {
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_SHORT)
        }
    }

    private fun setupNavigation() {
        viewModel.taskUpdatedEvent.observe(this, EventObserver {
            val action = AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
            findNavController().navigate(action)
        })
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber
import java.util.ArrayList


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getVmFactory() }

    private lateinit var viewDataBinding: TasksFragBinding
    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewDataBinding.viewmodel?.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewModel.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout(viewDataBinding.refreshLayout, viewDataBinding.tasksList)
        setupNavigation()
        setupFab()

        
        
        viewModel.loadTasks(true)
    }

    private fun setupNavigation() {
        viewDataBinding.viewmodel?.openTaskEvent?.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewDataBinding.viewmodel?.newTaskEvent?.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_SHORT)
        }
        arguments?.let {
            val message = TasksFragmentArgs.fromBundle(it).userMessage
            viewDataBinding.viewmodel?.showEditResultMessage(message)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewDataBinding.viewmodel?.run {
                    setFiltering(
                            when (it.itemId) {
                                R.id.active -> TasksFilterType.ACTIVE_TASKS
                                R.id.completed -> TasksFilterType.COMPLETED_TASKS
                                else -> TasksFilterType.ALL_TASKS
                            }
                    )
                    loadTasks(false)
                }
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(null,
                resources.getString(R.string.add_task))
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(ArrayList(0), viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
        loadTasks(true)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_saved_task_message)
            )
            ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_added_task_message)
            )
            DELETE_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_deleted_task_message)
            )
        }

    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) {
        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                val tasksResult = tasksRepository.getTasks(forceUpdate)

                if (tasksResult is Success) {
                    val tasks = tasksResult.data

                    val tasksToShow = ArrayList<Task>()
                    
                    for (task in tasks) {
                        when (_currentFiltering) {
                            TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                            TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                                tasksToShow.add(task)
                            }
                            TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                                tasksToShow.add(task)
                            }
                        }
                    }
                    isDataLoadingError.value = false
                    _items.value = ArrayList(tasksToShow)
                } else {
                    isDataLoadingError.value = false
                    _items.value = emptyList()
                    _snackbarText.value = Event(R.string.loading_tasks_error)
                }

                _dataLoading.value = false
            }
        }
    }

    fun refresh() {
        loadTasks(true)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupRefreshLayout
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {
    private lateinit var viewDataBinding: TaskdetailFragBinding

    private val args: TaskDetailFragmentArgs by navArgs()

    private val viewModel by viewModels<TaskDetailViewModel> { getVmFactory() }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_SHORT)
        }

        setupNavigation()
        this.setupRefreshLayout(viewDataBinding.refreshLayout)
    }

    private fun setupNavigation() {
        viewModel.deleteTaskCommand.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToTasksFragment(DELETE_RESULT_OK)
            findNavController().navigate(action)
        })
        viewModel.editTaskCommand.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToAddEditTaskFragment(args.taskId,
                    resources.getString(R.string.edit_task))
            findNavController().navigate(action)
        })
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.fab_edit_task)?.setOnClickListener {
            viewDataBinding.viewmodel?.editTask()
        }
    }

    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = viewModel
            listener = object : TaskDetailUserActionsListener {
                override fun onCompleteChanged(v: View) {
                    viewmodel?.setCompleted((v as CheckBox).isChecked)
                }
            }
        }
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner

        viewModel.start(args.taskId)

        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewDataBinding.viewmodel?.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _task = MutableLiveData<Task>()
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskCommand = MutableLiveData<Event<Unit>>()
    val editTaskCommand: LiveData<Event<Unit>> = _editTaskCommand

    private val _deleteTaskCommand = MutableLiveData<Event<Unit>>()
    val deleteTaskCommand: LiveData<Event<Unit>> = _deleteTaskCommand

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val taskId: String?
        get() = _task.value?.id

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }


    fun deleteTask() = viewModelScope.launch {
        taskId?.let {
            tasksRepository.deleteTask(it)
            _deleteTaskCommand.value = Event(Unit)
        }
    }

    fun editTask() {
        _editTaskCommand.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = _task.value ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun start(taskId: String?, forceRefresh: Boolean = false) {
        if (_isDataAvailable.value == true && !forceRefresh || _dataLoading.value == true) {
            return
        }

        
        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                if (taskId != null) {
                    tasksRepository.getTask(taskId, false).let { result ->
                        if (result is Success) {
                            onTaskLoaded(result.data)
                        } else {
                            onDataNotAvailable(result)
                        }
                    }
                }
                _dataLoading.value = false
            }
        }
    }

    private fun setTask(task: Task?) {
        this._task.value = task
        _isDataAvailable.value = task != null
    }

    private fun onTaskLoaded(task: Task) {
        setTask(task)
    }

    private fun onDataNotAvailable(result: Result<Task>) {
        _task.value = null
        _isDataAvailable.value = false
    }

    fun refresh() {
        taskId?.let { start(it, true) }
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.android.architecture.blueprints.todoapp.addedittask.AddEditTaskViewModel
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.statistics.StatisticsViewModel
import com.example.android.architecture.blueprints.todoapp.taskdetail.TaskDetailViewModel
import com.example.android.architecture.blueprints.todoapp.tasks.TasksViewModel


class ViewModelFactory constructor(
        private val tasksRepository: TasksRepository
) : ViewModelProvider.NewInstanceFactory() {

    override fun <T : ViewModel> create(modelClass: Class<T>) =
            with(modelClass) {
                when {
                    isAssignableFrom(StatisticsViewModel::class.java) ->
                        StatisticsViewModel(tasksRepository)
                    isAssignableFrom(TaskDetailViewModel::class.java) ->
                        TaskDetailViewModel(tasksRepository)
                    isAssignableFrom(AddEditTaskViewModel::class.java) ->
                        AddEditTaskViewModel(tasksRepository)
                    isAssignableFrom(TasksViewModel::class.java) ->
                        TasksViewModel(tasksRepository)
                    else ->
                        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
                }
            } as T
}

<code block>

package com.example.android.architecture.blueprints.todoapp.util



import android.view.View
import androidx.databinding.BindingAdapter
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.ScrollChildSwipeRefreshLayout
import com.example.android.architecture.blueprints.todoapp.tasks.TasksViewModel
import com.google.android.material.snackbar.Snackbar


fun View.showSnackbar(snackbarText: String, timeLength: Int) {
    Snackbar.make(this, snackbarText, timeLength).run {
        addCallback(object: Snackbar.Callback() {
            override fun onShown(sb: Snackbar?) {
                EspressoIdlingResource.increment()
            }

            override fun onDismissed(transientBottomBar: Snackbar?, event: Int) {
                EspressoIdlingResource.decrement()
            }
        })
        show()
    }
}


fun View.setupSnackbar(
    lifecycleOwner: LifecycleOwner,
    snackbarEvent: LiveData<Event<Int>>,
    timeLength: Int
) {

    snackbarEvent.observe(lifecycleOwner, Observer { event ->
        event.getContentIfNotHandled()?.let {
            showSnackbar(context.getString(it), timeLength)
        }
    })
}


@BindingAdapter("android:onRefresh")
fun ScrollChildSwipeRefreshLayout.setSwipeRefreshLayoutOnRefreshListener(
        viewModel: TasksViewModel) {
    setOnRefreshListener { viewModel.loadTasks(true) }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch


class StatisticsViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _error = MutableLiveData<Boolean>()
    val error: LiveData<Boolean> = _error

    
    private val _empty = MutableLiveData<Boolean>()
    val empty: LiveData<Boolean> = _empty

    private val _activeTasksPercent = MutableLiveData<Float>()
    val activeTasksPercent: LiveData<Float> = _activeTasksPercent

    private val _completedTasksPercent = MutableLiveData<Float>()
    val completedTasksPercent: LiveData<Float> = _completedTasksPercent

    private var activeTasks = 0

    private var completedTasks = 0

    fun start() {
        _dataLoading.value = true

        wrapEspressoIdlingResource {
            viewModelScope.launch {
                tasksRepository.getTasks().let { result ->
                    if (result is Success) {
                        _error.value = false
                        computeStats(result.data)
                    } else {
                        _error.value = true
                        activeTasks = 0
                        completedTasks = 0
                        computeStats(null)
                    }
                }
            }
        }
    }

    
    private fun computeStats(tasks: List<Task>?) {
        getActiveAndCompletedStats(tasks).let {
            _activeTasksPercent.value = it.activeTasksPercent
            _completedTasksPercent.value = it.completedTasksPercent
        }
        _empty.value = tasks.isNullOrEmpty()
        _dataLoading.value = false
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.StatisticsFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory


class StatisticsFragment : Fragment() {

    private lateinit var viewDataBinding: StatisticsFragBinding

    private val statisticsViewModel by viewModels<StatisticsViewModel> { getVmFactory() }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.statistics_frag, container,
                false)
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewDataBinding.stats = statisticsViewModel
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
    }

    override fun onResume() {
        super.onResume()
        statisticsViewModel.start()
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> =_dataLoading

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdated = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdated

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        _dataLoading.value?.let { isLoading ->
            
            if (isLoading) return
        }
        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }
        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription).isEmpty) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, taskCompleted, currentTaskId)
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) = viewModelScope.launch {
        tasksRepository.saveTask(newTask)
        _taskUpdated.value = Event(Unit)
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdated.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.AddtaskFragBinding
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class AddEditTaskFragment : Fragment() {

    private lateinit var viewDataBinding: AddtaskFragBinding

    private val viewModel by viewModels<AddEditTaskViewModel> { getVmFactory() }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {
        val root = inflater.inflate(R.layout.addtask_frag, container, false)
        viewDataBinding = AddtaskFragBinding.bind(root).apply {
            this.viewmodel = viewModel
        }
        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        return viewDataBinding.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupSnackbar()
        setupNavigation()
        loadData()
    }

    private fun setupSnackbar() {
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_SHORT)
        }
    }

    private fun setupNavigation() {
        viewModel.taskUpdatedEvent.observe(this, EventObserver {
            val action = AddEditTaskFragmentDirections
                .actionAddEditTaskFragmentToTasksFragment(ADD_EDIT_RESULT_OK)
            findNavController().navigate(action)
        })
    }

    private fun loadData() {
        
        viewDataBinding.viewmodel?.start(getTaskId())
    }

    private fun getTaskId(): String? {
        return arguments?.let {
            AddEditTaskFragmentArgs.fromBundle(it).TASKID
        }
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.PopupMenu
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.databinding.TasksFragBinding
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.snackbar.Snackbar
import timber.log.Timber
import java.util.ArrayList


class TasksFragment : Fragment() {

    private val viewModel by viewModels<TasksViewModel> { getVmFactory() }

    private lateinit var viewDataBinding: TasksFragBinding
    private lateinit var listAdapter: TasksAdapter

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?): View? {
        viewDataBinding = TasksFragBinding.inflate(inflater, container, false).apply {
            viewmodel = viewModel
        }
        setHasOptionsMenu(true)
        return viewDataBinding.root
    }

    override fun onOptionsItemSelected(item: MenuItem) =
        when (item.itemId) {
            R.id.menu_clear -> {
                viewDataBinding.viewmodel?.clearCompletedTasks()
                true
            }
            R.id.menu_filter -> {
                showFilteringPopUpMenu()
                true
            }
            R.id.menu_refresh -> {
                viewDataBinding.viewmodel?.loadTasks(true)
                true
            }
            else -> false
        }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.tasks_fragment_menu, menu)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)

        
        viewDataBinding.lifecycleOwner = this.viewLifecycleOwner
        setupSnackbar()
        setupListAdapter()
        setupRefreshLayout()
        setupNavigation()
        setupFab()
        viewDataBinding.viewmodel?.loadTasks(true)
    }

    private fun setupNavigation() {
        viewDataBinding.viewmodel?.openTaskEvent?.observe(this, EventObserver {
            openTaskDetails(it)
        })
        viewDataBinding.viewmodel?.newTaskEvent?.observe(this, EventObserver {
            navigateToAddNewTask()
        })
    }

    private fun setupSnackbar() {
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_SHORT)
        }
        arguments?.let {
            val message = TasksFragmentArgs.fromBundle(it).userMessage
            viewDataBinding.viewmodel?.showEditResultMessage(message)
        }
    }

    private fun showFilteringPopUpMenu() {
        val view = activity?.findViewById<View>(R.id.menu_filter) ?: return
        PopupMenu(requireContext(), view).run {
            menuInflater.inflate(R.menu.filter_tasks, menu)

            setOnMenuItemClickListener {
                viewDataBinding.viewmodel?.run {
                    setFiltering(
                            when (it.itemId) {
                                R.id.active -> TasksFilterType.ACTIVE_TASKS
                                R.id.completed -> TasksFilterType.COMPLETED_TASKS
                                else -> TasksFilterType.ALL_TASKS
                            }
                    )
                    loadTasks(false)
                }
                true
            }
            show()
        }
    }

    private fun setupFab() {
        activity?.findViewById<FloatingActionButton>(R.id.fab_add_task)?.let {
            it.setOnClickListener {
                navigateToAddNewTask()
            }
        }
    }

    private fun navigateToAddNewTask() {
        val action = TasksFragmentDirections
            .actionTasksFragmentToAddEditTaskFragment(null,
                resources.getString(R.string.add_task))
        findNavController().navigate(action)
    }

    private fun openTaskDetails(taskId: String) {
        val action = TasksFragmentDirections.actionTasksFragmentToTaskDetailFragment(taskId)
        findNavController().navigate(action)
    }

    private fun setupListAdapter() {
        val viewModel = viewDataBinding.viewmodel
        if (viewModel != null) {
            listAdapter = TasksAdapter(ArrayList(0), viewModel)
            viewDataBinding.tasksList.adapter = listAdapter
        } else {
            Timber.w("ViewModel not initialized when attempting to set up adapter.")
        }
    }

    private fun setupRefreshLayout() {
        viewDataBinding.refreshLayout.run {
            setColorSchemeColors(
                    ContextCompat.getColor(requireActivity(), R.color.colorPrimary),
                    ContextCompat.getColor(requireActivity(), R.color.colorAccent),
                    ContextCompat.getColor(requireActivity(), R.color.colorPrimaryDark)
            )
            
            scrollUpChild = viewDataBinding.tasksList
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.logo_no_fill, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_96dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_96dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_saved_task_message)
            )
            ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_added_task_message)
            )
            DELETE_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_deleted_task_message)
            )
        }

    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) {

        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                val tasksResult = tasksRepository.getTasks(forceUpdate)

                if (tasksResult is Success) {
                    val tasks = tasksResult.data

                    val tasksToShow = ArrayList<Task>()
                    
                    for (task in tasks) {
                        when (_currentFiltering) {
                            TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                            TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                                tasksToShow.add(task)
                            }
                            TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                                tasksToShow.add(task)
                            }
                        }
                    }
                    isDataLoadingError.value = false
                    _items.value = ArrayList(tasksToShow)
                } else {
                    isDataLoadingError.value = false
                    _items.value = emptyList()
                    _snackbarText.value = Event(R.string.loading_tasks_error)
                }

                _dataLoading.value = false
            }
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import com.example.android.architecture.blueprints.todoapp.EventObserver
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.databinding.TaskdetailFragBinding
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.getVmFactory
import com.example.android.architecture.blueprints.todoapp.util.setupSnackbar
import com.google.android.material.snackbar.Snackbar


class TaskDetailFragment : Fragment() {
    private lateinit var viewDataBinding: TaskdetailFragBinding

    private val viewModel by viewModels<TaskDetailViewModel> { getVmFactory() }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        setupFab()
        viewDataBinding.viewmodel?.let {
            view?.setupSnackbar(this, it.snackbarMessage, Snackbar.LENGTH_SHORT)
        }

        setupNavigation()
    }

    private fun setupNavigation() {
        viewModel.deleteTaskCommand.observe(this, EventObserver {
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToTasksFragment(DELETE_RESULT_OK)
            findNavController().navigate(action)
        })
        viewModel.editTaskCommand.observe(this, EventObserver {
            val taskId = TaskDetailFragmentArgs.fromBundle(arguments!!).TASKID
            val action = TaskDetailFragmentDirections
                .actionTaskDetailFragmentToAddEditTaskFragment(taskId,
                    resources.getString(R.string.edit_task))
            findNavController().navigate(action)
        })
    }

    private fun setupFab() {
        activity?.findViewById<View>(R.id.fab_edit_task)?.setOnClickListener {
            viewDataBinding.viewmodel?.editTask()
        }
    }

    override fun onResume() {
        super.onResume()
        val taskId = arguments?.let {
            TaskDetailFragmentArgs.fromBundle(it).TASKID
        }
        viewDataBinding.viewmodel?.start(taskId)
    }

    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.taskdetail_frag, container, false)
        viewDataBinding = TaskdetailFragBinding.bind(view).apply {
            viewmodel = viewModel
            listener = object : TaskDetailUserActionsListener {
                override fun onCompleteChanged(v: View) {
                    viewmodel?.setCompleted((v as CheckBox).isChecked)
                }
            }
        }
        viewDataBinding.setLifecycleOwner(this.viewLifecycleOwner)
        setHasOptionsMenu(true)
        return view
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_delete -> {
                viewDataBinding.viewmodel?.deleteTask()
                true
            }
            else -> false
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.taskdetail_fragment_menu, menu)
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.wrapEspressoIdlingResource
import kotlinx.coroutines.launch


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _task = MutableLiveData<Task>()
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskCommand = MutableLiveData<Event<Unit>>()
    val editTaskCommand: LiveData<Event<Unit>> = _editTaskCommand

    private val _deleteTaskCommand = MutableLiveData<Event<Unit>>()
    val deleteTaskCommand: LiveData<Event<Unit>> = _deleteTaskCommand

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }

    val taskId: String?
        get() = _task.value?.id

    fun deleteTask() = viewModelScope.launch {
        taskId?.let {
            tasksRepository.deleteTask(it)
            _deleteTaskCommand.value = Event(Unit)
        }
    }

    fun editTask() {
        _editTaskCommand.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = _task.value ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    fun start(taskId: String?) {
        _dataLoading.value = true

        wrapEspressoIdlingResource {

            viewModelScope.launch {
                if (taskId != null) {
                    tasksRepository.getTask(taskId, false).let { result ->
                        if (result is Success) {
                            onTaskLoaded(result.data)
                        } else {
                            onDataNotAvailable(result)
                        }
                    }
                }
                _dataLoading.value = false
            }
        }
    }

    private fun setTask(task: Task?) {
        this._task.value = task
        _isDataAvailable.value = task != null
    }

    private fun onTaskLoaded(task: Task) {
        setTask(task)
    }

    private fun onDataNotAvailable(result: Result<Task>) {
        _task.value = null
        _isDataAvailable.value = false
    }

    fun onRefresh() {
        taskId?.let { start(it) }
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import android.view.View
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.CoreMatchers.allOf
import org.hamcrest.Matcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun setup() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun tearDown() {
        repository.deleteAllTasksBlocking()
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        verify(navController).navigate(
          TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
            null, getApplicationContext<Context>().getString(R.string.add_task)))
    }

    @Test
    fun displayTask_whenRepositoryHasData() {
        
        val repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.saveTaskBlocking(Task("title", "description"))

        
        launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)

        
        onView(withText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        ActivityScenario.launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        ActivityScenario.launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(checkboxWithText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }

    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(doesNotExist())
    }

    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))
        repository.saveTaskBlocking(Task("TITLE3", "DESCRIPTION3", true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        onView(withText("TITLE2")).check(matches(isDisplayed()))
        onView(withText("TITLE3")).check(matches(isDisplayed()))
    }

    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2", true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(R.string.menu_clear)).perform(click())

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())

        
        onView(withText("You have no TO-DOs!")).check(matches(isDisplayed()))
    }

    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())

        
        onView(withText("You have no completed TO-DOs!")).check(matches((isDisplayed())))
    }

    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())

        
        onView(withText("You have no active TO-DOs!")).check(matches((isDisplayed())))
    }

    private fun checkboxWithText(text: String) : Matcher<View> {
        return allOf(withId(R.id.complete), hasSibling(withText(text)))
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.Matchers.allOf
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private lateinit var repository: TasksRepository

    
    @UiThreadTest
    @Before
    fun resetState() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.deleteAllTasksBlocking()
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    @Test
    fun createTask() {
        
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title))
          .perform(typeText("title"))
        onView(withId(R.id.add_task_description))
          .perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(replaceText("NEW TITLE"))
        onView(withId(R.id.add_task_description)).perform(replaceText("NEW DESCRIPTION"))

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("NEW TITLE")).check(matches(isDisplayed()))

        
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE1"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE1"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title)).perform(typeText("TITLE2"))
        onView(withId(R.id.add_task_description)).perform(typeText("DESCRIPTION"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withText("TITLE2")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
        onView(withText("TITLE2")).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION", true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION"))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION", true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText("TITLE1"))))
            .check(matches(isChecked()))
    }
}

<code block>
package com.example.android.architecture.blueprints.todoapp.tasks

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.testing.launchFragmentInContainer
import androidx.navigation.NavController
import androidx.navigation.Navigation
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.MediumTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.deleteAllTasksBlocking
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.Mockito.verify
import org.robolectric.annotation.LooperMode
import org.robolectric.annotation.TextLayoutMode



@RunWith(AndroidJUnit4::class)
@MediumTest
@LooperMode(LooperMode.Mode.PAUSED)
@TextLayoutMode(TextLayoutMode.Mode.REALISTIC)
class TasksFragmentTest {

    private lateinit var repository: TasksRepository

    @Before
    fun setup() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
    }

    @After
    fun tearDown() {
        repository.deleteAllTasksBlocking()
    }

    @Test
    fun clickAddTaskButton_navigateToAddEditFragment() {
        
        val scenario = launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)
        val navController = mock(NavController::class.java)
        scenario.onFragment {
            Navigation.setViewNavController(it.view!!, navController)
        }

        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        verify(navController).navigate(
          TasksFragmentDirections.actionTasksFragmentToAddEditTaskFragment(
            null, getApplicationContext<Context>().getString(R.string.add_task)))
    }

    @Test
    @MediumTest
    fun displayTask_whenRepositoryHasData() {
        
        val repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        repository.saveTaskBlocking(Task("title", "description"))

        
        launchFragmentInContainer<TasksFragment>(Bundle(), R.style.AppTheme)

        
        onView(withText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun displayActiveTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        ActivityScenario.launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))
    }

    @Test
    fun displayCompletedTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1", true))

        ActivityScenario.launch(TasksActivity::class.java)

        onView(withText("TITLE1")).check(matches(isDisplayed()))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_active)).perform(click())
        onView(withText("TITLE1")).check(matches(not(isDisplayed())))

        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_completed)).perform(click())
        onView(withText("TITLE1")).check(matches(isDisplayed()))
    }

    @Test
    fun deleteOneTask() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))

        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
    }

    @Test
    fun deleteOneOfTwoTasks() {
        repository.saveTaskBlocking(Task("TITLE1", "DESCRIPTION1"))
        repository.saveTaskBlocking(Task("TITLE2", "DESCRIPTION2"))

        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText("TITLE1")).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(R.string.nav_all)).perform(click())
        onView(withText("TITLE1")).check(doesNotExist())
        
        onView(withText("TITLE2")).check(matches(isDisplayed()))
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import android.view.View
import android.widget.ListView
import androidx.test.annotation.UiThreadTest
import androidx.test.core.app.ActivityScenario
import androidx.test.core.app.ApplicationProvider.getApplicationContext
import androidx.test.espresso.Espresso.onView
import androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
import androidx.test.espresso.Espresso.pressBack
import androidx.test.espresso.IdlingRegistry
import androidx.test.espresso.action.ViewActions.click
import androidx.test.espresso.action.ViewActions.closeSoftKeyboard
import androidx.test.espresso.action.ViewActions.replaceText
import androidx.test.espresso.action.ViewActions.typeText
import androidx.test.espresso.assertion.ViewAssertions.doesNotExist
import androidx.test.espresso.assertion.ViewAssertions.matches
import androidx.test.espresso.matcher.ViewMatchers.hasSibling
import androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom
import androidx.test.espresso.matcher.ViewMatchers.isChecked
import androidx.test.espresso.matcher.ViewMatchers.isDescendantOfA
import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
import androidx.test.espresso.matcher.ViewMatchers.withId
import androidx.test.espresso.matcher.ViewMatchers.withText
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ServiceLocator
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.EspressoIdlingResource
import com.example.android.architecture.blueprints.todoapp.util.saveTaskBlocking
import com.google.common.base.Preconditions.checkArgument
import kotlinx.coroutines.runBlocking
import org.hamcrest.Description
import org.hamcrest.Matcher
import org.hamcrest.Matchers.allOf
import org.hamcrest.TypeSafeMatcher
import org.hamcrest.core.IsNot.not
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith


@RunWith(AndroidJUnit4::class)
@LargeTest
class TasksActivityTest {

    private val TITLE1 = "TITLE1"
    private val TITLE2 = "TITLE2"
    private val TITLE3 = "TITLE3"
    private val DESCRIPTION = "DESCR"

    private lateinit var repository: TasksRepository

    
    @UiThreadTest
    @Before
    fun resetState() {
        repository = ServiceLocator.provideTasksRepository(getApplicationContext())
        runBlocking {
            repository.deleteAllTasks()
        }
    }

    
    @Before
    fun registerIdlingResource() {
        IdlingRegistry.getInstance().register(EspressoIdlingResource.countingIdlingResource)
    }

    
    @After
    fun unregisterIdlingResource() {
        IdlingRegistry.getInstance().unregister(EspressoIdlingResource.countingIdlingResource)
    }

    
    private fun withItemText(itemText: String): Matcher<View> {
        checkArgument(itemText.isNotEmpty(), "itemText cannot be null or empty")
        return object : TypeSafeMatcher<View>() {
            override fun matchesSafely(item: View) = allOf(
                isDescendantOfA(isAssignableFrom(ListView::class.java)),
                withText(itemText)
            ).matches(item)

            override fun describeTo(description: Description) {
                description.appendText("is isDescendantOfA LV with text $itemText")
            }
        }
    }

    @Test
    fun createTask() {
        
        ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withId(R.id.fab_add_task)).perform(click())
        onView(withId(R.id.add_task_title))
          .perform(typeText("title"))
        onView(withId(R.id.add_task_description))
          .perform(typeText("description"))
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText("title")).check(matches(isDisplayed()))
    }

    @Test
    fun editTask() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.fab_edit_task)).perform(click())

        val editTaskTitle = TITLE2
        val editTaskDescription = "New Description"

        
        onView(withId(R.id.add_task_title))
            .perform(replaceText(editTaskTitle), closeSoftKeyboard()) 
        onView(withId(R.id.add_task_description)).perform(
            replaceText(editTaskDescription),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())

        
        onView(withItemText(editTaskTitle)).check(matches(isDisplayed()))

        
        onView(withItemText(TITLE1)).check(doesNotExist())
    }

    
    @Test
    fun markTaskAsComplete() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
    }

    
    @Test
    fun markTaskAsActive() {
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        clickCheckBoxForTask(TITLE1)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(matches(not(isDisplayed())))
    }

    
    @Test
    fun showAllTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewAllTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
    }

    
    @Test
    fun showActiveTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewActiveTasks()
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(doesNotExist())
    }

    
    @Test
    fun showCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))
        repository.saveTaskBlocking(Task(TITLE3, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        
        viewCompletedTasks()
        onView(withItemText(TITLE1)).check(doesNotExist())
        onView(withItemText(TITLE2)).check(matches(isDisplayed()))
        onView(withItemText(TITLE3)).check(matches(isDisplayed()))
    }

    
    @Test
    fun clearCompletedTasks() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))
        repository.saveTaskBlocking(Task(TITLE2, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)

        viewAllTasks()
        
        openActionBarOverflowOrOptionsMenu(getApplicationContext())
        onView(withText(string.menu_clear)).perform(click())

        viewAllTasks()
        
        onView(withItemText(TITLE1)).check(matches(isDisplayed()))
        onView(withItemText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun createOneTask_deleteTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        createTask(TITLE1, DESCRIPTION)

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(doesNotExist())
    }

    @Test
    fun createTwoTasks_deleteOneTask() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        
        createTask(TITLE1, DESCRIPTION)
        createTask(TITLE2, DESCRIPTION)

        
        onView(withText(TITLE2)).perform(click())

        
        onView(withId(R.id.menu_delete)).perform(click())

        
        viewAllTasks()
        onView(withText(TITLE1)).check(matches(isDisplayed()))
        onView(withText(TITLE2)).check(doesNotExist())
    }

    @Test
    fun markTaskAsCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    @Test
    fun markTaskAsActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsCompleteAndActiveOnDetailScreen_taskIsActiveInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(not(isChecked())))
    }

    @Test
    fun markTaskAsActiveAndCompleteOnDetailScreen_taskIsCompleteInList() {
        
        repository.saveTaskBlocking(Task(TITLE1, DESCRIPTION, true))

        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText(TITLE1)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        onView(withId(R.id.task_detail_complete)).perform(click())

        
        pressBack()

        
        onView(allOf(withId(R.id.complete), hasSibling(withText(TITLE1))))
            .check(matches(isChecked()))
    }

    
    @Test
    fun noTasks_AllTasksFilter_AddTaskViewVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewAllTasks()

        
        onView(withText("You have no TO-DOs!")).check(matches(isDisplayed()))
    }

    
    @Test
    fun noTasks_CompletedTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewCompletedTasks()

        
        onView(withText("You have no completed TO-DOs!")).check(matches((isDisplayed())))
    }

    
    @Test
    fun noTasks_ActiveTasksFilter_AddTaskViewNotVisible() {
        val activityScenario = ActivityScenario.launch(TasksActivity::class.java)
        viewActiveTasks()

        
        onView(withText("You have no active TO-DOs!")).check(matches((isDisplayed())))
    }

    private fun viewAllTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_all)).perform(click())
    }

    private fun viewActiveTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_active)).perform(click())
    }

    private fun viewCompletedTasks() {
        onView(withId(R.id.menu_filter)).perform(click())
        onView(withText(string.nav_completed)).perform(click())
    }

    private fun createTask(title: String, description: String) {
        
        onView(withId(R.id.fab_add_task)).perform(click())

        
        onView(withId(R.id.add_task_title)).perform(
            typeText(title),
            closeSoftKeyboard()
        ) 
        onView(withId(R.id.add_task_description)).perform(
            typeText(description),
            closeSoftKeyboard()
        ) 

        
        onView(withId(R.id.fab_save_task)).perform(click())
    }

    private fun clickCheckBoxForTask(title: String) {
        onView(allOf(withId(R.id.complete), hasSibling(withText(title)))).perform(click())
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.plus
import kotlin.coroutines.CoroutineContext


abstract class BaseViewModel(private val coroutineContext: CoroutineContext) : ViewModel() {

    val viewModelScope: CoroutineScope
        get() = (this as ViewModel).viewModelScope + coroutineContext

}
<code block>

package com.example.android.architecture.blueprints.todoapp.data

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID


@Entity(tableName = "tasks")
data class Task @JvmOverloads constructor(
        @ColumnInfo(name = "title") var title: String = "",
        @ColumnInfo(name = "description") var description: String = "",
        @PrimaryKey @ColumnInfo(name = "entryid") var id: String = UUID.randomUUID().toString()
) {

    
    @ColumnInfo(name = "completed") var isCompleted = false

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description


    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() || description.isEmpty()
}
<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import com.example.android.architecture.blueprints.todoapp.BaseViewModel
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext


class StatisticsViewModel(
    private val tasksRepository: TasksRepository,
    coroutineContext: CoroutineContext = EmptyCoroutineContext
) : BaseViewModel(coroutineContext) {

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _error = MutableLiveData<Boolean>()
    val error: LiveData<Boolean> = _error

    
    private val _empty = MutableLiveData<Boolean>()
    val empty: LiveData<Boolean> = _empty

    private val _numberOfActiveTasks = MutableLiveData<Int>()
    val numberOfActiveTasks: LiveData<Int> = _numberOfActiveTasks

    private val _numberOfCompletedTasks = MutableLiveData<Int>()
    val numberOfCompletedTasks: LiveData<Int> = _numberOfCompletedTasks

    private var activeTasks = 0

    private var completedTasks = 0

    fun start() {
        loadStatistics()
    }

    fun loadStatistics() {
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTasks().let { result ->
                if (result is Success) {
                    _error.value = false
                    computeStats(result.data)
                } else {
                    _error.value = true
                    activeTasks = 0
                    completedTasks = 0
                    updateDataBindingObservables()
                }
            }
        }
    }

    
    private fun computeStats(tasks: List<Task>) {
        var completed = 0
        var active = 0

        for (task in tasks) {
            if (task.isCompleted) {
                completed += 1
            } else {
                active += 1
            }
        }
        activeTasks = active
        completedTasks = completed

        updateDataBindingObservables()
    }

    private fun updateDataBindingObservables() {
        _numberOfCompletedTasks.value = completedTasks

        _numberOfActiveTasks.value = activeTasks

        _empty.value = activeTasks + completedTasks == 0
        _dataLoading.value = false
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import com.example.android.architecture.blueprints.todoapp.BaseViewModel
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository,
    coroutineContext: CoroutineContext = EmptyCoroutineContext
) : BaseViewModel(coroutineContext) {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> =_dataLoading

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdated = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdated

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        _dataLoading.value?.let { isLoading ->
            
            if (isLoading) return
        }
        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }
        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription).isEmpty) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, currentTaskId)
                .apply { isCompleted = taskCompleted }
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) = viewModelScope.launch {
        tasksRepository.saveTask(newTask)
        _taskUpdated.value = Event(Unit)
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdated.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import com.example.android.architecture.blueprints.todoapp.BaseViewModel
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import kotlinx.coroutines.launch
import java.util.ArrayList
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext


class TasksViewModel(
    private val tasksRepository: TasksRepository,
    coroutineContext: CoroutineContext = EmptyCoroutineContext
) : BaseViewModel(coroutineContext) {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.ic_assignment_turned_in_24dp, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_24dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_24dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) = viewModelScope.launch {
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_saved_task_message)
            )
            ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_added_task_message)
            )
            DELETE_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_deleted_task_message)
            )
        }

    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) {

        _dataLoading.value = true

        viewModelScope.launch {
            val tasksResult = tasksRepository.getTasks(forceUpdate)

            if (tasksResult is Success) {
                val tasks = tasksResult.data

                val tasksToShow = ArrayList<Task>()
                
                for (task in tasks) {
                    when (_currentFiltering) {
                        TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                        TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                            tasksToShow.add(task)
                        }
                        TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                            tasksToShow.add(task)
                        }
                    }
                }
                isDataLoadingError.value = false
                _items.value = ArrayList(tasksToShow)
            } else {
                isDataLoadingError.value = false
                _items.value = emptyList()
                _snackbarText.value = Event(R.string.loading_tasks_error)
            }

            _dataLoading.value = false
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import com.example.android.architecture.blueprints.todoapp.BaseViewModel
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository,
    coroutineContext: CoroutineContext = EmptyCoroutineContext
) : BaseViewModel(coroutineContext) {

    private val _task = MutableLiveData<Task>()
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskCommand = MutableLiveData<Event<Unit>>()
    val editTaskCommand: LiveData<Event<Unit>> = _editTaskCommand

    private val _deleteTaskCommand = MutableLiveData<Event<Unit>>()
    val deleteTaskCommand: LiveData<Event<Unit>> = _deleteTaskCommand

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }

    val taskId: String?
        get() = _task.value?.id

    fun deleteTask() = viewModelScope.launch {
        taskId?.let {
            tasksRepository.deleteTask(it)
            _deleteTaskCommand.value = Event(Unit)
        }
    }

    fun editTask() {
        _editTaskCommand.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) = viewModelScope.launch {
        val task = _task.value ?: return@launch
        if (completed) {
            tasksRepository.completeTask(task)
            showSnackbarMessage(R.string.task_marked_complete)
        } else {
            tasksRepository.activateTask(task)
            showSnackbarMessage(R.string.task_marked_active)
        }
    }


    fun start(taskId: String?) = viewModelScope.launch {
        if (taskId != null) {
            _dataLoading.value = true
            tasksRepository.getTask(taskId, false).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable(result)
                }
            }
        }
    }


    private fun setTask(task: Task?) {
        this._task.value = task
        _isDataAvailable.value = task != null
    }

    private fun onTaskLoaded(task: Task) {
        setTask(task)
        _dataLoading.value = false
    }

    private fun onDataNotAvailable(result: Result<Task>) {
        _task.value = null
        _dataLoading.value = false
        _isDataAvailable.value = false
    }

    fun onRefresh() {
        taskId?.let { start(it) }
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import androidx.lifecycle.LiveData
import org.junit.Assert
import org.junit.Assert.assertEquals
import org.junit.Assert.fail

fun assertNonNullTrue(b: Boolean?) = Assert.assertTrue(b == true)

fun assertNonNullFalse(b: Boolean?) = Assert.assertTrue(b == false)

fun assertNonNullEquals(one: Any?, two: Any?) {
    if (one == null && two == null) return fail("Both sides are null")
    return assertEquals(one, two)
}

fun assertLiveDataEventTriggered(
    liveData: LiveData<Event<String>>,
    taskId: String
) {
    val value = LiveDataTestUtil.getValue(liveData)
    assertEquals(value.getContentIfNotHandled(), taskId)
}

fun assertSnackbarMessage(snackbarLiveData: LiveData<Event<Int>>, messageId: Int) {
    val value: Event<Int> = LiveDataTestUtil.getValue(snackbarLiveData)
    assertEquals(value.getContentIfNotHandled(), messageId)
}
<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.collect.Lists
import java.util.LinkedHashMap


class FakeRepository : TasksRepository {

    var tasksServiceData: LinkedHashMap<String, Task> = LinkedHashMap()

    private var shouldReturnError = false

    fun setReturnError(value: Boolean) {
        shouldReturnError = value
    }

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        tasksServiceData[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Could not find task"))
    }

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        if (shouldReturnError) {
            return Error(Exception("Test exception"))
        }
        return Success(Lists.newArrayList(tasksServiceData.values))
    }

    override suspend fun saveTask(task: Task) {
        tasksServiceData[task.id] = task
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, task.id).apply {
            isCompleted = true
        }
        tasksServiceData[task.id] = completedTask
    }

    override suspend fun completeTask(taskId: String) {
        
        throw NotImplementedError()
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, task.id)
        tasksServiceData[task.id] = activeTask
    }

    override suspend fun activateTask(taskId: String) {
        throw NotImplementedError()
    }

    override suspend fun clearCompletedTasks() {
        tasksServiceData = tasksServiceData.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteTask(taskId: String) {
        tasksServiceData.remove(taskId)
    }

    override suspend fun deleteAllTasks() {
        tasksServiceData.clear()
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        for (task in tasks) {
            tasksServiceData[task.id] = task
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.FakeFailingTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.ViewModelScopeMainDispatcherRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.ObsoleteCoroutinesApi
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.TestCoroutineContext
import org.hamcrest.MatcherAssert.assertThat
import org.hamcrest.core.Is.`is`
import org.junit.Assert
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ObsoleteCoroutinesApi
class StatisticsViewModelTest {

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    
    private lateinit var statisticsViewModel: StatisticsViewModel

    
    private val tasksRepository = FakeRepository()

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var coroutinesMainDispatcherRule = ViewModelScopeMainDispatcherRule()

    
    private val testContext = TestCoroutineContext()

    @Before
    fun setupStatisticsViewModel() {
        statisticsViewModel = StatisticsViewModel(tasksRepository, testContext)
    }

    @Test
    fun loadEmptyTasksFromRepository_EmptyResults() = runBlocking {
        

        
        statisticsViewModel.loadStatistics()

        
        testContext.triggerActions()

        
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.empty), `is`(true))
    }

    @Test
    fun loadNonEmptyTasksFromRepository_NonEmptyResults() {
        
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2").apply {
            isCompleted = true
        }
        val task3 = Task("Title3", "Description3").apply {
            isCompleted = true
        }
        tasksRepository.addTasks(task1, task2, task3)

        
        statisticsViewModel.loadStatistics()

        
        testContext.triggerActions()

        
        assertEquals(LiveDataTestUtil.getValue(statisticsViewModel.empty), false)
        assertEquals(LiveDataTestUtil.getValue(statisticsViewModel.numberOfActiveTasks), 1)
        assertEquals(LiveDataTestUtil.getValue(statisticsViewModel.numberOfCompletedTasks), 2)
    }

    @Test
    fun loadStatisticsWhenTasksAreUnavailable_CallErrorToDisplay() = runBlocking {
        val errorViewModel = StatisticsViewModel(
            DefaultTasksRepository(
                FakeFailingTasksRemoteDataSource,
                FakeFailingTasksRemoteDataSource)
        )

        
        errorViewModel.loadStatistics()

        
        assertEquals(LiveDataTestUtil.getValue(errorViewModel.empty), true)
        assertEquals(LiveDataTestUtil.getValue(errorViewModel.error), true)
    }

    @Test
    fun loadTasks_loading() {
        
        statisticsViewModel.start()

        
        Assert.assertTrue(LiveDataTestUtil.getValue(statisticsViewModel.dataLoading))

        
        testContext.triggerActions()

        
        Assert.assertFalse(LiveDataTestUtil.getValue(statisticsViewModel.dataLoading))
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil.getValue
import com.example.android.architecture.blueprints.todoapp.R.string
import com.example.android.architecture.blueprints.todoapp.ViewModelScopeMainDispatcherRule
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.ObsoleteCoroutinesApi
import kotlinx.coroutines.test.TestCoroutineContext
import org.hamcrest.Matchers.`is`
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertThat
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ObsoleteCoroutinesApi
class AddEditTaskViewModelTest {

    
    private lateinit var addEditTaskViewModel: AddEditTaskViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var coroutinesMainDispatcherRule = ViewModelScopeMainDispatcherRule()

    
    @get:Rule var instantExecutorRule = InstantTaskExecutorRule()

    
    private val testContext = TestCoroutineContext()

    private val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()

        
        addEditTaskViewModel = AddEditTaskViewModel(tasksRepository, testContext)
    }

    @ObsoleteCoroutinesApi
    @Test
    fun saveNewTaskToRepository_showsSuccessMessageUi() {
        val newTitle = "New Task Title"
        val newDescription = "Some Task Description"
        (addEditTaskViewModel).apply {
            title.value = newTitle
            description.value = newDescription
        }
        addEditTaskViewModel.saveTask()

        
        testContext.triggerActions()

        val newTask = tasksRepository.tasksServiceData.values.first()

        
        assertThat(newTask.title, `is`(newTitle))
        assertThat(newTask.description, `is`(newDescription))
    }

    @Test
    fun loadTasks_loading() {
        
        addEditTaskViewModel.start(task.id)

        
        assertTrue(getValue(addEditTaskViewModel.dataLoading))

        
        testContext.triggerActions()

        
        assertFalse(getValue(addEditTaskViewModel.dataLoading))
    }

    @Test
    fun loadTasks_taskShown() {
        
        tasksRepository.addTasks(task)

        
        addEditTaskViewModel.start(task.id)

        
        testContext.triggerActions()

        
        assertEquals(getValue(addEditTaskViewModel.title), task.title)
        assertEquals(getValue(addEditTaskViewModel.description), task.description)
        assertEquals(getValue(addEditTaskViewModel.dataLoading), false)
    }

    @ObsoleteCoroutinesApi
    @Test
    fun saveNewTaskToRepository_emptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "Some Task Description")
    }

    @ObsoleteCoroutinesApi
    @Test
    fun saveNewTaskToRepository_nullTitle_error() {
        saveTaskAndAssertSnackbarError(null, "Some Task Description")
    }
    @ObsoleteCoroutinesApi
    @Test
    fun saveNewTaskToRepository_emptyDescription_error() {
        saveTaskAndAssertSnackbarError("Title", "")
    }

    @ObsoleteCoroutinesApi
    @Test
    fun saveNewTaskToRepository_nullDescription_error() {
        saveTaskAndAssertSnackbarError("Title", null)
    }

    @ObsoleteCoroutinesApi
    @Test
    fun saveNewTaskToRepository_nullDescriptionNullTitle_error() {
        saveTaskAndAssertSnackbarError(null, null)
    }

    @ObsoleteCoroutinesApi
    @Test
    fun saveNewTaskToRepository_emptyDescriptionEmptyTitle_error() {
        saveTaskAndAssertSnackbarError("", "")
    }

    private fun saveTaskAndAssertSnackbarError(title: String?, description: String?) {
        (addEditTaskViewModel).apply {
            this.title.value = title
            this.description.value = description
        }

        
        addEditTaskViewModel.saveTask()

        
        assertSnackbarMessage(addEditTaskViewModel.snackbarMessage, string.empty_task_message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ViewModelScopeMainDispatcherRule
import com.example.android.architecture.blueprints.todoapp.assertLiveDataEventTriggered
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.ObsoleteCoroutinesApi
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.TestCoroutineContext
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ObsoleteCoroutinesApi
class TasksViewModelTest {

    
    private lateinit var tasksViewModel: TasksViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var coroutinesMainDispatcherRule = ViewModelScopeMainDispatcherRule()

    
    @get:Rule var instantExecutorRule = InstantTaskExecutorRule()

    
    private val testContext = TestCoroutineContext()

    @Before
    fun setupViewModel() {
        
        tasksRepository = FakeRepository()
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2").apply {
            isCompleted = true
        }
        val task3 = Task("Title3", "Description3").apply {
            isCompleted = true
        }
        tasksRepository.addTasks(task1, task2, task3)

        tasksViewModel = TasksViewModel(tasksRepository, testContext)
    }

    @Test
    fun loadAllTasksFromRepository_loadingTogglesAndDataLoaded() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        assertTrue(LiveDataTestUtil.getValue(tasksViewModel.dataLoading))

        
        testContext.triggerActions()

        
        assertFalse(LiveDataTestUtil.getValue(tasksViewModel.dataLoading))

        
        assertFalse(LiveDataTestUtil.getValue(tasksViewModel.items).isEmpty())
        assertTrue(LiveDataTestUtil.getValue(tasksViewModel.items).size == 3)
    }

    @Test
    fun loadActiveTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.ACTIVE_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        testContext.triggerActions()

        
        assertFalse(LiveDataTestUtil.getValue(tasksViewModel.dataLoading))

        
        assertFalse(LiveDataTestUtil.getValue(tasksViewModel.items).isEmpty())
        assertTrue(LiveDataTestUtil.getValue(tasksViewModel.items).size == 1)
    }

    @Test
    fun loadCompletedTasksFromRepositoryAndLoadIntoView() {
        
        
        tasksViewModel.setFiltering(TasksFilterType.COMPLETED_TASKS)

        
        tasksViewModel.loadTasks(true)

        
        testContext.triggerActions()

        
        assertFalse(LiveDataTestUtil.getValue(tasksViewModel.dataLoading))

        
        assertFalse(LiveDataTestUtil.getValue(tasksViewModel.items).isEmpty())
        assertTrue(LiveDataTestUtil.getValue(tasksViewModel.items).size == 2)
    }

    @Test
    fun loadTasks_error() {
        
        tasksRepository.setReturnError(true)

        
        tasksViewModel.loadTasks(true)

        
        testContext.triggerActions()

        
        assertFalse(LiveDataTestUtil.getValue(tasksViewModel.dataLoading))

        
        assertTrue(LiveDataTestUtil.getValue(tasksViewModel.items).isEmpty())

        
        assertSnackbarMessage(tasksViewModel.snackbarMessage, R.string.loading_tasks_error)
    }

    @Test
    fun clickOnFab_showsAddTaskUi() {
        
        tasksViewModel.addNewTask()

        
        val value = LiveDataTestUtil.getValue(tasksViewModel.newTaskEvent)
        assertNotNull(value.getContentIfNotHandled())
    }

    @Test
    fun clickOnOpenTask_setsEvent() {
        
        val taskId = "42"
        tasksViewModel.openTask(taskId)

        
        assertLiveDataEventTriggered(tasksViewModel.openTaskEvent, taskId)
    }

    @Test
    fun clearCompletedTasks_clearsTasks() = runBlocking {
        
        tasksViewModel.clearCompletedTasks()

        
        tasksViewModel.loadTasks(true)

        
        testContext.triggerActions()

        
        val allTasks = LiveDataTestUtil.getValue(tasksViewModel.items)
        val completedTasks = allTasks.filter { it.isCompleted }

        
        assertEquals(completedTasks.size, 0)

        
        assertEquals(allTasks.size, 1)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.completed_tasks_cleared)
    }

    @Test
    fun showEditResultMessages_editOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_saved_task_message)
    }

    @Test
    fun showEditResultMessages_addOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(ADD_EDIT_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_added_task_message)
    }

    @Test
    fun showEditResultMessages_deleteOk_snackbarUpdated() {
        
        tasksViewModel.showEditResultMessage(DELETE_RESULT_OK)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.successfully_deleted_task_message)
    }

    @Test
    fun completeTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description")
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, true)

        
        testContext.triggerActions()

        
        assertTrue(tasksRepository.tasksServiceData[task.id]?.isCompleted == true)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_complete)
    }

    @Test
    fun activateTask_dataAndSnackbarUpdated() {
        
        val task = Task("Title", "Description").apply { isCompleted = true }
        tasksRepository.addTasks(task)

        
        tasksViewModel.completeTask(task, false)

        
        testContext.triggerActions()

        
        assertTrue(tasksRepository.tasksServiceData[task.id]?.isActive == true)

        
        assertSnackbarMessage(
            tasksViewModel.snackbarMessage, R.string.task_marked_active)
    }

    @Test
    fun getTasksAddViewVisible() {
        
        tasksViewModel.setFiltering(TasksFilterType.ALL_TASKS)

        
        assertTrue(LiveDataTestUtil.getValue(tasksViewModel.tasksAddViewVisible))
    }
}
<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.ViewModelScopeMainDispatcherRule
import com.example.android.architecture.blueprints.todoapp.assertSnackbarMessage
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import junit.framework.Assert.assertEquals
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.ObsoleteCoroutinesApi
import kotlinx.coroutines.test.TestCoroutineContext
import org.hamcrest.core.Is.`is`
import org.hamcrest.core.IsNull.nullValue
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertThat
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test


@ObsoleteCoroutinesApi
class TaskDetailViewModelTest {

    
    private lateinit var taskDetailViewModel: TaskDetailViewModel

    
    private lateinit var tasksRepository: FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var coroutinesMainDispatcherRule = ViewModelScopeMainDispatcherRule()

    
    @get:Rule var instantExecutorRule = InstantTaskExecutorRule()

    
    private val testContext = TestCoroutineContext()

    val task = Task("Title1", "Description1")

    @Before
    fun setupViewModel() {
        tasksRepository = FakeRepository()
        tasksRepository.addTasks(task)

        taskDetailViewModel = TaskDetailViewModel(tasksRepository, testContext)
    }

    @Test
    fun getActiveTaskFromRepositoryAndLoadIntoView() {
        taskDetailViewModel.start(task.id)

        
        testContext.triggerActions()

        
        assertEquals(
            LiveDataTestUtil.getValue(taskDetailViewModel.task).title, task.title
        )
        assertEquals(
            LiveDataTestUtil.getValue(taskDetailViewModel.task).description, task.description
        )
    }

    @Test
    fun deleteTask() {

        assertTrue(tasksRepository.tasksServiceData.containsValue(task))
        taskDetailViewModel.start(task.id)

        
        testContext.triggerActions()

        
        taskDetailViewModel.deleteTask()

        
        testContext.triggerActions()

        assertFalse(tasksRepository.tasksServiceData.containsValue(task))
    }

    @Test
    fun completeTask() {

        taskDetailViewModel.start(task.id)

        
        testContext.triggerActions()

        assertTrue(tasksRepository.tasksServiceData[task.id]?.isCompleted == false)

        
        taskDetailViewModel.setCompleted(true)

        
        testContext.triggerActions()

        assertTrue(tasksRepository.tasksServiceData[task.id]?.isCompleted == true)
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_complete)
    }

    @Test
    fun activateTask() {
        task.isCompleted = true

        taskDetailViewModel.start(task.id)

        
        testContext.triggerActions()

        assertTrue(tasksRepository.tasksServiceData[task.id]?.isCompleted == true)

        
        taskDetailViewModel.setCompleted(false)

        
        testContext.triggerActions()

        assertTrue(tasksRepository.tasksServiceData[task.id]?.isCompleted == false)
        assertSnackbarMessage(taskDetailViewModel.snackbarMessage, R.string.task_marked_active)

    }

    @Test
    fun taskDetailViewModel_repositoryError() {
        
        tasksRepository.setReturnError(true)

        
        taskDetailViewModel.start(task.id)

        
        testContext.triggerActions()

        
        assertFalse(LiveDataTestUtil.getValue(taskDetailViewModel.isDataAvailable))
    }

    @Test
    fun updateSnackbar_nullValue() {
        
        val snackbarText = taskDetailViewModel.snackbarMessage.value

        
        assertThat("Snackbar text does not match", snackbarText, `is`(nullValue()))
    }

    @Test
    fun clickOnEditTask_SetsEvent() {
        
        taskDetailViewModel.editTask()

        
        val value = LiveDataTestUtil.getValue(taskDetailViewModel.editTaskCommand)
        assertNotNull(value.getContentIfNotHandled())
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID


@Entity(tableName = "tasks")
data class Task @JvmOverloads constructor(
        @ColumnInfo(name = "title") var title: String = "",
        @ColumnInfo(name = "description") var description: String = "",
        @PrimaryKey @ColumnInfo(name = "entryid") var id: String = UUID.randomUUID().toString()
) {

    
    @ColumnInfo(name = "completed") var isCompleted = false

    val titleForList: String
        get() = if (title.isNotEmpty()) title else description


    val isActive
        get() = !isCompleted

    val isEmpty
        get() = title.isEmpty() && description.isEmpty()
}
<code block>


package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class StatisticsViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _error = MutableLiveData<Boolean>()
    val error: LiveData<Boolean> = _error

    
    private val _empty = MutableLiveData<Boolean>()
    val empty: LiveData<Boolean> = _empty

    private val _numberOfActiveTasks = MutableLiveData<Int>()
    val numberOfActiveTasks: LiveData<Int> = _numberOfActiveTasks

    private val _numberOfCompletedTasks = MutableLiveData<Int>()
    val numberOfCompletedTasks: LiveData<Int> = _numberOfCompletedTasks

    private var activeTasks = 0

    private var completedTasks = 0

    fun start() {
        loadStatistics()
    }

    fun loadStatistics() {
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTasks().let { result ->
                if (result is Success) {
                    _error.value = false
                    computeStats(result.data)
                } else {
                    _error.value = true
                    activeTasks = 0
                    completedTasks = 0
                    updateDataBindingObservables()
                }
            }
        }
    }

    
    private fun computeStats(tasks: List<Task>) {
        var completed = 0
        var active = 0

        for (task in tasks) {
            if (task.isCompleted) {
                completed += 1
            } else {
                active += 1
            }
        }
        activeTasks = active
        completedTasks = completed

        updateDataBindingObservables()
    }

    private fun updateDataBindingObservables() {
        _numberOfCompletedTasks.value = completedTasks

        _numberOfActiveTasks.value = activeTasks

        _empty.value = activeTasks + completedTasks == 0
        _dataLoading.value = false
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp.addedittask

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class AddEditTaskViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    
    val title = MutableLiveData<String>()

    
    val description = MutableLiveData<String>()

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> =_dataLoading

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private val _taskUpdated = MutableLiveData<Event<Unit>>()
    val taskUpdatedEvent: LiveData<Event<Unit>> = _taskUpdated

    private var taskId: String? = null

    private var isNewTask: Boolean = false

    private var isDataLoaded = false

    private var taskCompleted = false

    fun start(taskId: String?) {
        _dataLoading.value?.let { isLoading ->
            
            if (isLoading) return
        }
        this.taskId = taskId
        if (taskId == null) {
            
            isNewTask = true
            return
        }
        if (isDataLoaded) {
            
            return
        }
        isNewTask = false
        _dataLoading.value = true

        viewModelScope.launch {
            tasksRepository.getTask(taskId).let { result ->
                if (result is Success) {
                    onTaskLoaded(result.data)
                } else {
                    onDataNotAvailable()
                }
            }
        }
    }

    private fun onTaskLoaded(task: Task) {
        title.value = task.title
        description.value = task.description
        taskCompleted = task.isCompleted
        _dataLoading.value = false
        isDataLoaded = true
    }

    private fun onDataNotAvailable() {
        _dataLoading.value = false
    }

    
    internal fun saveTask() {
        val currentTitle = title.value
        val currentDescription = description.value

        if (currentTitle == null || currentDescription == null) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }
        if (Task(currentTitle, currentDescription ?: "").isEmpty) {
            _snackbarText.value =  Event(R.string.empty_task_message)
            return
        }

        val currentTaskId = taskId
        if (isNewTask || currentTaskId == null) {
            createTask(Task(currentTitle, currentDescription))
        } else {
            val task = Task(currentTitle, currentDescription, currentTaskId)
                .apply { isCompleted = taskCompleted }
            updateTask(task)
        }
    }

    private fun createTask(newTask: Task) {
        viewModelScope.launch {
            tasksRepository.saveTask(newTask)
            _taskUpdated.value = Event(Unit)
        }
    }

    private fun updateTask(task: Task) {
        if (isNewTask) {
            throw RuntimeException("updateTask() was called but task is new.")
        }
        viewModelScope.launch {
            tasksRepository.saveTask(task)
            _taskUpdated.value = Event(Unit)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.tasks

import androidx.annotation.DrawableRes
import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksDataSource
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import com.example.android.architecture.blueprints.todoapp.util.ADD_EDIT_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.DELETE_RESULT_OK
import com.example.android.architecture.blueprints.todoapp.util.EDIT_RESULT_OK
import kotlinx.coroutines.launch
import java.util.ArrayList


class TasksViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _items = MutableLiveData<List<Task>>().apply { value = emptyList() }
    val items: LiveData<List<Task>> = _items

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _currentFilteringLabel = MutableLiveData<Int>()
    val currentFilteringLabel: LiveData<Int> = _currentFilteringLabel

    private val _noTasksLabel = MutableLiveData<Int>()
    val noTasksLabel: LiveData<Int> = _noTasksLabel

    private val _noTaskIconRes = MutableLiveData<Int>()
    val noTaskIconRes: LiveData<Int> = _noTaskIconRes

    private val _tasksAddViewVisible = MutableLiveData<Boolean>()
    val tasksAddViewVisible: LiveData<Boolean> = _tasksAddViewVisible

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    private var _currentFiltering = TasksFilterType.ALL_TASKS

    
    private val isDataLoadingError = MutableLiveData<Boolean>()

    private val _openTaskEvent = MutableLiveData<Event<String>>()
    val openTaskEvent: LiveData<Event<String>> = _openTaskEvent

    private val _newTaskEvent = MutableLiveData<Event<Unit>>()
    val newTaskEvent: LiveData<Event<Unit>> = _newTaskEvent

    
    val empty: LiveData<Boolean> = Transformations.map(_items) {
        it.isEmpty()
    }

    init {
        
        setFiltering(TasksFilterType.ALL_TASKS)
    }

    
    fun setFiltering(requestType: TasksFilterType) {
        _currentFiltering = requestType

        
        when (requestType) {
            TasksFilterType.ALL_TASKS -> {
                setFilter(R.string.label_all, R.string.no_tasks_all,
                    R.drawable.ic_assignment_turned_in_24dp, true)
            }
            TasksFilterType.ACTIVE_TASKS -> {
                setFilter(R.string.label_active, R.string.no_tasks_active,
                    R.drawable.ic_check_circle_24dp, false)
            }
            TasksFilterType.COMPLETED_TASKS -> {
                setFilter(R.string.label_completed, R.string.no_tasks_completed,
                    R.drawable.ic_verified_user_24dp, false)
            }
        }
    }

    private fun setFilter(@StringRes filteringLabelString: Int, @StringRes noTasksLabelString: Int,
            @DrawableRes noTaskIconDrawable: Int, tasksAddVisible: Boolean) {
        _currentFilteringLabel.value = filteringLabelString
        _noTasksLabel.value = noTasksLabelString
        _noTaskIconRes.value = noTaskIconDrawable
        _tasksAddViewVisible.value = tasksAddVisible
    }

    fun clearCompletedTasks() {
        viewModelScope.launch {
            tasksRepository.clearCompletedTasks()
            _snackbarText.value = Event(R.string.completed_tasks_cleared)
            loadTasks(false)
        }
    }

    fun completeTask(task: Task, completed: Boolean) {
        
        viewModelScope.launch {
            if (completed) {
                tasksRepository.completeTask(task)
                showSnackbarMessage(R.string.task_marked_complete)
            } else {
                tasksRepository.activateTask(task)
                showSnackbarMessage(R.string.task_marked_active)
            }
        }
    }

    
    fun addNewTask() {
        _newTaskEvent.value = Event(Unit)
    }

    
    internal fun openTask(taskId: String) {
        _openTaskEvent.value = Event(taskId)
    }

    fun showEditResultMessage(result: Int) {
        when (result) {
            EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_saved_task_message)
            )
            ADD_EDIT_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_added_task_message)
            )
            DELETE_RESULT_OK -> _snackbarText.setValue(
                Event(R.string.successfully_deleted_task_message)
            )
        }

    }

    private fun showSnackbarMessage(message: Int) {
        _snackbarText.value = Event(message)
    }

    
    fun loadTasks(forceUpdate: Boolean) = viewModelScope.launch {

        _dataLoading.value = true
        val tasksResult = tasksRepository.getTasks(forceUpdate)

        if (tasksResult is Success) {
            val tasks = tasksResult.data

            val tasksToShow = ArrayList<Task>()
            
            for (task in tasks) {
                when (_currentFiltering) {
                    TasksFilterType.ALL_TASKS -> tasksToShow.add(task)
                    TasksFilterType.ACTIVE_TASKS -> if (task.isActive) {
                        tasksToShow.add(task)
                    }
                    TasksFilterType.COMPLETED_TASKS -> if (task.isCompleted) {
                        tasksToShow.add(task)
                    }
                }
            }
            _dataLoading.value = false
            isDataLoadingError.value = false

            val itemsValue = ArrayList(tasksToShow)
            _items.value = itemsValue
        } else {
            _dataLoading.value = false
            isDataLoadingError.value = false
            _items.value = emptyList()
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.taskdetail

import androidx.annotation.StringRes
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Transformations
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.android.architecture.blueprints.todoapp.Event
import com.example.android.architecture.blueprints.todoapp.R
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.TasksRepository
import kotlinx.coroutines.launch


class TaskDetailViewModel(
    private val tasksRepository: TasksRepository
) : ViewModel() {

    private val _task = MutableLiveData<Task>()
    val task: LiveData<Task> = _task

    private val _isDataAvailable = MutableLiveData<Boolean>()
    val isDataAvailable: LiveData<Boolean> = _isDataAvailable

    private val _dataLoading = MutableLiveData<Boolean>()
    val dataLoading: LiveData<Boolean> = _dataLoading

    private val _editTaskCommand = MutableLiveData<Event<Unit>>()
    val editTaskCommand: LiveData<Event<Unit>> = _editTaskCommand

    private val _deleteTaskCommand = MutableLiveData<Event<Unit>>()
    val deleteTaskCommand: LiveData<Event<Unit>> = _deleteTaskCommand

    private val _snackbarText = MutableLiveData<Event<Int>>()
    val snackbarMessage: LiveData<Event<Int>> = _snackbarText

    
    val completed: LiveData<Boolean> = Transformations.map(_task) { input: Task? ->
        input?.isCompleted ?: false
    }

    val taskId: String?
        get() = _task.value?.id

    fun deleteTask() {
        taskId?.let {
            viewModelScope.launch {
                tasksRepository.deleteTask(it)
                _deleteTaskCommand.value = Event(Unit)
            }
        }
    }

    fun editTask() {
        _editTaskCommand.value = Event(Unit)
    }

    fun setCompleted(completed: Boolean) {
        val task = _task.value ?: return
        viewModelScope.launch {
            if (completed) {
                tasksRepository.completeTask(task)
                showSnackbarMessage(R.string.task_marked_complete)
            } else {
                tasksRepository.activateTask(task)
                showSnackbarMessage(R.string.task_marked_active)
            }
        }
    }

    fun start(taskId: String?) {
        if (taskId != null) {
            _dataLoading.value = true
            viewModelScope.launch {
                tasksRepository.getTask(taskId, false).let { result ->
                    if (result is Success) {
                        onTaskLoaded(result.data)
                    } else {
                        onDataNotAvailable(result)
                    }
                }
            }
        }
    }

    private fun setTask(task: Task?) {
        this._task.value = task
        _isDataAvailable.value = task != null
    }

    private fun onTaskLoaded(task: Task) {
        setTask(task)
        _dataLoading.value = false
    }

    private fun onDataNotAvailable(result: Result<Task>) {
        _task.value = null
        _dataLoading.value = false
        _isDataAvailable.value = false
    }

    fun onRefresh() {
        taskId?.let { start(it) }
    }

    private fun showSnackbarMessage(@StringRes message: Int) {
        _snackbarText.value = Event(message)
    }
}

<code block>


package com.example.android.architecture.blueprints.todoapp

import org.junit.Assert
import org.junit.Assert.fail

fun assertNonNullTrue(b: Boolean?) = Assert.assertTrue(b == true)

fun assertNonNullFalse(b: Boolean?) = Assert.assertTrue(b == false)

fun assertNonNullEquals(one: Any?, two: Any?) {
    if (one == null && two == null) return fail("Both sides are null")
    return Assert.assertEquals(one, two)
}

<code block>

package com.example.android.architecture.blueprints.todoapp.data.source

import androidx.annotation.VisibleForTesting
import com.example.android.architecture.blueprints.todoapp.data.Result
import com.example.android.architecture.blueprints.todoapp.data.Result.Error
import com.example.android.architecture.blueprints.todoapp.data.Result.Success
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.google.common.collect.Lists
import java.util.LinkedHashMap


object FakeRepository : TasksRepository {

    private var TASKS_SERVICE_DATA: LinkedHashMap<String, Task> = LinkedHashMap()

    override suspend fun getTask(taskId: String, forceUpdate: Boolean): Result<Task> {
        TASKS_SERVICE_DATA[taskId]?.let {
            return Success(it)
        }
        return Error(Exception("Could not find task"))
    }

    override suspend fun getTasks(forceUpdate: Boolean): Result<List<Task>> {
        return Success(Lists.newArrayList(TASKS_SERVICE_DATA.values))
    }

    override suspend fun saveTask(task: Task) {
        TASKS_SERVICE_DATA.put(task.id, task)
    }

    override suspend fun completeTask(task: Task) {
        val completedTask = Task(task.title, task.description, task.id)
        completedTask.isCompleted = true
        TASKS_SERVICE_DATA.put(task.id, completedTask)
    }

    override suspend fun completeTask(taskId: String) {
        
    }

    override suspend fun activateTask(task: Task) {
        val activeTask = Task(task.title, task.description, task.id)
        TASKS_SERVICE_DATA.put(task.id, activeTask)
    }

    override suspend fun activateTask(taskId: String) {
        
    }

    override suspend fun clearCompletedTasks() {
        TASKS_SERVICE_DATA = TASKS_SERVICE_DATA.filterValues {
            !it.isCompleted
        } as LinkedHashMap<String, Task>
    }

    override suspend fun deleteTask(taskId: String) {
        TASKS_SERVICE_DATA.remove(taskId)
    }

    override suspend fun deleteAllTasks() {
        TASKS_SERVICE_DATA.clear()
    }

    @VisibleForTesting
    fun addTasks(vararg tasks: Task) {
        for (task in tasks) {
            TASKS_SERVICE_DATA.put(task.id, task)
        }
    }
}

<code block>

package com.example.android.architecture.blueprints.todoapp.statistics

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.android.architecture.blueprints.todoapp.FakeFailingTasksRemoteDataSource
import com.example.android.architecture.blueprints.todoapp.LiveDataTestUtil
import com.example.android.architecture.blueprints.todoapp.ViewModelScopeMainDispatcherRule
import com.example.android.architecture.blueprints.todoapp.data.Task
import com.example.android.architecture.blueprints.todoapp.data.source.DefaultTasksRepository
import com.example.android.architecture.blueprints.todoapp.data.source.FakeRepository
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.runBlocking
import org.hamcrest.MatcherAssert.assertThat
import org.hamcrest.core.Is.`is`
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test


class StatisticsViewModelTest {

    
    @get:Rule
    var instantExecutorRule = InstantTaskExecutorRule()

    private lateinit var statisticsViewModel: StatisticsViewModel
    private val tasksRepository = FakeRepository

    
    @ExperimentalCoroutinesApi
    @get:Rule
    var coroutinesMainDispatcherRule = ViewModelScopeMainDispatcherRule()

    @Before
    fun setupStatisticsViewModel() {
        
        val task1 = Task("Title1", "Description1")
        val task2 = Task("Title2", "Description2").apply {
            isCompleted = true
        }
        val task3 = Task("Title3", "Description3").apply {
            isCompleted = true
        }
        tasksRepository.addTasks(task1, task2, task3)

        statisticsViewModel = StatisticsViewModel(tasksRepository)
    }

    @Test
    fun loadEmptyTasksFromRepository_EmptyResults() = runBlocking {
        
        tasksRepository.deleteAllTasks()

        
        statisticsViewModel.loadStatistics()

        
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.empty), `is`(true))
    }

    @Test
    fun loadNonEmptyTasksFromRepository_NonEmptyResults() = runBlocking {
        
        statisticsViewModel.loadStatistics()

        
        assertThat(LiveDataTestUtil.getValue(statisticsViewModel.empty), `is`(false))
    }

    @Test
    fun loadStatisticsWhenTasksAreUnavailable_CallErrorToDisplay() = runBlocking {
        val errorViewModel = StatisticsViewModel(
            DefaultTasksRepository(
                FakeFailingTasksRemoteDataSource,
                FakeFailingTasksRemoteDataSource)
        )

        
        errorViewModel.loadStatistics()

        
        assertEquals(LiveDataTestUtil.getValue(errorViewModel.empty), true)
        assertEquals(LiveDataTestUtil.getValue(errorViewModel.error), true)
    }
}

<code block>







































































































<code block>














































































































































































































































<code block>
































































































































































